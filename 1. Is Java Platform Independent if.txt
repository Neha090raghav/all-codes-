java and multithreading
java 8 eature
collections
indexing
garabage collectors
try and catch
exception

springbot
hibernate
design patters


daily practice
java intervw
questions
MySQL
spring


react js
interview
react redux
js
js interview
css
typescript
codetech



https://www.youtube.com/playlist?list=PL6W8uoQQ2c63f469AyV78np0rbxRFppkx->important ideo please watch before interview

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
1. Is Java Platform Independent if then how?
*Yes, Java is a Platform Independent language
*Unlike many programming languages javac compiles the program to form a bytecode or .class file
*This file is independent of the software or hardware running but needs a JVM(Java Virtual Machine) file preinstalled in the operating system for further execution of the bytecode.
*Although JVM is platform dependent
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
2. What are the top Java Features?
Simple: Java is quite simple to understand and the syntax
Platform Independent: Java is platform independent means we can run the same program in any software and hardware and will get the same result.
Interpreted: Java is interpreted as well as a compiler-based language. 
Object-Oriented: Java is an object-oriented language that supports the concepts of class,  objects, four pillars of OOPS, etc.
Multithreaded: deal with multiple tasks at once by defining multiple threads
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
3. What is JVM?
*VM stands for Java Virtual Machine it is a Java interpreter
*It is responsible for loading, verifying, and executing the bytecode created in Java.
*Although it is platform dependent which means the software of JVM is different for different Operating Systems it plays a vital role in making Java platform Independent.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
4. What is JIT?
*JIT stands for (Just-in-Time) compiler is a part of JRE(Java Runtime Environment),
* it is used for better performance of the Java applications during run-time.
*Source code is compiled with javac to form bytecode
Bytecode is further passed on to JVM 
JIT is a part of JVM, JIT is responsible for compiling bytecode into native machine code at run time.
The JIT compiler is enabled throughout, while it gets activated when a method is invoked. For a compiled method, the JVM directly calls the compiled code, instead of interpreting it.
As JVM calls the compiled code that increases the performance and speed of the execution.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
5. What are Memory storages available with JVM?
*Class(Method) Area: stores class-level data of every class such as the runtime constant pool, field, and method data, and the code for methods.
Heap: Objects are created or objects are stored. It is used to allocate memory to objects during run time.
Stack: stores data and partial results which will be needed while returning value for method and performing dynamic linking
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------6.6. What is a classloader?
*Classloader is the part of JRE(Java Runtime Environment), during the execution of the bytecode or created .class file classloader is responsible for dynamically loading the java classes and interfaces to JVM(Java Virtual Machine).
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
7.7. Difference between JVM, JRE, and JDK.

JVM: JVM also known as Java Virtual Machine is a part of JRE. JVM is a type of interpreter responsible for converting bytecode into machine-readable code. JVM itself is platform dependent but it interprets the bytecode which is the platform-independent reason why Java is platform-independent. 

JRE: JRE stands for Java Runtime Environment, it is an installation package that provides an environment to run the Java program or application on any machine.

JDK: JDK stands for Java Development Kit which provides the environment to develop and execute Java programs. JDK is a package that includes two things Developmen

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
8. What are the differences between Java and C++?
*Basis

C++

Java

Platform                   

C++ is Platform Dependent

Java is Platform Independent

Application

C++ is mainly used for System Programming

Java is Mainly used for Application Programming

Hardware

C++ is nearer to hardware

Java is not so interactive with hardware

Global Scope

C++ supports global and namespace scope.

Java doesn't support global scope.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------9. Explain public static void main(String args[]) in Java.

*public: the public is the access modifier responsible for mentioning who can access the element or the method and what is the limit.  It is responsible for making the main function globally available. It is made public so that JVM can invoke it from outside the class as it is not present in the current class.
*static: static is a keyword used so that we can use the element without initiating the class so to avoid the unnecessary allocation of the memory. 
*void: void is a keyword and is used to specify that a method doesn‚Äôt return anything. As the main function doesn't return anything we use void.
main: main represents that the function declared is the main function. It helps JVM to identify that the declared function is the main function.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
10. What is Java String Pool?
*A Java String Pool is a place in heap memory where all the strings defined in the program are stored
*A separate place in a stack is there where the variable storing the string is stored. 
*Whenever we create a new string object, JVM checks for the presence of the object in the String pool, If String is available in the pool, the same object reference is shared with the variable, else a new object is created.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
11. What will happen if we don't declare the main as static?
*We can declare the main method without using static and without getting any errors. But, the main method will not be treated as the entry point to the application or the program.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
12. What are Packages in Java?
*Packages in Java can be defined as the grouping of related types of classes, interfaces, etc 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
13.13. Why Packages are used?
1.Advantages of Packages in Java:

Avoid Name Clashes:

Packages prevent naming conflicts by providing a unique namespace for classes, interfaces, and other types. If two classes have the same name but are in different packages, they can coexist without conflict.
For example, you could have com.company1.util.Logger and com.company2.util.Logger without any naming issues, as the package structure differentiates them.
This is particularly useful in large projects or when using third-party libraries, where class names might overlap.


2.Easier Access Control
*Packages work with Java‚Äôs access modifiers (public, protected, private, and default) to control access to classes, methods, and fields.
*Java provides access modifiers like public, protected, private, and default (no modifier). When using packages, the default access makes a class or method visible only within the same package, helping in restricting access.
*Java provides access modifiers like public, protected, private, and default (no modifier). When using packages, the default access makes a class or method visible only within the same package, helping in restricting access.
*// In package com.company
package com.company;
class Employee {  // default access
    void display() {
        System.out.println("Employee details");
    }
}
now if we use this in the other package then the error
*// In package com.client
package com.client;
import com.company.Employee; // ‚ùå Compile error

public class Test {
    public static void main(String[] args) {
        Employee emp = new Employee();  // ‚ùå Not accessible
    }
}



3.‚úÖ 3. We can have hidden classes that are not visible outside the package
üí° Meaning:
If a class is package-private (i.e., no public modifier), it is hidden from other packages but accessible within the same package.
// Hidden helper class
package com.utils;
class MathHelper {
    static int square(int x) {
        return x * x;
    }
}

// Public class using the helper internally
package com.utils;
public class Calculator {
    public int calculateSquare(int num) {
        return MathHelper.square(num); // ‚úÖ Accessible inside package
    }
}
From outside the com.utils package, you can use Calculator but not MathHelper:
import com.utils.Calculator; // ‚úÖ

public class Test {
    public static void main(String[] args) {
        Calculator c = new Calculator();
        System.out.println(c.calculateSquare(4)); // 16

        // MathHelper is not accessible here ‚ùå
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------15. How many types of packages are there in Java?
1. Built-in Packages (Predefined Packages)
*hese are predefined packages provided by Java Standard Library (JDK). You can directly import and use them in your code.
*Examples of built-in packages:
java.lang ‚Äì Contains fundamental classes like String, Math, Integer (imported by default)

java.util ‚Äì Contains utility classes like ArrayList, HashMap, Date

java.io ‚Äì For input/output like File, BufferedReader, FileInputStream

java.net ‚Äì For networking

java.sql ‚Äì For database access


import java.util.ArrayList;

public class BuiltInExample {
    public static void main(String[] args) {
        ArrayList<String> fruits = new ArrayList<>();
        fruits.add("Apple");
        fruits.add("Mango");
        System.out.println(fruits); // Output: [Apple, Mango]
    }
}



2.user defined packages
These are packages created by the programmer to organize their own classes in a modular way.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------v
17. When a byte datatype is used?
*A byte is an 8-bit signed two-complement integer
*The minimum value supported by bytes is -128 and 127 is the maximum value.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
18. Can we declare Pointer in Java?
*No, Java doesn't provide the support of Pointer.
*As Java needed to be more secure because which feature of the pointer is not provided in Java.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
19. What is the default value of byte datatype in Java?
*The default value of the byte datatype in Java is 0.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
20. What is the default value of float and double datatype in Java?
*The default value of the float is 0.0f and of double is 0.0d in Java.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
21. What is the Wrapper class in Java?
*Wrapper, in general, is referred to a larger entity that encapsulates a smaller entity. Here in Java, the wrapper class is an object class that encapsulates the primitive data types. 
*The primitive data types are the ones from which further data types could be created. For example, integers can further lead to the construction of long, byte, short, etc. On the other hand, the string cannot, hence it is not primitive
*Getting back to the wrapper class, Java contains 8 wrapper classes. They are Boolean, Byte, Short, Integer, Character, Long, Float, and Double.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
22. Why do we need wrapper classes?
1.1. Wrapper Classes are Final and Immutable
*Final means the class cannot be subclassed (i.e., no one can extend Integer, Double, etc.).
*. Provides Methods like valueOf(), parseInt(), etc.
2.Wrapper classes provide utility methods for converting between strings and primitives:

java
Copy
Edit
String s = "123";
int x = Integer.parseInt(s);       // Converts string to primitive int
Integer y = Integer.valueOf(s);    // Converts string to Integer object
Each wrapper class includes similar methods:

parseXxx(String) ‚Üí returns primitive

valueOf(String) ‚Üí returns wrapper object

toString() ‚Üí converts primitive/wrapper to string

3.3. Autoboxing and Unboxing
Java automatically converts between primitives and wrapper objects
int x = 5;
Integer obj = x;   // autoboxing
int x = 5;
Integer obj = x;   // autoboxing
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
23. Differentiate between instance and local variables.

*Instance Variable

Local Variable

Declared outside the method, directly invoked by the method.

Declared within the method.                                                              

Has a default value.

No default value

It can be used throughout the class.

The scope is limited to the method.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
24. What are the default values assigned to variables and instances in Java
*In Java When we haven‚Äôt initialized the instance variables then the compiler initializes them with default values. The default values for instances and variables depend on their data types. Some common types of default data types are:

The default value for numeric types (byte, short, int, long, float, and double) is 0.
The default value for the boolean type is false.
The default value for object types (classes, interfaces, and arrays) is null.
The null character, "u0000, " is the default value for the char type.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
25.25. What is a Class Variable?
*n Java, a class variable (also known as a static variable) is a variable that is declared within a class but outside of any method, constructor, or block. 
*Class variables are declared with the static keyword, and they are shared by all instances (objects) of the class as well as by the class itself. No matter how many objects are derived from a class, each class variable would only exist once.
*the static variable PI is accessed directly inside the class because:

In Java, static variables can be accessed directly by their name within the same class.
Outside the class, you must use GFG.PI to access it.


// Java program to demonstrate use of Clas Variable
class GFG {
    public static int ctr = 0;
    public GFG() { ctr++; }
    public static void main(String[] args)
    {
        GFG obj1 = new GFG();
        GFG obj2 = new GFG();
        GFG obj3 = new GFG();
        System.out.println("Number of objects created are "
                           + GFG.ctr);
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
26. What is the default value stored in Local Variables?
*There is no default value stored with local variables. Also, primitive variables and objects don't have any default values.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
27. Explain the difference between instance variable and a class variable.
*Instance Variable: A class variable without the static modifier is called an instance variable. It is unique to each object (instance) of the class and is not shared between instances.
// Java Program to demonstrate Instance Variable
import java.io.*;
class GFG {
    private String name;
    public void setName(String name) { this.name = name; }
    public String getName() { return name; }
    public static void main(String[] args)
    {
        GFG obj = new GFG();
        obj.setName("John");
        System.out.println("Name " + obj.getName());
    }
}

Class Variable:  Class Variable variable can be declared anywhere at the class level using the keyword static. These variables can only have one value when applied to various objects. These variables can be shared by all class members since they are not connected to any specific object of the class.
*// Java Program to demonstrate Class Variable
import java.io.*;
class GFG {
    // class variable
    private static final double PI = 3.14159;
    private double radius;
    public GFG(double radius) { this.radius = radius; }
    public double getArea() { return PI * radius * radius; }
    public static void main(String[] args)
    {
        GFG obj = new GFG(5.0);
        System.out.println("Area of circle: "
                           + obj.getArea());
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
28. What is a static variable?
*The static keyword is used to share the same variable or method of a given class. Static variables are the variables that once declared then a single copy of the variable is created and shared among all objects at the class level.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
29. What is the difference between System.out, System.err, and System.in?
1.System.out - It is a PrintStream that is used for writing characters or can be said it can output the data we want to write on the Command Line Interface console/terminal.
// Java Program to implement
// System.out
import java.io.*;
// Driver Class
class GFG {
    // Main Function
    public static void main(String[] args)
    {
        // Use of System.out
        System.out.println("");
    }
}

2.System.err - It is used to display error messages.
*// Java program to demonstrate
// System.err
import java.io.*;
// Driver Class
class GFG {
    // Main function
    public static void main(String[] args)
    {
        // Printing error
        System.err.println(
            "This is how we throw error with System.err");
    }
}

3.System.in - It is an InputStream used to read input from the terminal Window. We can't use the System.in directly so we use Scanner class for taking input with the system.in.
// Java Program to demonstrate
// System.in
import java.util.*;
// Driver Class
class Main {
    // Main Function
    public static void main(String[] args)
    {
        // Scanner class with System.in
        Scanner sc = new Scanner(System.in);
        // Taking input from the user
        int x = sc.nextInt();
        int y = sc.nextInt();
        // Printing the output
        System.out.printf("Addition: %d", x + y);
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
30. What do you understand by an IO stream?
*Java brings various Streams with its I/O package that helps the user to perform all the input-output operations.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
31. What is the difference between the Reader/Writer class hierarchy and the InputStream/OutputStream class hierarchy?
*The key difference between them is that byte stream data is read and written by input/output stream classes
*Characters are handled by the Reader and Writer classes.
*Aspect	           InputStream/OutputStream  (Byte Streams)	       Reader/Writer (Character Streams)
Data Type Handled	 Raw bytes (byte, byte[])	       Characters (char, char[])
Base Classes	           InputStream / OutputStream	       Reader / Writer
Used For	Binary data: images, audio, PDF, video, etc.	Textual data: .txt, .xml, .html, .csv, etc
ncoding Support	No ‚Äî doesn‚Äôt handle character encoding	Yes ‚Äî handles encoding like UTF-8, UTF-16
ypical Use Cases	File copying, sending binary data over network	Reading/writing text files, console I/O


 1. InputStream/OutputStream Hierarchy (Byte Stream)
Used when working with binary data.

Reads and writes data as bytes.

Example subclasses:

FileInputStream

BufferedInputStream

DataOutputStream

InputStream is = new FileInputStream("image.png");
byte[] buffer = new byte[1024];
is.read(buffer);




2.2. Reader/Writer Hierarchy (Character Stream)
Used when working with character/text data.

Reads and writes data as characters.

Supports Unicode and character encoding.

Example subclasses:

FileReader, FileWriter

BufferedReader, BufferedWriter
Reader reader = new FileReader("data.txt");
char[] chars = new char[100];
reader.read(chars);


Note :here input stram is the parent abstract class which has some functionality and fileinout stream extend the parent class so that all the subclass can have the common functionality
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
32. What are the super most classes for all the streams?
*All the stream classes can be divided into two types of classes that are ByteStream classes and CharacterStream Classes. The ByteStream classes are further divided into InputStream classes and OutputStream classes. CharacterStream classes are also divided into Reader classes and Writer classes. The SuperMost classes for all the InputStream classes is java.io.InputStream and for all the output stream classes is java.io.OutPutStream. Similarly, for all the reader classes, the super-most class is java.io.Reader, and for all the writer classes, it is java.io.Writer.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
33. What are the FileInputStream and FileOutputStream?
*FileInputStream class in Java is useful for reading data from a file in the form of a Java sequence of bytes.
*
import java.io.FileInputStream;
import java.io.IOException;

public class FileInputStreamExample {
    public static void main(String[] args) {
        FileInputStream fis = null;

        try {
            // Open the file sample.txt
            fis = new FileInputStream("sample.txt");

            int byteData;

            // Read each byte one by one until end of file (-1)
            while ((byteData = fis.read()) != -1) {
                // Convert byte to character and print
                System.out.print((char) byteData);
            }
        } catch (IOException e) {
            System.out.println("An error occurred: " + e.getMessage());
        } finally {
            try {
                if (fis != null) {
                    fis.close(); // Always close the stream
                }
            } catch (IOException e) {
                System.out.println("Error closing the stream");
            }
        }
    }
}
Code	Meaning
FileInputStream fis = new FileInputStream("sample.txt");	Opens sample.txt for reading byte-by-byte
fis.read()	Reads a single byte, returns its int value (0‚Äì255), or -1 if end of file
(char) byteData	Converts the byte value to a character
while ((byteData = fis.read()) != -1)	Keeps reading until no more data
fis.close()	Closes the file to free system resources
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
34. What is the purpose of using BufferedInputStream and BufferedOutputStream classes?
*BufferedInputStream and BufferedOutputStream are used to increase the performance of input/output operations by reducing the number of direct interactions with the underlying disk or network.
*How It Works:
Without buffering: Every read/write operation interacts directly with the file or stream, which is slow.

With buffering: A buffer (byte array) is used to temporarily store data.

Data is read/written in larger chunks, not one byte at a time.

This reduces I/O calls to the disk or network and improves performance.
*BufferedInputStream bis = new BufferedInputStream(new FileInputStream("file.txt"));
BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("file.txt"));

import java.io.*;

public class BufferedInputExample {
    public static void main(String[] args) throws IOException {
        FileInputStream fis = new FileInputStream("sample.txt");
        BufferedInputStream bis = new BufferedInputStream(fis);

        int byteData;
        while ((byteData = bis.read()) != -1) {
            System.out.print((char) byteData);
        }

        bis.close(); // also closes fis
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
36. What is an I/O filter?
*An I/O Filter in Java is a stream that acts as a wrapper around another stream to modify, enhance, or filter the data being read or written.
*as in above example the bufferedinput stream is wrapper oustside fileinput steam calss

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
37. How many ways you can take input from the console?
1.Using Command line argument
// Java Program to implement input
// using Command line argument
import java.io.*;
class GFG {
    public static void main(String[] args)
    {
        // check if length of args array is
        // greater than 0
        if (args.length > 0) {
            System.out.println(
                "The command line arguments are:");
            // iterating the args array and printing
            // the command line arguments
            for (String val : args)
                System.out.println(val);
        }
        else
            System.out.println("No command line "
                               + "arguments found.");
    }
}
// Use below commands to run the code
// javac GFG.java
// java Main GeeksforGeeks


2.// Java Program to implement
// Buffer Reader Class
import java.io.*;
class GFG {
    public static void main(String[] args)
        throws IOException
    {
        // Enter data using BufferReader
        BufferedReader read = new BufferedReader(
            new InputStreamReader(System.in));
        // Reading data using readLine
        String x = read.readLine();
        // Printing the read line
        System.out.println(x);
    }
}

3.// Java program to implement input
// Using Console Class
public class GfG {
    public static void main(String[] args)
    {
        // Using Console to input data from user
        String x = System.console().readLine();
        System.out.println("You entered string " + x);
    }
}

4.// Java program to demonstrate
// working of Scanner in Java
import java.util.Scanner;
class GfG {
    public static void main(String args[])
    {
        // Using Scanner for Getting Input from User
        Scanner in = new Scanner(System.in);
        String str = in.nextLine();
        System.out.println("You entered string " + str);
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------


38. Difference in the use of print, println, and printf.


 1. print()
Prints the text as-is.

Cursor remains on the same line after printing.

Does not add a new line at the end.

üßæ Example:
java
Copy
Edit
System.out.print("Hello ");
System.out.print("World!");
Output:

nginx
Copy
Edit
Hello World!
üîπ 2. println()
Prints the text.

Then moves the cursor to the next line.

Adds a newline character (\n) at the end.

üßæ Example:
java
Copy
Edit
System.out.println("Hello");
System.out.println("World!");
Output:

nginx
Copy
Edit
Hello
World!
üîπ 3. printf()
Stands for print formatted.

Used to print formatted strings, similar to C‚Äôs printf.

Supports format specifiers like %d, %s, %f, etc.

üßæ Example:
java
Copy
Edit
int age = 25;
String name = "Neha";
System.out.printf("Name: %s, Age: %d", name, age);
Output:

yaml
Copy
Edit
Name: Neha, Age: 25
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is a Covariant Return Type in Java?
*Covariant return type means that when overriding a method, the return type of the overriding method in the child class can be a subclass of the return type declared in the parent class.

This feature was introduced in Java 5 to allow more specific return types in overridden methods.
class Animal {}

class Dog extends Animal {}

class AnimalFactory {
    Animal getAnimal() {
        return new Animal();
    }
}

class DogFactory extends AnimalFactory {
    @Override
    Dog getAnimal() { // ‚úÖ Covariant return type
        return new Dog();
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
45. What is the transient keyword?
*During serialization, Java saves the state of an object into a stream. However, some fields:

may contain sensitive information (like passwords),

or are not meaningful to save (like cached values or temporary data).
*sing transient on such fields tells the JVM:

‚ùå ‚ÄúDon‚Äôt serialize this field ‚Äî just skip it.‚Äù
import java.io.*;

class User implements Serializable {
    String username;
    transient String password; // üëà will not be serialized

    User(String username, String password) {
        this.username = username;
        this.password = password;
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
46. What's the difference between the methods sleep() and wait()?
*Sleep()

Wait()

The sleep() method belongs to the thread class.

Wait() method belongs to the object class.
This method is a static method.

This method is not a static method.
Sleep does not release the lock that the current thread holds.

wait() release the lock which allows other threads to acquire it.
Mainly used to delay a thread for some specific time duration.

Mainly used to pause a thread until notified by another thread.
Sleep() Has Two Overloaded Methods:

sleep(long millis)millis: milliseconds
sleep(long millis, int nanos) nanos: Nanoseconds
Wait() Has Three Overloaded Methods:

wait()
wait(long timeout)
wait(long timeout, int nanos)


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
47. What are the differences between String and StringBuffer?
*Feature	String	StringBuffer
Definition	A sequence of characters (text)	A mutable sequence of characters
Mutability	‚ùå Immutable ‚Äî once created, cannot be changed	‚úÖ Mutable ‚Äî can be modified without creating new objects
Performance	Slower when performing multiple modifications (due to object creation)	Faster for frequent string modifications (e.g., appending, inserting)
Thread-safety	‚ùå Not thread-safe	‚úÖ Thread-safe ‚Äî all methods are synchronized
Use case	When you don't need to modify the string content	When you need to modify string content frequently in a thread-safe way


String s immutable 
String s = "Hello";
s.concat(" World");
System.out.println(s); // Output: Hello (original not changed)


StringBuffer sb = new StringBuffer("Hello");
sb.append(" World");
System.out.println(sb); // Output: Hello World

Note:StringBuffer sb = "Hello"; // ‚ùå Compilation error: incompatible types
‚úÖ Explanation:
"Hello" is a String literal, so it can only be directly assigned to a String variable.

To create a StringBuffer from a string, use: new StringBuffer("Hello").
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
48. What are the differences between StringBuffer and StringBuilder?
*Feature	StringBuffer	StringBuilder
Mutability	Mutable	Mutable
Thread-safety	‚úÖ Yes (synchronized)	‚ùå No (not synchronized)
Performance	Slower due to synchronization overhead	Faster as there is no synchronization
Use Case	Use when multiple threads are accessing and modifying the same string	Use in single-threaded scenarios for better performance

// StringBuffer: Thread-safe
StringBuffer sb1 = new StringBuffer("Hello");
sb1.append(" World");
System.out.println(sb1); // Output: Hello World

// StringBuilder: Not thread-safe, but faster
StringBuilder sb2 = new StringBuilder("Hello");
sb2.append(" Java");
System.out.println(sb2); // Output: Hello Java
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
49. Which among String Builder or String Buffer should be preferred when there are a lot of updates required to be done in the data?
String is immutable, making it inefficient for scenarios requiring frequent updates. Instead, we can use StringBuilder or StringBuffer. If thread safety is required (synchronized operations), StringBuffer should be used. However, if performance is a priority in a single-threaded context, StringBuilder is the better choice since it is faster and does not incur synchronization overhead.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
50. Why is StringBuffer called mutable?
*StringBuffer class in Java is used to represent a changeable string of characters. It offers an alternative to the immutable String class by enabling you to change a string's contents without constantly creating new objects. Mutable (modifiable) strings are created with the help of the StringBuffer class. The StringBuffer class in Java is identical to the String class except that it is changeable.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
51. How is the creation of a String using new() different from that of a literal?
*1. String literals and the String Pool
When you write:

java
Copy
Edit
1.String s1 = "ABC";
"ABC" is a String literal.

Java keeps all literals in a special memory area called the String Constant Pool (SCP), which is part of the heap, not the stack.

If the literal "ABC" already exists in the pool, Java reuses the reference instead of creating a new object.

This saves memory and improves performance.
String s1 = "ABC";
String s2 = "ABC"; // Reuses same "ABC" object from SCP

2.2. String creation using new
When you write:

java
Copy
Edit
String s3 = new String("ABC");
"ABC" literal still goes into the String Constant Pool if it‚Äôs not already there.

new String("ABC") always creates a new object in the heap, outside the SCP.

So here, you end up with two objects:

"ABC" in the String Pool

A new "ABC" in the normal heap memory

String s1 = "ABC";
String s2 = new String("ABC");
System.out.println(s1 == s2); // false (different references)
System.out.println(s1.equals(s2)); // true (same content)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
52. What is an array in Java?
*An Array in Java is a data structure that is used to store a fixed-size sequence of elements of the same type. Elements of an array can be accessed by their index, which starts from 0 and goes up to a length of minus 1. Array declaration in Java is done with the help of square brackets and size is also specified during the declaration. 

Syntax:

int[] Arr = new int[5]; 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
53. On which memory arrays are created in Java?
*Arrays in Java are created in heap memory. When an array is created with the help of a new keyword, memory is allocated in the heap to store the elements of the array. In Java, the heap memory is managed by the Java Virtual Machine(JVM) and it is also shared between all threads of the Java Program.
*The memory which is no longer in use by the program, JVM uses a garbage collector to reclaim the memory
*Arrays in Java are created dynamically which means the size of the array is determined during the runtime of the program. The size of the array is specified during the declaration of the array and it cannot be changed once the array is created.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*56. What is the difference between int array[] and int[] array?
*Both int array[] and int[] array are used to declare an array of integers in java. The only difference between them is on their syntax no functionality difference is present between them.

int arr[] is a C-Style syntax to declare an Array.
int[] arr is a Java-Style syntax to declare an Array.
However, it is generally recommended to use Java-style syntax to declare an Array. As it is easy to read and understand also it is more consiste
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
57. How to copy an array in Java?
1.clone() method
*Creates a new array object with the same length as the original.

Copies all elements into the new array.

For primitive arrays (like int[]), values are copied directly (deep copy).

For object arrays (like String[]), only references are copied (shallow copy)


Examples :int[] a = {1, 2, 3};
int[] b = a.clone();
b[0] = 99;
System.out.println(a[0]); // Still 1 ‚Üí deep copy


String[] x = {"A", "B"};
String[] y = x.clone();
y[0] = "Z"; // Changes reference in y only, but...
System.out.println(x[0]); // Still "A" ‚Üí separate references
Note:here as the strings are immutable


2.2. System.arraycopy() Method
*same thing for shallow and  deep as above
*but here we can make the paryila copy possible 
int[] arr = {1, 2, 7, 9, 8};
int[] tempArr = new int[arr.length];
System.arraycopy(arr, 0, tempArr, 0, arr.length);



3.3 Arrays.copyOf() Method
*just the array size can be increased or decreased
*Creates a new array of the given length.

Copies elements from original array to the new one.

If the new length is larger, remaining elements are filled with default values (0 for int, null for objects).

If the new length is smaller, the array is truncated.
*import java.util.Arrays;

int[] arr = {1, 2, 4, 8};
int[] tempArr = Arrays.copyOf(arr, arr.length);

int[] a = {1, 2, 3};
int[] bigger = Arrays.copyOf(a, 5); // {1, 2, 3, 0, 0}
int[] smaller = Arrays.copyOf(a, 2); // {1, 2}







4.44. Arrays.copyOfRange() Method
java
Copy
Edit
int[] arr = {1, 2, 4, 8};
int[] tempArr = Arrays.copyOfRange(arr, 0, arr.length);
How it works:

Similar to copyOf(), but lets you choose start and end index.

End index is exclusive (like substring in Java).
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
58. What do you understand by the jagged array?
*A jagged Array in Java is just a two-dimensional array in which each row of the array can have a different length. Since all the rows in a 2-d Array have the same length but a jagged array allows more flexibility in the size of each row. This feature is very useful in conditions where the data has varying lengths or when memory usage needs to be optimized.   
*int[][] Arr = new int[][] {
    {1, 2, 8}, 
    {7, 5}, 
    {6, 7, 2, 6}
};
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
59.59. Is it possible to make an array volatile?
*What volatile Means in Java
Purpose: It‚Äôs a hint to the Java Memory Model (JMM) telling the JVM that a variable‚Äôs value must always be read from and written to main memory ‚Äî never cached in a thread‚Äôs local CPU cache.

Effect: This ensures visibility of updates between threads, and it also prevents certain instruction reorderings.

Example with a primitive:
volatile boolean flag = false;

// Thread 1
flag = true; // visible immediately to other threads

// Thread 2
if (flag) { // will see the latest value from main memory
    // do something
}

Why You Can‚Äôt Make ‚Äúan Array‚Äù Volatile
*You can write:

java
Copy
Edit
volatile int[] arr;
‚Ä¶but here only the reference arr is volatile ‚Äî not the individual elements.

That means:

If you reassign arr = new int[]{1, 2, 3}; ‚Üí this change is visible to all threads immediately.

But if you do arr[0] = 42; ‚Üí there‚Äôs no guarantee another thread will see that update unless you synchronize or use something like AtomicIntegerArray.



Example:
volatile int[] numbers = new int[5];

// Thread 1
numbers[0] = 99; // element update ‚Äî NOT guaranteed visible to Thread 2

// Thread 2
System.out.println(numbers[0]); // may see old value
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
62. What are the main concepts of OOPs in Java?
The main concepts of OOPs in Java are mentioned below:

Inheritance
Polymorphism
Abstraction
Encapsulation 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Object-Oriented Programming Language

Object-Based Programming Language

Object-oriented programming language covers larger concepts like inheritance, polymorphism, abstraction, etc.	The scope of object-based programming is limited to the usage of objects and encapsulation.
It supports all the built-in objects	It doesn‚Äôt support all the built-in objects
Examples: Java, C#, etc.	Examples: Java script, visual basics, etc
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
64. How is the ‚Äònew‚Äô operator different from the ‚ÄònewInstance()‚Äô operator in Java?
1.new operator

*Type is checked at compile time
*Using new ‚Äî when you know the class at compile time
*public class EmailService {
    private String smtpServer;

    public EmailService(String smtpServer) {
        this.smtpServer = smtpServer;
    }

    public void send(String to, String message) {
        System.out.println("Email sent to " + to + " via " + smtpServer);
    }
}
*public class App {
    public static void main(String[] args) {
        // We KNOW we're using EmailService
        EmailService service = new EmailService("smtp.gmail.com");
        service.send("john@example.com", "Hello!");
    }
}
*Advantages here:

Compiler knows the exact class ‚Üí type-safety.

Easy to read, no reflection complexity.

Best choice for normal app code.


2.2. Using newInstance() ‚Äî when the class is decided at runtime
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
65. What are Classes in Java? 
*In Java, Classes are the collection of objects sharing similar characteristics and attributes.
* Classes represent the blueprint or template from which objects are created. 
*Classes are not real-world entities but help us to create objects which are real-world entities. 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
66.66. What is the difference between static (class) method and instance method?
*Static method is associated with a class rather than an object.

The instance method is associated with an object rather than a class.

Static methods can be called using the class name only without creating an instance of a class.

The instance methods can be called on a specific instance of a class using the object reference.

Static methods do not have access to this keyword.

Instance methods have access to this keyword.

Static methods can access only static members of the class.

Instance methods can access both static and non-static methods of the class.

Static methods cannot be overridden because they are resolved at compile time, not at run time. This means that the compiler decides which method to call based on the reference type, not on the object type.

Instance methods can be overridden because they are resolved at run time, not at compile time. This means that th


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
67. What is this keyword in Java?
*this‚Äô is a keyword used to reference a variable that refers to the current object.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
68. What are Brief Access Specifiers and Types of Access Specifiers?
*Access Specifiers in Java help to restrict the scope of a class, constructor, variable, method, or data member
*There are four types of Access Specifiers in Java mentioned
1. Public

Scope: Accessible everywhere ‚Äî inside the same class,same package anotherclass , other packages another class.

Use: When you want full visibility.

Example:
package pack1;

public class PublicExample {
    public String name = "Neha";

    public void showName() {
        System.out.println("Name: " + name);
    }
}
package pack2;

import pack1.PublicExample;

public class TestPublic {
    public static void main(String[] args) {
        PublicExample obj = new PublicExample();
        System.out.println(obj.name); // Accessible
        obj.showName(); // Accessible
    }
}


2. Private
*Scope: Accessible only within the same class.

*Use: For encapsulation ‚Äî hiding internal details from outside.
class PrivateExample {
    private int age = 25;

    private void displayAge() {
        System.out.println("Age: " + age);
    }

    public void accessPrivate() {
        // Private members are accessible here
        displayAge();
    }
}

public class TestPrivate {
    public static void main(String[] args) {
        PrivateExample obj = new PrivateExample();
        // obj.age; // ‚ùå Error: age has private access
        // obj.displayAge(); // ‚ùå Error
        obj.accessPrivate(); // ‚úÖ Works via public method
    }
}


3.3. Protected

Scope:

Accessible in the same package (like default).

Accessible in subclasses in other packages (via inheritance).

Use: When you want to allow subclass access but restrict unrelated classes.
// File: pack1/ProtectedExample.java
package pack1;

public class ProtectedExample {
    protected void greet() {
        System.out.println("Hello from Protected Method!");
    }
}
// File: pack2/ChildClass.java
package pack2;

import pack1.ProtectedExample;

public class ChildClass extends ProtectedExample {
    public static void main(String[] args) {
        ChildClass obj = new ChildClass();
        obj.greet(); // ‚úÖ Accessible through inheritance
    }
}



4.4. Default (Package-Private)

Scope: Accessible only within the same package.

Use: When you don‚Äôt specify any access modifier ‚Äî it‚Äôs automatically default.

Keyword: No keyword ‚Äî just omit public, private, or protected.

// File: pack1/DefaultExample.java
package pack1;

class DefaultExample {
    void showMessage() {
        System.out.println("Hello from Default Method!");
    }
}

// File: pack1/DefaultExample.java
package pack1;

class DefaultExample {
    void showMessage() {
        System.out.println("Hello from Default Method!");
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
69. What will be the initial value of an object reference which is defined as an instance variable?
*The initial value of an object reference which is defined as an instance variable is a NULL value.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
70. What is an object?s
*The object is a real-life entity that has certain properties and methods associated with it.
*The object is also defined as the instance of a class.
*An object can be declared using a new keyword.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
71. What are the different ways to create objects in Java?
1.Method 1: Using new Keyword (Most Common)
*here they are usd to access the instance varibake abnd metjods which are resolved at the run time
*// Java program to Illustrate Creation of Object
// Using new keyword

// Main class
class GFG {

    // Declaring and initializing string
    // Custom input string
    String name = "GeeksForGeeks";

    // Main driver method
    public static void main(String[] args)
    {
        // As usual and most generic used we will
        // be creating object of class inside main()
        // using new keyword
        GFG obj = new GFG();

        // Print and display the object
        System.out.println(obj.name);
    }
}
*here note main method can acces static variable directly butto acces to non static we need to create the objecst




2.Method 2: Using clone() Method
*// Java program to demonstrate object creation using the
// clone() method
class GFG implements Cloneable {

    // Instance variable
    String name = "GeeksForGeeks";

    // Overriding the clone() method from Object class
    @Override
    protected Object clone()
        throws CloneNotSupportedException
    {
        return super
        // Calls Object class's clone() method
            .clone(); 
    }

    // Main method
    public static void main(String[] args)
    {
        try {
            // Creating the first object
            GFG obj1 = new GFG();

            // Creating a clone (copy) of obj1
            GFG obj2 = (GFG)obj1.clone();

            // Printing the value of name from the cloned
            // object
            System.out.println(obj2.name);
        }
        catch (CloneNotSupportedException e) {
            // Handling exception if cloning is not
            // supported
            e.printStackTrace();
        }
    }
}
Note: 

It performs a shallow copy (deep copy needs custom implementation).
If the class doesn't implement Cloneable, a CloneNotSupportedException will be thrown.


3.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------Serialization and Deserialization in Java

1.What is Serialization and Deserialization?
Serialization is a mechanism of converting the state of an object into a byte stream.
*What is Serialization and Deserialization?
Serialization is a mechanism of converting the state of an object into a byte stream.

Important Points of Serialisation:

Platform-Independent: In Java, the serialization is a platform-independent process. It means that if we serialize an object using a byte stream on one platform can be easily deserialized on different platforms.
Serializable Interface: If we want to make a class serializable, then it must implement the Serializable interface. This interface does not contain any methods or variables ( marker interface), but it gives a signal that the class is ready for serialization.

Deserialization is the reverse process where the byte stream is used to recreate the actual Java object in memory. This mechanism is used to persist the object.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
72. What are the advantages and disadvantages of object cloning?
1.Better than Assignment (=) Operator

= only copies references, not the actual object.

Using clone() creates a new object with the same content, avoiding unintended side effects of shared references.

2.Encapsulation via Protected Method

Object.clone() is protected, so only classes themselves (or their subclasses) can decide how cloning should work.

This gives control to the class author, e.g., only Employee can decide how an Employee object should be cloned.
3.Prototype Design Pattern Support

Often used in the Prototype pattern (create object by cloning instead of constructing).

Faster than creating objects through constructors when the initialization is expensive.

Diadvantages
Disadvantages of Object Cloning in Java

Requires Cloneable Marker Interface

The class must implement Cloneable.

If not, calling clone() throws CloneNotSupportedException.

Default is Shallow Copy

super.clone() just copies field values (bitwise copy).

If the object has references to other objects, both original and clone will point to the same sub-objects ‚Üí leads to bugs.

Example: Cloning a Person with an Address object ‚Äî both persons will share the same address reference.

class Address {
    String city;

    Address(String city) {
        this.city = city;
    }
}

class Person implements Cloneable {
    String name;
    Address address;

    Person(String name, Address address) {
        this.name = name;
        this.address = address;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone(); // shallow copy
    }
}

public class ShallowCloneExample {
    public static void main(String[] args) throws CloneNotSupportedException {
        Address addr = new Address("Delhi");
        Person p1 = new Person("Neha", addr);

        // Shallow clone
        Person p2 = (Person) p1.clone();

        // Modify clone‚Äôs address
        p2.address.city = "Mumbai";

        System.out.println(p1.name + " lives in " + p1.address.city); // Neha lives in Mumbai ‚ùå
        System.out.println(p2.name + " lives in " + p2.address.city); // Neha lives in Mumbai
    }
}


class Address implements Cloneable {
    String city;

    Address(String city) {
        this.city = city;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone(); // separate Address object
    }
}

class Person implements Cloneable {
    String name;
    Address address;

    Person(String name, Address address) {
        this.name = name;
        this.address = address;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        Person cloned = (Person) super.clone();
        cloned.address = (Address) address.clone(); // deep copy
        return cloned;
    }
}

public class DeepCloneExample {
    public static void main(String[] args) throws CloneNotSupportedException {
        Address addr = new Address("Delhi");
        Person p1 = new Person("Neha", addr);

        // Deep clone
        Person p2 = (Person) p1.clone();

        // Modify clone‚Äôs address
        p2.address.city = "Mumbai";

        System.out.println(p1.name + " lives in " + p1.address.city); // Neha lives in Delhi ‚úÖ
        System.out.println(p2.name + " lives in " + p2.address.city); // Neha lives in Mumbai
    }
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
73. What are the advantages of passing this into a method instead of the current class object itself?
*‚úÖ Advantages of passing this instead of the current class object reference

this is implicitly final

You cannot reassign this to another object reference inside the class.

But if you pass the current class object explicitly (like MyClass obj = new MyClass(); someMethod(obj);), that variable (obj) is not necessarily final and could later point to another object.

So this guarantees immutability of the reference.

class Demo {
    void show() {
        System.out.println("Inside Demo");
    }

    void callMethod() {
        helper(this); // this is guaranteed to always refer to current object
    }

    void helper(Demo d) {
        d.show();
    }
}


*Useful in synchronized blocks

You can synchronize on this to ensure thread safety for instance methods.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
74. What is the constructor?
*Constructor is a special method that is used to initialize objects.
*Constructor is called when a object is created.
*// Class Created
class XYZ{
      private int val;
      
      // Constructor
      XYZ(){
            val=0;
      }
};
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
75. What happens if you don't provide a constructor in a class?
*If you don't provide a constructor in a class in Java, the compiler automatically generates a default constructor with no arguments and no operation which is a default constructor.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
76. How many types of constructors are used in Java?
There are two types of constructors in Java as mentioned below:

Default Constructor
Parameterized Constructor
Default Constructor: It is the type that does not accept any parameter value. It is used to set initial values for object attributes.

class_Name();
// Default constructor called
Parameterized Constructor: It is the type of constructor that accepts parameters as arguments. These are used to assign values to instance variables during the initialization of objects.

class_Name(parameter1, parameter2......);
// All the values passed as parameter will be
// allocated accordingly
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is copy constructor?
*‚úÖ Copy Constructor in Java

A copy constructor is a special type of constructor that creates a new object by copying the fields (state) of another object.
It takes another object of the same class as a parameter.
class Student {
    String name;
    int age;

    // Normal constructor
    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Copy constructor
    Student(Student s) {
        this.name = s.name;
        this.age = s.age;
    }

    void display() {
        System.out.println(name + " - " + age);
    }
}

public class CopyConstructorExample {
    public static void main(String[] args) {
        Student s1 = new Student("Neha", 22);
        Student s2 = new Student(s1); // copy constructor called

        s1.display(); // Neha - 22
        s2.display(); // Neha - 22
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
79. Where and how can you use a private constructor?
*

‚úÖ Where and How to Use a Private Constructor in Java

A private constructor is a constructor declared with the private access modifier.
This means objects of that class cannot be created from outside the class, and the class cannot be subclassed.

üîπ Uses of Private Constructor

Restrict Object Creation (Utility Classes)

Used in classes that contain only static methods and fields (e.g., java.lang.Math, java.util.Collections).

Prevents accidental instantiation.

Singleton Design Pattern

Ensures only one instance of a class exists.

Private constructor prevents outside instantiation.



class Utility {
    // Private constructor to prevent instantiation
    private Utility() {
        System.out.println("Private constructor called");
    }

    public static int add(int a, int b) {
        return a + b;
    }
}

public class Test {
    public static void main(String[] args) {
        // Utility u = new Utility(); ‚ùå Not allowed
        System.out.println(Utility.add(10, 20)); // ‚úÖ 30
    }
}


class Singleton {
    // static instance
    private static Singleton instance;

    // private constructor
    private Singleton() {
        System.out.println("Singleton instance created");
    }

    // public static method to return instance
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}

public class TestSingleton {
    public static void main(String[] args) {
        Singleton s1 = Singleton.getInstance();
        Singleton s2 = Singleton.getInstance();

        System.out.println(s1 == s2); // ‚úÖ true (same instance)
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
80. What are the differences between the constructors and methods?
Java constructors are used for initializing objects. During creation, constructors are called to set attributes for objects apart from this few basic differences between them are:

Constructors are only called when the object is created but other methods can be called multiple times during the life of an object.
Constructors do not have a return type, whereas methods have a return type, which can be void or any other type.
Constructors are used to setting up the initial state but methods are used to perform specific actions.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
81. What is an Interface?
*An interface in Java is a collection of static final variables and abstract methods that define the contract or agreement for a set of linked classes.
* Any class that implements an interface is required to implement a specific set of methods.
*It specifies the behavior that a class must exhibit but not the specifics of how it should be implemented.
// Java Program to demonstrate Interface
import java.io.*;
interface Shape {
    double getArea();
    double getPerimeter();
}
class Circle implements Shape {
    private double radius;
    public Circle(double radius) { this.radius = radius; }
    public double getArea()
    {
        return Math.PI * radius * radius;
    }
    public double getPerimeter()
    {
        return 2 * Math.PI * radius;
    }
}
class GFG {
    public static void main(String[] args)
    {
        Circle circle = new Circle(5.0);
        System.out.println("Area of circle is "
                           + circle.getArea());
        System.out.println("Perimeter of circle is"
                           + circle.getPerimeter());
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------
82. Give some features of the Interface.
An Interface in Java programming language is defined as an abstract type used to specify the behavior of a class. An interface in Java is a blueprint of a behavior. A Java interface contains static constants and abstract methods.

Features of the Interface are mentioned below:

The interface can help to achieve total abstraction.
Allows us to use multiple inheritances in Java.
Any class can implement multiple interfaces even when one class can extend only one class.
It is also used to achieve loose coupling.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
83. What is a marker interface?
An Interface is recognized as an empty interface (no field or methods) it is called a marker interface. Examples of marker interfaces are Serializable, Cloneable, and Remote interfaces. 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Abstract Class

Interface Class

Both abstract and non-abstract methods may be found in an abstract class.

The interface contains only abstract methods.

Abstract Class supports Final methods.

The interface class does not support Final methods.

Multiple inheritance is not supported by the Abstract class.

Multiple inheritances is supported by Interface Class.

Abstract Keyword is used to declare Abstract class.

Interface Keyword is used to declare the interface class.

extend keyword is used to extend an Abstract Class.	implements keyword is used to implement the interface.
Abstract Class has members like protected, private, etc.

All class members are public by default
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
85. What do you mean by data encapsulation?
* Basically, it bundles data and methods that operate on that data within a single unit. Encapsulation is achieved by declaring the instance variables of a class as private, which means they can only be accessed within the class.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
87. What is the primary benefit of Encapsulation? 
*The main advantage of Encapsulation in Java is its ability to protect the internal state of an object from external modification or access.
*The main benefit is of providing a way to control and manage the state and the behavior of an object and also protecting it from modification and unauthorized access at the same time. 
// Java Program to demonstrate use of Encapsulation
import java.io.*;
class Person {
    private String Name;
    private int age;
    public String getName() { return Name; }
    public void setName(String Name) { this.Name = Name; }
    public int getAge() { return age; }
    public void setAge(int age) { this.age = age; }
}
// Driver class
class GFG {
    // main function
    public static void main(String[] args)
    {
        Person p = new Person();
        p.setName("Rohan");
        p.setAge(29);
        System.out.println("Name is " + p.getName());
        System.out.println("Age is " + p.getAge());
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
88. What do you mean by aggregation?
*Definition:
Aggregation is a specialized form of association that represents a "Has-A" relationship between two classes.
*Key Characteristics:

Unidirectional ‚Üí One class (the whole) contains a reference to another class (the part).

Ownership without Lifecycle Dependency ‚Üí The whole object can exist without the part object, and the part can also exist independently of the whole.

Representation ‚Üí In UML, aggregation is represented with a hollow diamond at the whole side.


class Engine {
    void start() {
        System.out.println("Engine started...");
    }
}

class Car {
    private Engine engine; // Car has an Engine

    public Car(Engine engine) {
        this.engine = engine;
    }

    void drive() {
        engine.start();
        System.out.println("Car is driving...");
    }
}

public class Main {
    public static void main(String[] args) {
        Engine engine = new Engine();   // Engine exists independently
        Car car = new Car(engine);      // Car "has a" Engine
        car.drive();
    }
}
Note:Aggregation: "Has-a" but independent lifecycle (parts can exist without the whole).
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
89. What is the ‚ÄòIS-A ‚Äò relationship in OOPs Java?
'IS-A' is a type of relationship in OOPs Java where one class inherits another class.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
90. Define Inheritance.
When an object that belongs to a subclass acquires all the properties and behavior of a parent object that is from the superclass, it is known as inheritance.  A class within a class is called the subclass and the latter is referred to as the superclass. Sub class or the child class is said to be specific whereas the superclass or the parent class is generic. Inheritance provides code reusability.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
92. What is multiple inheritance? Is it supported by Java?
A component of the object-oriented notion known as multiple inheritances allows a class to inherit properties from many parent classes. When methods with the same signature are present in both superclasses and subclasses, an issue arises. The method's caller cannot specify to the compiler which class method should be called or even which class method should be given precedence. 

Note: Java doesn‚Äôt support Multiple Inheritance

Example:




// Java Program to show multiple Inheritance
import java.io.*;
interface Animal {
    void eat();
}
interface Mammal {
    void drink();
}
class Dog implements Animal, Mammal {
    public void eat() { System.out.println("Eating"); }
    public void drink() { System.out.println("Drinking"); }
    void bark() { System.out.println("Barking"); }
}
class GFG {
    public static void main(String[] args)
    {
        Dog d = new Dog();
        d.eat();
        d.drink();
        d.bark();
    }
}

Output
Eating
Drinking
Barking
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
94. Is there any limitation to using Inheritance?
Yes, there is a limitation of using Inheritance in Java, as because of inheritance one can inherit everything from super class and interface because of which subclass is too clustered and sometimes error-prone when dynamic overriding or dynamic overloading is done in certain situations.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
95. Although inheritance is a popular OOPs concept, it is less advantageous than composition. Explain.
Inheritance is a popular concept of Object-Oriented Programming (OOP), in which a class can inherit the properties and methods from any other class, which is referred to as a Parent or superclass. On the other hand in Composition, a class can contain an instance of another class as a member variable which is often referred to as part or a component. Below are some reasons why composition is more advantageous than inheritance:

Tight Coupling: Whenever any changes are made to the superclass, these changes can affect the behavior of all its child or Subclasses. This problem makes code less flexible and also creates issues during maintenance. This problem also leads to the Tight coupling between the classes.
Fragile Base Class Problem: When the changes to the base class can break the functionality of its derived classes. This problem can make it difficult to add new features or modify the existing ones. This problem is known as the Fragile Base class problem.
Limited Reuse: Inheritance in Java can lead to limited code reuse and also code duplication. As a subclass inherits all the properties and methods of its superclass, sometimes it may end up with unnecessary code which is not needed. This leads to a less maintainable codebase.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
9. Difference between Composition and Aggregation
Feature	Aggregation	Composition
Type of Relationship	Defines a "Has-A" relationship	Defines a "Part-Of" relationship
Independence	The contained (child) objects can exist independently of the container	The contained (child) objects cannot exist independently of the container
Lifetime	Child objects have their own lifetime and are not destroyed with the parent	Child objects‚Äô lifetime is bound to the parent; when the parent is destroyed, so are the children
UML Representation	Represented by a hollow diamond (‚óä)	Represented by a filled diamond (‚óÜ)
Ownership Strength	Weak relationship (loose ownership)	Strong relationship (strong ownership)
‚úÖ Example of Aggregation
class Professor {
    String name;
    Professor(String name) { this.name = name; }
}

class Department {
    String deptName;
    List<Professor> professors;

    Department(String deptName, List<Professor> professors) {
        this.deptName = deptName;
        this.professors = professors;
    }
}

public class Main {
    public static void main(String[] args) {
        Professor p1 = new Professor("Dr. Smith");
        Professor p2 = new Professor("Dr. John");
        
        // Professors exist independently of Department
        List<Professor> profList = List.of(p1, p2);
        Department dept = new Department("Computer Science", profList);
    }
}


üëâ Here, even if the Department object is deleted, Professor objects still exist independently.
This is Aggregation.

‚úÖ Example of Composition
class Engine {
    void start() { System.out.println("Engine started"); }
}

class Car {
    private Engine engine;

    Car() {
        // Engine is created when Car is created
        this.engine = new Engine();
    }

    void drive() {
        engine.start();
        System.out.println("Car is driving...");
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.drive();
        // When Car is destroyed, Engine is also destroyed
    }
}


üëâ Here, the Engine is part of the Car. If the Car object is destroyed, the Engine will also be destroyed.
This is Composition.

üîë Summary

Aggregation: Whole-part relationship but parts can exist independently. (Weak ownership)

Composition: Whole-part relationship where parts cannot exist without the whole. (Strong ownership)

Would you like me to also make a real-world analogy (like University‚ÄìProfessor vs Car‚ÄìEngine) to remember the difference easily in interviews?
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
101. What is Polymorphism?
Polymorphism is defined as the ability to take more than one form It is of two types namely, Compile time polymorphism or method overloading- a function called during compile time. For instance, take a class ‚Äòarea‚Äô. Based on the number of parameters it may calculate the area of a square, triangle, or circle. Run time polymorphism or method overriding- links during run time.  The method inside a class overrides the method of the parent class.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Dynamic method dispatch is a resolving mechanism for method overriding during the run time. Method overriding is the one where the method in a subclass has the same name, parameters, and return type as a method in the superclass. When the over-ridden method is called through a superclass reference, java determines which version (superclass or subclass) of that method is to be executed based upon the type of an object being referred to at the time the call occurs. Thus the decision is made at run time. This is referred to as dynamic method dispatch.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
105. Can we override the static method?
*No, as static methods are part of the class rather than the object so we can't override them.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
106. Can we override the overloaded method?
*Yes, since the overloaded method is a completely different method in the eyes of the compiler. Overriding isn't the same thing at all. The decision as to which method to call is deferred to runtime.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
107. Can we overload the main() method?

public class MainOverloadExample {

    // JVM entry point
    public static void main(String[] args) {
        System.out.println("This is the original main method");

        // calling overloaded versions manually
        main(10);
        main("Hello");
    }

    // Overloaded main method with int parameter
    public static void main(int x) {
        System.out.println("Overloaded main with int: " + x);
    }

    // Overloaded main method with String parameter
    public static void main(String msg) {
        System.out.println("Overloaded main with String: " + msg);
    }
}
Note:The JVM always looks for only one signature as the entry point:

public static void main(String[] args)


If you overload it, the JVM will not call those overloaded versions automatically.
But you can call them yourself from the main method.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
109. Can we override the private methods?
*No,The private methods are accessible only within the class in which it is declared. Since this method is not visible to other classes and cannot be accessed, it cannot be overridden. 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------110. Can we change the scope of the overridden method in the subclass?
*
----------------------------------------------------------------------------------------------------------------------------------------------------------------------Throwable
‚îÇ
‚îú‚îÄ‚îÄ Error (unchecked, not meant to be caught usually)
‚îÇ     ‚îú‚îÄ‚îÄ OutOfMemoryError
‚îÇ     ‚îú‚îÄ‚îÄ StackOverflowError
‚îÇ     ‚îî‚îÄ‚îÄ VirtualMachineError
‚îÇ
‚îî‚îÄ‚îÄ Exception
      ‚îÇ
      ‚îú‚îÄ‚îÄ Checked Exceptions
      ‚îÇ     ‚îú‚îÄ‚îÄ IOException
      ‚îÇ     ‚îÇ     ‚îú‚îÄ‚îÄ FileNotFoundException
      ‚îÇ     ‚îÇ     ‚îî‚îÄ‚îÄ EOFException
      ‚îÇ     ‚îÇ
      ‚îÇ     ‚îú‚îÄ‚îÄ SQLException
      ‚îÇ     ‚îú‚îÄ‚îÄ ParseException
      ‚îÇ     ‚îú‚îÄ‚îÄ ClassNotFoundException
      ‚îÇ     ‚îî‚îÄ‚îÄ CloneNotSupportedException
      ‚îÇ
      ‚îî‚îÄ‚îÄ Unchecked Exceptions (RuntimeException)
            ‚îú‚îÄ‚îÄ NullPointerException
            ‚îú‚îÄ‚îÄ ArrayIndexOutOfBoundsException
            ‚îú‚îÄ‚îÄ ArithmeticException
            ‚îú‚îÄ‚îÄ IllegalArgumentException
            ‚îÇ      ‚îî‚îÄ‚îÄ NumberFormatException
            ‚îî‚îÄ‚îÄ IllegalStateException



















































----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Sspring
*it is java framework to create the stand alone application and the enterprise application
*sprig application are lightin with as they follw the modular architecture
*it supports various ypes of configrations like the jaa based configrations,xml sed configrations and the annotation based configurations
*it supports the dependency injections which is injecting one object inside the other
*AOP stands for Aspect-Oriented Programming ‚Äî a programming paradigm that helps you separate cross-cutting concerns from your main business logic.

Think of it as a way to write code that injects certain behaviors into multiple places in your program without duplicating the same code everywhere.
suh as logging ,security etc
*it simplifies the jdbc access by the use of spring jdbc and the orm which supports the hibernate and the jpa but main help is it reduces the boilerplate code
*It is very easy to test the spring applications
*they gives the sring security module due to which authentication becomes very easy
*sprg application is extensible measn scalable
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Spring container is the core componner of the spring framework
*its like jvm
*its manages the java beans objects
*It manages the java beasn objects lifecycle
*Di
*aop
*Transactional management
*internationalization


Note:A JavaBean is just a normal Java class that follows a few specific rules so that it can be easily used by tools, frameworks, or libraries.

JavaBean Rules

It must be public (so it can be accessed from anywhere).

It must have a no-argument constructor (so frameworks can easily create instances).

It must have private fields (to follow encapsulation).

It must have public getter and setter methods for those fields.

It should be serializable (optional but common, by implementing Serializable).
*Foe ex:import java.io.Serializable;

public class Employee implements Serializable {
    
    private int id;
    private String name;
    private double salary;

    // No-argument constructor (required)
    public Employee() {}

    // Parameterized constructor (optional)
    public Employee(int id, String name, double salary) {
        this.id = id;
        this.name = name;
        this.salary = salary;
    }

    // Getters and setters (required)
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }

    public double getSalary() {
        return salary;
    }
    public void setSalary(double salary) {
        this.salary = salary;
    }
}
import java.io.Serializable;

public class Employee implements Serializable {
    
    private int id;
    private String name;
    private double salary;

    // No-argument constructor (required)
    public Employee() {}

    // Parameterized constructor (optional)
    public Employee(int id, String name, double salary) {
        this.id = id;
        this.name = name;
        this.salary = salary;
    }

    // Getters and setters (required)
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }

    public double getSalary() {
        return salary;
    }
    public void setSalary(double salary) {
        this.salary = salary;
    }
}


*Types of spring containers
1.Beans factory
2.Application context

Working of spring container

*so first of all outside te container we create the java bean classes and we have configuration which tells container that what objects to create ,from which cleass it belongs and how to set the id
*java container redas both java beans classes and configuratyion file  and create the objects
*we invoke the spring container with help of application context

Note:we declare pacakges name by reverse first compay domain then clcinet then epartment 
*lets take the example as com.comviva.employyee
*make class as employee
*then another package as com.comviva.resources than class as the applicationContext.xml
*and in broser write xml based configuration which is of 2 types dtd style  and xml style
*take xml schema syle and paste it in teh appContext.xml file ,these are the instruction to spring ioc container
*<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="myBean" class="org.example.beans.Student">
        <property name="name" value="neha" />
    </bean>
</beans>
*now inside the xml file add  <bean id="myBean" class="org.example.beans.Student">
this will actually create the object of class Student and uonet name asmyBean
*when ioc container reads the config file it will create objects
*now to invke this springcotainer w will use he ApplicationCotext
*butfor that we need to download the jar file
*we need to download spring beans jar
*spring core
*spring context
*pring expression
*spring logging'
Note:always download from web maven repository file
Note:all file downloaded must be of same version
*and then open IntelliJ project ->open module setting then directory then the add jar here add the jar
*and in external linbrary you can see the jars
*Note:always place the xml file in the resources and in main line
*package org.example;

import org.example.beans.Student;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Main {
    public static void main(String[] args) {

        ApplicationContext app=new ClassPathXmlApplicationContext("ApplicationContext.xml");
        Student s1=(Student)app.getBean("myBean");


        System.out.println(s1.getName());
    }
}
Note:  ApplicationContext app=new ClassPathXmlApplicationContext("ApplicationContext.xml"); invoke ioc container read configuration file and create objects 
*------------------------------------------------------------------------------------------------------------------------------------------------------------------
java based configueation

*here in src->main->or.example->config  we create the java file 

*package org.example.config;

import org.example.beans.Student;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class javaConfig {

    @Bean
    public Student mybean()
    {
        Student s1=new Student();
        s1.setName("neha");
        return s1;

    }
}

*here we provide the annotation as configuration
*and then the it has method annotatd with beans 
*the method name is same as ebna nam e
*and return type same  as class anme
*here inside this we create onject
*set
*and return 
*then we invoke the ioc container inside the main 
*package org.example;

import org.example.beans.Student;

import org.example.config.javaConfig;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Main {
    public static void main(String[] args) {

        ApplicationContext app=new AnnotationConfigApplicationContext(javaConfig.class);
        Student s1=(Student)app.getBean("mybean");


        System.out.println(s1.getName());
    }
}
Note:here we uses the AnnotationConfigApplicationContext
*and in arg we provide the classs not string



-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
spring based configuration
*in spring based configuration also we need to create the xml file or the javas based configuration let see with xl file
*<?xml version = "1.0" encoding = "UTF-8"?>

<beans xmlns = "http://www.springframework.org/schema/beans"
       xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context = "http://www.springframework.org/schema/context"
       xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
   http://www.springframework.org/schema/context
   http://www.springframework.org/schema/context/spring-context-3.0.xsd">

    <context:annotation-config/>
    <!-- bean definitions go here -->

</beans>
*Note:here the thing is we dont create the beans here
*as soon it says that component scan ij the package it will find class with annotation as the componnet
*but in pojo we addd the @componnet saying that its the object of that class will be beans object and name will start with the classname smalcase first letter
*and in main package org.example;

import org.example.beans.Student;


import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Main {
    public static void main(String[] args) {

        ApplicationContext app=new ClassPathXmlApplicationContext("ApplicationContext.xml");
        Student s1=(Student)app.getBean("student");


        System.out.println(s1.getName());
    }
}

*Note:now to provide the default values 
package org.example.beans;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class Student {
    @Value("neha")
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    private String description;
}
Note:her using annattion we created the objects
Note:here if we use the java basd configuration
here after the @configuration wrte the @componentscan("orf.examples.beans") and we dont craeet here beans
*
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*Javan bean object lifecycle
*so first the java bean deifinition load from the xml,java basd,springannotation based configuration
*the beans onject is creatd name is given with default value
*then after the java bean object is created it is initialized by using property tag in th xml basd and value tag in the value annotation in spring annotation
*then use the beasn object
*finally bean object is destroyed
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is dependency injection
*dependency injection is basically the design pattern
*Its main task i to inject one object into another object
*suppose we have the class Student{
Address address

}
*Student object depends on the address object and injecting the address object in student is called the dependency injection
*Hrad coding
When you directly put values or object creation logic inside your code, that‚Äôs hard coding.

Example:

public class Student {
    private String name = "Neha"; // ‚ùå hardcoded
}


If you want to change "Neha" ‚Üí "Raghav", you must modify the code and recompile.


2.2. Tight Coupling

When one class is directly dependent on another class, changing one affects the other.

Example:

class MathCheat {
    void cheat() {
        System.out.println("Math cheat started...");
    }
}

class Student {
    MathCheat mathCheat = new MathCheat();  // ‚ùå tightly coupled

    void startCheating() {
        mathCheat.cheat();
    }
}


Here, Student creates MathCheat ‚Üí tightly coupled.
If we replace MathCheat with ScienceCheat, we must modify Student.


3.When classes are not directly dependent, they communicate via abstraction (interfaces, setters, constructors).

Example:

class Student {
    private Cheat cheat;   // ‚úÖ interface/abstraction

    // Dependency is injected (not created inside)
    public void setCheat(Cheat cheat) {
        this.cheat = cheat;
    }

    void startCheating() {
        cheat.cheat();
    }
}

interface Cheat {
    void cheat();
}

class MathCheat implements Cheat {
    public void cheat() {
        System.out.println("Math cheat started...");
    }
}


Now, Student doesn‚Äôt care which cheat ‚Üí MathCheat or ScienceCheat.
*It is used to achie the loose coupling meas through setter method asin the object inrad of new object()
*We can achive the depnedencyijection by
1.through setter method
2.through constructor method
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Dependency injection thrugh the setter method using xml based
*lets implement by the xml based configuration
*here w have student that take refernec of address class so in he xml
*<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="adressId" class="org.example.beans.Address">
        <property name="houseno" value="62" />
        <property name="pincode" value="202001" />
        <property name="street" value="aligarh" />

    </bean>
    <bean id="myBean" class="org.example.beans.Student">
        <property name="name" value="neha" />
        <property name="description" value="details" />
        <property name="address" ref="adressId" />

    </bean>
</beans>
*Note:here ref instead of value and than name of object
package org.example;

import org.example.beans.Student;


import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Main {
    public static void main(String[] args) {

        ApplicationContext app=new ClassPathXmlApplicationContext("ApplicationContext.xml");
        Student s1=(Student)app.getBean("myBean");


        System.out.println(s1.getAddress());
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Constructor inection using xml based
*s here mak the change in xml cofiguraio as the 
*here in both classs make constructor and in the configuration file
*<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="adressId" class="org.example.beans.Address">
       <constructor-arg value="62" />
        <constructor-arg value="202001" />
        <constructor-arg value="aligarh" />

    </bean>
    <bean id="myBean" class="org.example.beans.Student">
        <constructor-arg value="neha" />
        <constructor-arg value="details" />
        <constructor-arg ref="adressId" />

    </bean>
</beans>
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Now the setter injection using the config file
*create the file package org.example;

import org.example.beans.Address;
import org.example.beans.Student;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class javaconfig {
    @Bean
    public Address addressobj()
    {
        Address ad=new Address();
        ad.setHousno("62");
        ad.setStreet("aligarh");
        ad.setPincode("202001");
        return ad;


    }
    @Bean
    public Student createstudentobj()
    {
        Student s=new Student();
        s.setName("neha");
        s.setAddress(addressobj());
        s.setDescription("details");
        return s;
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
constructor injection using java config

package org.example;

import org.example.beans.Address;
import org.example.beans.Student;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class javaconfig {
    @Bean
    public Address addressobj()
    {
        Address ad=new Address("62","202001","aligarh");

        return ad;


    }
    @Bean
    public Student createstudentobj()
    {
        Student s=new Student("neha",addressobj(),"details");

        return s;
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Autowiring
*All the dependency injection we did above was manullay but autowiring is feature of spring through which we inject the dependency automatically
*w do it by the 
1.xml based autowriig->"autowire attribute"
2.annottaion based autowring->Autowire annotation

1.@Autowire annotation in java based configurating
lets take the java based annotation and hre inside the student bean ojet we will not set the dares manullay instead 
package org.example.beans;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class Student {
    public Student(String name,  String description) {
        this.name = name;
        
        this.description = description;
    }

    @Value("neha")
    private String name;

    public String getAddress() {
        return address.getStreet();
    }


    public void setAddress(Address address) {
        this.address = address;
        System.out.println("setter method called");
    }
@Autowired
    private Address address;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    private String description;
}
Note:we make th address as utowired means from whwre yu find address just plug in
*so follow this case for the setter dont seta dn in constructor also dont pass to initialize
*Note:due to this no of line of code decrease
*Note:suppose we have more than one object of the address
*then which one will getinject for that along with @Autowired
@Qualifier("createaddressobj1")
    private Address address;
8Note:autowiring can be done on non primitive data type and not on the primitive data types
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
autowire attribute in the xml based configuration
* <bean id="address" class="org.example.beans.Address">
        <property name="housno" value="62" />
        <property name="pincode" value="202001" />
        <property name="street" value="aligarh" />

    </bean>
    <bean id="myBean" class="org.example.beans.Student" autowire="byName">
        <property name="name" value="neha" />
        <property name="description" value="details" />

Note: byName here te id of the address beans object must be same as the field name in Sstudent class
*Note:her uatowire attribute make use of the setter methods so please have the setter methods 
* 
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="addId" class="org.example.beans.Address">
        <property name="housno" value="62" />
        <property name="pincode" value="202001" />
        <property name="street" value="aligarh" />

    </bean>
    <bean id="addId2" class="org.example.beans.Address" autowire-candidate="false">
        <property name="housno" value="62" />
        <property name="pincode" value="202001" />
        <property name="street" value="aligarh" />

    </bean>
    <bean id="myBean" class="org.example.beans.Student" autowire="byType">
        <property name="name" value="neha" />
        <property name="description" value="details" />


    </bean>
</beans>
in autowire by tyoe the autowiring taje place by coparing type and if we hav more object than make the unused object
----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
Introduction to maven(
*in building the java project there are many phases

*maven is build too automates these phases
1.building thestructure
2.instead of providing the jar file as dependency we download and provide now we provide the dependency in pom.xmk and it will directly download
3.Prepares the documentation
4.Compile the source code
5.Start or stop the server
6.pacakge project in jar or war file

so we have project that goes through diffrenet phases to get output
*maven automates the process by reading pom file which contains configuaryion like build config,depndency
*
*so the maven reads this pom file and go tothe global onlin repo download and add to local repo our own compute .m2 folder and then add to project
* 




Sspring programme suing the maven

*so create project then generat structure maven then group id must be com.comviva
*then must be quickstart
*create 
*Note:jdk is 17 thatis fom the file program both i project structure and in modules
*no in dependency add he spring contextdependenc
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Spring jdbc tutorial
*spring jdbc module is  amodule n sprigconnect the spring application with the database
*Sspring jdbc module use jdbc api
*spring jdbc module provide the 3 classes
1.DriverManagerDataSsource
2.jdbc template
3.NamedParameterjdbc template

1.DriverManagerDataSsource is th e implemented class of the DataSsoure interface
DataSource interface lies in the javax.sql package
It is used for
*Database connection
*Database configuration
*Driver loader

2.jdbc template
*Its is used for the crud operations
*Methods of the jdbc template are 
*update()->insert ,update,delete
*query(),queryforList(),queryforMap()
*

package com.comviva;


import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DriverManagerDataSource;


@Configuration
public class SpringFile {
    @Bean
    public DriverManagerDataSource mydatasource()
    {
        DriverManagerDataSource ds=new DriverManagerDataSource();
        ds.setDriverClassName("com.mysql.cj.jdbc.Driver");
        ds.setUrl("jdbc:mysql://localhost:3306/connectiontospringjdbc");
        ds.setUsername("root");
        ds.setPassword("rootadmin");
        return ds;
    }
    @Bean
    public JdbcTemplate myJdbcTemplate()
    {
        JdbcTemplate n=new JdbcTemplate();
        n.setDataSource(mydatasource());
        return n;
    }
}
 and in main file we have the 
package com.comviva;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.jdbc.core.JdbcTemplate;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
        System.out.println( "Hello World!" );
        ApplicationContext con=new AnnotationConfigApplicationContext(SpringFile.class);
        JdbcTemplate jd=con.getBean(JdbcTemplate.class);
        String insert="INSERT into student values(?,?,?)";
        int count=jd.update(insert,101,"neha");
    }
}

*nw for the select part
*String selectquery="SELECT * FROM student";
        List<Student> liststudent=jd.query(selectquery,new StudentRowMapper());
where studentrowmapper is he mapper class 
package com.comviva;

import org.springframework.jdbc.core.RowMapper;

import java.sql.ResultSet;
import java.sql.SQLException;

public class StudentRowMapper implements RowMapper<Student> {


    @Override
    public Student mapRow(ResultSet rs, int rowNum) throws SQLException {
        Student s=new Student();
        s.setName(rs.getString("std_roll"));
        s.setRollno(rs.getInt("std_marks"));

        return s;
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------
NamedParameterJdbc template is the class or executing the sql queries withnamed paramaters instad of the ?
*it improves the code readability
* @Bean
    public NamedParameterJdbcTemplate myJdbcTemplate()
    {
        return new NamedParameterJdbcTemplate(mydatasource() );
    }
*System.out.println( "Hello World!" );
        ApplicationContext con=new AnnotationConfigApplicationContext(SpringFile.class);
        NamedParameterJdbcTemplate jd=con.getBean(NamedParameterJdbcTemplate.class);
        Map<String,Object>mpp=new HashMap<String,Object>();
        mpp.put("key_rollno",1);
        mpp.put("key_name","neha");

        String insert="INSERT into student values(:key_rollno,:key_name)";
        int count=jd.update(insert,mpp);
*
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
What are design pattern
*Deisgn apttern re the reusable solution for the design problems
*mvc design patern
*so n the eclpse make the dynamc project there
*and there make inside the web app
*index.html and there  re
*then login.hml
*register.html
*and then make the src-soyrces->in.sp.controller
regisre.java
*login.java
*then in the register.java
*here in registration form @websrvlets annotation and then the clas sregusrer implement httservlets an here overside the method
*doPost 
*then req.getparameter
*then try
*catch
*here make connection add jar in lib file
*and then con.getpreparedsatatment()
*insertquery
*after insert successful callthe dispatcher to loin file
*

<!DOCTYPE html>
<html>
<head>
    <title>Home</title>
</head>
<body>
    <h2>Welcome</h2>
    <a href="register.html">Register</a> | 
    <a href="login.html">Login</a>
</body>
</html>


<!DOCTYPE html>
<html>
<head>
    <title>Register</title>
</head>
<body>
    <h2>Registration</h2>
    <form action="register" method="post">
        Name: <input type="text" name="name"><br>
        Email: <input type="text" name="email"><br>
        Password: <input type="password" name="password"><br>
        <input type="submit" value="Register">
    </form>
</body>
</html>

package in.sp.controller;

import java.io.*;
import java.sql.*;
import javax.servlet.*;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.*;

@WebServlet("/register")
public class RegisterServlet extends HttpServlet {
    protected void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
        String name = req.getParameter("name");
        String email = req.getParameter("email");
        String password = req.getParameter("password");

        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
            Connection con = DriverManager.getConnection(
                "jdbc:mysql://localhost:3306/mymvcdb", "root", "yourpassword");

            PreparedStatement ps = con.prepareStatement(
                "INSERT INTO users(name,email,password) VALUES (?,?,?)");
            ps.setString(1, name);
            ps.setString(2, email);
            ps.setString(3, password);

            int i = ps.executeUpdate();

            if (i > 0) {
                RequestDispatcher rd = req.getRequestDispatcher("login.html");
                rd.forward(req, res);
            } else {
                res.getWriter().println("Registration Failed");
            }

            con.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

package in.sp.controller;

import java.io.*;
import java.sql.*;
import javax.servlet.*;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.*;

@WebServlet("/register")
public class RegisterServlet extends HttpServlet {
    protected void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
        String name = req.getParameter("name");
        String email = req.getParameter("email");
        String password = req.getParameter("password");

        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
            Connection con = DriverManager.getConnection(
                "jdbc:mysql://localhost:3306/mymvcdb", "root", "yourpassword");

            PreparedStatement ps = con.prepareStatement(
                "INSERT INTO users(name,email,password) VALUES (?,?,?)");
            ps.setString(1, name);
            ps.setString(2, email);
            ps.setString(3, password);

            int i = ps.executeUpdate();

            if (i > 0) {
                RequestDispatcher rd = req.getRequestDispatcher("login.html");
                rd.forward(req, res);
            } else {
                res.getWriter().println("Registration Failed");
            }

            con.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

package in.sp.controller;

import in.sp.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.*;
import java.io.IOException;
import java.sql.*;

@WebServlet("/login")
public class LoginServlet extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String email = req.getParameter("email");
        String password = req.getParameter("password");

        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
            Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydb", "root", "root");

            String sql = "SELECT * FROM users WHERE email=? AND password=?";
            PreparedStatement ps = con.prepareStatement(sql);
            ps.setString(1, email);
            ps.setString(2, password);

            ResultSet rs = ps.executeQuery();

            if (rs.next()) {
                // Map DB row to User object
                User user = new User();
                user.setId(rs.getInt("id"));
                user.setName(rs.getString("name"));
                user.setEmail(rs.getString("email"));
                user.setPassword(rs.getString("password"));

                // Store User in session
                HttpSession session = req.getSession();
                session.setAttribute("user", user);

                // redirect to profile.jsp
                resp.sendRedirect("profile.jsp");
            } else {
                req.setAttribute("error", "Invalid email or password");
                req.getRequestDispatcher("login.html").forward(req, resp);
            }

            con.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

<%@ page import="in.sp.model.User" %>
<%
    HttpSession session = request.getSession(false);
    User user = (User) session.getAttribute("user");

    if (user == null) {
        response.sendRedirect("login.html");
        return;
    }
%>

<html>
<body>
    <h2>Welcome, <%= user.getName() %>!</h2>
    <p>Email: <%= user.getEmail() %></p>

    <form action="logout" method="get">
        <button type="submit">Logout</button>
    </form>
</body>
</html>
package in.sp.controller;

import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.*;
import java.io.IOException;

@WebServlet("/logout")
public class LogoutServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        HttpSession session = req.getSession(false);
        if (session != null) {
            session.invalidate();
        }
        resp.sendRedirect("login.html");
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Spring web module
*web module i sthe part of the springframework
*which help in creating the applications
*It helps in the handling http requests and response,integrating with other technologies and then managing sessions
*spring web mvc is the part of the spring web moule just added the mvc design patterns in it


*Architecture of spring web mvc
*
-------Got it üëç You‚Äôve shared a diagram that represents the Spring Web MVC Architecture. Let me explain it clearly step by step:

Spring Web MVC Architecture

Spring Web MVC is based on the Front Controller design pattern, implemented by the DispatcherServlet.
Here‚Äôs how the flow works:

Client Request

The client (browser) sends a request to the application.

Front Controller (DispatcherServlet)

All incoming requests are first handled by the DispatcherServlet.

It acts as a front controller, centralizing the request handling.

Handler Mapping

The DispatcherServlet consults the Handler Mapping to decide which Controller method should handle the request.

Mapping is based on URL patterns, annotations (@RequestMapping, @GetMapping, etc.).

Controller

The mapped Controller executes business logic with the help of the Model (Command/Service classes).

It returns a ModelAndView object, which contains:

Model ‚Üí data

View name ‚Üí logical view

View Resolver

The DispatcherServlet passes the view name to the View Resolver.

The View Resolver translates the logical view name into a real View (e.g., JSP, Thymeleaf, FreeMarker, etc.) file.

View

The view is rendered with the provided model data.

Example: JSP page uses the model attributes.

Response

Finally, the generated view (HTML page) is returned as a response to the client.

Flow Summary
Client ‚Üí DispatcherServlet ‚Üí Handler Mapping ‚Üí Controller ‚Üí ModelAndView 
       ‚Üí View Resolver ‚Üí View ‚Üí DispatcherServlet ‚Üí Response ‚Üí Client


‚ö° This is exactly what your diagram shows:

DispatcherServlet in the center (Front Controller).

HandlerMapping to find the right controller.

Controllers interacting with Model (Command classes).

Returning ModelAndView.

ViewResolver resolving actual JSP/HTML.

View generating the response for the Client.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------Why do we need Tomcat?

When you write a Java web app (with JSPs, Servlets, Spring MVC, etc.), your code won‚Äôt run directly like a normal Java program ‚Äî it needs something that can understand HTTP requests, Servlets, and JSPs.

That‚Äôs where Tomcat comes in:

It listens on a port (default: 8080)

Accepts requests from browsers (like http://localhost:8080/myApp)

Runs your servlet/JSP code

Sends back the response (usually HTML/JSON/XML) to the browser

üîπ Example

Say you write a servlet:

@WebServlet("/hello")
public class HelloServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response) 
        throws IOException {
        response.getWriter().println("Hello from Servlet!");
    }
}


If you deploy this to Tomcat and run http://localhost:8080/hello,
üëâ Tomcat takes care of starting your servlet, handling the HTTP request, and sending "Hello from Servlet!" to the browser.

üîπ Tomcat vs. Other Servers

Tomcat ‚Üí Lightweight, only supports Servlets/JSPs (not full Java EE features).

JBoss/WildFly, GlassFish ‚Üí Full Java EE servers (support EJB, JPA, JMS, etc.).

Spring Boot ‚Üí Often uses embedded Tomcat internally (so you don‚Äôt install Tomcat separately).

‚úÖ In short:
Tomcat is like a web engine for Java ‚Äî it makes your Java servlets and JSPs accessible from a web browser.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
How to configure tomcat with eclipse
*first install tomcat
*xtract
*go to eclipse
*window 
*preference
*server
*run time env
*then add the tyomcat version nd dir
*in enclipse add the maven project
*there the type must be web app
*Note:if facing any erro in index.jsp click o project thn project facets than run time
*Why do we need Tomcat?
*in eclipse ->maven->webapp 
*spring mvc
*configure dispatcheservlet in the web.xml file
*
*
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is ringboot
*Springboot is the open source java framework  built on the top  of the springframework
*boot refers to the rapidly initiating the spring applications by handling the stup nd canfiguartions
*It makes making the spring application afster nd easier
*1.opiniated default means means spring provides  wht is need to be used maven and dependency is sprig web app,and also provides the configuration file->app.properties
*2.Convention ver configuration menas iead of configuring everything we can use restcontroller or rest pis,@service for service layr,@repository
*3.automatic configurtion
*4.embedded servers


So through he springboot  can make the 
1.spring we app ->uses the mvc measn the tomcat
2.microservices
3.Rest ful web services
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Springboot starters re the dependency descriptors
*dependency means the external library or jar file
*descriptors meabs the description about heir vesrions



suppose we wan to make any web application
*jars needded spring web mvc 
*tomcat
*logging
*validation
so just stotrethese whole dependency needed in the springboot starter
*<dependencies>
<dependency>
<group id>
<artifact id >spring-boot-starter-web

*so basically springboot tarter automatically add all the configuarteion eed for the application instead of manullay dding the configuration
*it boosts productivity
*It ensures compatibility by taking care of the version

so basically the 
1.spring boot starter  maintains configuration,boost productivity and loging,yml processing
2.spring starter web produce the web application,spring mvc,tomcat,logging,yml processing
3.sringboot starter data jpa->spring data jpa,hibernate,connection pool
4.spring boot starter security
5.spring boot starter thymleaf as springboot doesnot supports the jsp so thymleaf
6spring boot starter test->provide the junit,mockito
7spring boot starter actuator to monitor thr health

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

springboot latest version is 4.22.1
*so from spring iniiazater ownload project with spring web 
*and open in the IntelliJ
*in main we have the @SpringBootApplication which is used to setup the spring application
*It is combination of 3 annottaiosn which are 
1.@configuration:it tells that ti class cab be used as the configuration to create the bean object
2.@componnetscan so that it can scan all package and classes to see any clas which can be  beans object
3.enable auto configuration to provide the configuration

*@SpringBootApplication:It is the entr point for the application
*SpringApplication.run
run method tasks are
*spring application initialize
*application contect etup
*load external configurate
*load and apply register beans
*start server

Note the spring web
src->main java
src main resource->static where we store static files,tempalte where we store the dynamic pages using the thymleaf,app.properties to store configuration like the port 
*Note all the packages must be inside the src/mian/java packages 
ackage controllers;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class FirstController {

    @GetMapping("/")
    @ResponseBody
    public String printHello()
    {
        return "hello";
    }
}

in app.properties spring.port=8181 now urn application on part 8181
*Now the thing is that the wb app respons ei=on thw web page
*and spring starter on the console

--------------------------------------------------------------------------------------------------------------------------------------------------------------------s
Understanding auto configuration
so in spring web application
*src->main->webap->webinf->web.xml mei dispatch servlet,web-servlet.xl->component scan,internal resource view resolver
*but in springboot web application we hav the app.properties where configurations are added automatically in app.properties
*so sringboot first reads the pom ile and find sprigboot starter web then all the configurationunder the dependency will be added
*How Auto-Configuration Works (Step by Step)
Step 1: @SpringBootApplication

When you create a Spring Boot app, you add:

@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}


@SpringBootApplication includes:

@Configuration ‚Üí tells Spring this is a config class

@EnableAutoConfiguration ‚Üí enables auto config

@ComponentScan ‚Üí scans your package for components

Step 2: @EnableAutoConfiguration

This annotation looks into spring-boot-autoconfigure JAR, which contains a file:

META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports


This file lists all possible AutoConfiguration classes, e.g.:

DataSourceAutoConfiguration

DispatcherServletAutoConfiguration

WebMvcAutoConfiguration
---------------------------------------------------------------------------------------------------------------------------------------------------------------------

So springbootapplication annotation consists of the annotation Configuration,ComponnetScan
then the beasn annotation to tell tat this beans objects needs to be created
*after springoot strat tanthe run metods must be override
*tere call the beans method
*package com.comviva.springbbotfirstprogram;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;

@SpringBootApplication
public class SpringbbotfirstprogramApplication implements CommandLineRunner {

	public static void main(String[] args) {
		System.out.println("started");

		SpringApplication.run(SpringbbotfirstprogramApplication.class, args);
	}

	@Override
	public void run(String... args) throws Exception {
		myclass().message();

	}
	@Bean
	public MyClass myclass()
	{
		MyClass m=new MyClass();
		return m;
	}
}
Note:if i wan the run and mbeans in another class than the 
*make anotherpacakage in,sp.cinfig
*make config clasa and add annottaions as configuration 
*package com.comviva.springbbotfirstprogram;

import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig {
    public CommandLineRunner commd()
    {
        return new CommandLineRunner() {
            @Override
            public void run(String... args) throws Exception {
                myclass().message();

            }
        };
    }
    @Bean
    public MyClass myclass()
    {
        MyClass m=new MyClass();
        return m;
    }

}


------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Sprinboot jdbc tutorial
*How t connect the springboot application to database via jbc
*Main steps for springbok jdbc application are :
*add the springboot starter MySQL and springboot starter jdbc
*Provide database properties in app.properties like spring.datasource.url,spring.datasource.driver-classname,ring.datasource.password
*Note:here by initializing its property springboot auto onfigure the datasource
*use the jdbctemplate class for crud operations
*

Points to be noted:

*Springboot jdbc is built upon the spring jdbc module
*Springboot autoconfigure the datasource beans ,jdbctemplate beans and the namedparamterjdbctemplate beans
*So fist of all we need to create the dao ayer which interact with the entity and storeentity in the database using jdbc
so ak
*package com.comviva.repository;

import cpm.comviva.entity.User;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

@Repository
public class Userrepo {
    public JdbcTemplate jdbc;
    public boolean insert(User u)
    {
        boolean status=false;
        String sql="INSERT INTO USER (name,roolno) values(?,?)";
        int count=jdbc.update(sql,1,"neha");
        if(count>0)
        {
            status=true;
        }
        return status;
    }
}
*So here the thinh is that jdbc template is autoconfigre and adding the repository always creat the beans onject
*1. pom.xml dependencies
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-jdbc</artifactId>
    </dependency>

    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <scope>runtime</scope>
    </dependency>
</dependencies>

2. application.properties
spring.datasource.url=jdbc:mysql://localhost:3306/jdbc_demo
spring.datasource.username=root
spring.datasource.password=yourpassword
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

3. Entity ‚Äì User.java
package com.example.jdbc.entity;

public class User {
    private int id;
    private String name;
    private String email;

    // Constructors
    public User() {}
    public User(int id, String name, String email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }

    // Getters & setters
    public int getId() { return id; }
    public void setId(int id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    @Override
    public String toString() {
        return "User [id=" + id + ", name=" + name + ", email=" + email + "]";
    }
}

4. Repository Interface ‚Äì UserRepository.java
package com.example.jdbc.repository;

import com.example.jdbc.entity.User;
import java.util.List;

public interface UserRepository {
    int insertUser(User user);
    User getUserById(int id);
    List<User> getAllUsers();
    int updateUser(User user);
    int deleteUser(int id);
}

5. Repository Implementation ‚Äì UserRepositoryImpl.java
package com.example.jdbc.repository;

import com.example.jdbc.entity.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class UserRepositoryImpl implements UserRepository {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    private RowMapper<User> rowMapper = (rs, rowNum) ->
            new User(rs.getInt("id"), rs.getString("name"), rs.getString("email"));

    @Override
    public int insertUser(User user) {
        String sql = "INSERT INTO users (id, name, email) VALUES (?, ?, ?)";
        return jdbcTemplate.update(sql, user.getId(), user.getName(), user.getEmail());
    }

    @Override
    public User getUserById(int id) {
        String sql = "SELECT * FROM users WHERE id=?";
        return jdbcTemplate.queryForObject(sql, rowMapper, id);
    }

    @Override
    public List<User> getAllUsers() {
        String sql = "SELECT * FROM users";
        return jdbcTemplate.query(sql, rowMapper);
    }

    @Override
    public int updateUser(User user) {
        String sql = "UPDATE users SET name=?, email=? WHERE id=?";
        return jdbcTemplate.update(sql, user.getName(), user.getEmail(), user.getId());
    }

    @Override
    public int deleteUser(int id) {
        String sql = "DELETE FROM users WHERE id=?";
        return jdbcTemplate.update(sql, id);
    }
}

6. Main Class ‚Äì SpringbootJdbcCrudApplication.java
package com.example.jdbc;

import com.example.jdbc.entity.User;
import com.example.jdbc.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringbootJdbcCrudApplication implements CommandLineRunner {

    @Autowired
    private UserRepository userRepository;

    public static void main(String[] args) {
        SpringApplication.run(SpringbootJdbcCrudApplication.class, args);
    }

    @Override
    public void run(String... args) {
        // Insert
        User user1 = new User(1, "Neha", "neha@example.com");
        userRepository.insertUser(user1);

        // Fetch single
        System.out.println("User with ID 1: " + userRepository.getUserById(1));

        // Update
        user1.setName("Neha Raghav");
        user1.setEmail("raghav.neha@example.com");
        userRepository.updateUser(user1);
        System.out.println("Updated: " + userRepository.getUserById(1));

        // Fetch all
        System.out.println("All users: " + userRepository.getAllUsers());

        // Delete
        userRepository.deleteUser(1);
        System.out.println("After delete: " + userRepository.getAllUsers());
    }
}
Note:here so that @coniguration,@repository creates the bean object automatically
*wherea in the run method create the pojo object is manullay we are creatig the object thay are nit beans 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------What is hibernate framework
*Hibernate is aframeworkor rm tool
*so problem with the jdbc wa tat we write the query and the java code
*but hibernate says do the ava code not the sql things use the java methods
*so we have th pojo object tharrepresent table an dproerties in it are columns
*and this mapping between java objects and database is called the orm
*---------------------------------------------------------------------------------------------------------------------------------------------------------------------Hibernate crud operations
So basically hibernate software is inerace between java ap and database
*and then the behind the scene it uss e jdbc
*Hibernate provides some essential components known as the core objecst for managing database 
*and it has the configuration file hibernate.cfg.xml
*So basically what appens is the This file is used t make the database connection such as set urlname d all
*and we have the aping file which maps the java objects with the database
*

Hibernate Workflow Example

Load configuration (hibernate.cfg.xml).

Build SessionFactory.

Open a Session (like opening a connection).

Begin a Transaction.

Perform CRUD operations (save, update, delete, query).

Commit/Rollback transaction.

Close session.



Steps
*hav thedepnednecy f hibernate and mysql
*Create the entity with @Entity configuration and the entity must be from javax.persistence as t ensure the portability across various orm frameworks
*and on the tabl also add the @table identity so it will create the table as ser and the @column enetity
*now make the hibernate.config.xml there write code from maven dependency>or hibernate ->hibernate configuration
*and ther dd <hibernate-configuration>
<propert name="connection.driver_class>commysql
all operteis for database configuration
*Notei want that i dont create the table manully instead hibernate create it itself
*<propert name="hbm2ddl.auto">update<propert>
<propert ame="show_sql"
*the fially or mappig <mapping class="in.sp.entites">
*


in main
*Configuartion c=new Configuration()
*c.configure(hibernate.cfg.xml)/hole url
*then is the SesiionFactory t is heavywight thread fe and manages session and must be sed each one or ne databsecfg.etSesiionFactory()
*Sesiion for performig he rud operation=SessionFactory.etSession(
*Transactions for the 
session.szve(user)

for insert->save persist
foret->session.get(user.lass,1)->return User


Steps to Create Hibernate CRUD Project
1. Dependencies (Maven pom.xml)
<dependencies>
    <!-- Hibernate Core -->
    <dependency>
        <groupId>org.hibernate</groupId>
        <artifactId>hibernate-core</artifactId>
        <version>5.6.15.Final</version>
    </dependency>

    <!-- MySQL Connector -->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <version>8.0.33</version>
    </dependency>

    <!-- JPA API (javax.persistence for portability) -->
    <dependency>
        <groupId>javax.persistence</groupId>
        <artifactId>javax.persistence-api</artifactId>
        <version>2.2</version>
    </dependency>
</dependencies>

2. Entity Class
package in.sp.entities;

import javax.persistence.*;

@Entity
@Table(name = "users")   // Table name auto-created as "users"
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // Auto-increment
    private int id;

    @Column(name = "name", nullable = false, length = 100)
    private String name;

    @Column(name = "email", unique = true)
    private String email;

    public User() {}
    public User(String name, String email) {
        this.name = name;
        this.email = email;
    }

    // getters and setters
    public int getId() { return id; }
    public void setId(int id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    @Override
    public String toString() {
        return "User [id=" + id + ", name=" + name + ", email=" + email + "]";
    }
}

3. Hibernate Configuration File (hibernate.cfg.xml)

Place this file in src/main/resources/.

<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd">

<hibernate-configuration>
    <session-factory>

        <!-- Database Connection Settings -->
        <property name="hibernate.connection.driver_class">com.mysql.cj.jdbc.Driver</property>
        <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/hibernate_demo</property>
        <property name="hibernate.connection.username">root</property>
        <property name="hibernate.connection.password">yourpassword</property>

        <!-- Hibernate Dialect -->
        <property name="hibernate.dialect">org.hibernate.dialect.MySQL8Dialect</property>

        <!-- Schema Auto Creation -->
        <property name="hibernate.hbm2ddl.auto">update</property>

        <!-- Show SQL -->
        <property name="hibernate.show_sql">true</property>
        <property name="hibernate.format_sql">true</property>

        <!-- Entity Mapping -->
        <mapping class="in.sp.entities.User"/>
    </session-factory>
</hibernate-configuration>


‚ö° Because of hibernate.hbm2ddl.auto=update, Hibernate will auto-create/update tables in DB ‚Üí you don‚Äôt need to create manually.

4. Main Class (CRUD Operations)
package in.sp;

import in.sp.entities.User;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;

public class HibernateApp {
    public static void main(String[] args) {
        // Step 1: Load configuration
        Configuration cfg = new Configuration();
        cfg.configure("hibernate.cfg.xml");   // load from resources

        // Step 2: Build SessionFactory (heavyweight, thread-safe)
        SessionFactory sessionFactory = cfg.buildSessionFactory();

        // Step 3: Open Session (lightweight, per-operation)
        Session session = sessionFactory.openSession();

        // Step 4: Begin Transaction
        Transaction tx = session.beginTransaction();

        // INSERT (save/persist)
        User user1 = new User("Neha", "neha@example.com");
        session.save(user1); // OR session.persist(user1)

        // FETCH by id
        User fetchedUser = session.get(User.class, 1); // primary key lookup
        System.out.println("Fetched: " + fetchedUser);

        // UPDATE
        if (fetchedUser != null) {
            fetchedUser.setName("Neha Raghav");
            session.update(fetchedUser);
        }

        // DELETE
        if (fetchedUser != null) {
            session.delete(fetchedUser);
        }

        // Step 5: Commit Transaction
        tx.commit();

        // Step 6: Close Session & SessionFactory
        session.close();
        sessionFactory.close();
    }
}

5. Database Setup

Before running, just create the database (Hibernate will handle table creation):

CREATE DATABASE hibernate_demo;


Then run the program ‚Üí Hibernate will create the users table automatically.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Notefrom pring initilizater 
*just create the normal maven prect
*we dont connect hibernate directly with the spring boo
*so spring data jpa internally uses the hibernate and then the it provide cosde easily available and built in query support like findAll
*so make use of the pring project starter
*add the hibernate-core
*MySQL
*jaxbapi dependency
*jaxb-core
*jaxb-impl


*make the enity user with table an denetity annotation 
*and make the hibernate.cfg.xml
*so in main now call the cong=fiure the session factor make session and sa euser
*But the code written in main s very bad
*so first store all cruds in separate file make interface db operations ther method as the getuserdetails th id as perimison 
Now want here session .get(UserClass.,1)
*so make the session in another class and return there session facto there make method as static
*in main method there application context run from the springboo.run there call getbean by the implemented class from interface dboperation and povde d

Note:here make the implemeying method as reo sot that it can be get by means


Data JPA directly. Instead:

Add Hibernate core + MySQL + JAXB dependencies manually.

Create User entity with @Entity, @Table, etc.

Use hibernate.cfg.xml for config.

Create a SessionFactory utility class to manage Hibernate sessions.

Create a Repository interface (DbOperations) with methods like saveUser, getUserById.

Create a Repository implementation (@Repository) that uses Hibernate SessionFactory.

Finally, in main() (Spring Boot entry point), use ApplicationContext.getBean(...) to get repo bean and perform CRUD.

This way your CRUD code is not dumped inside main(), but separated cleanly.

üìÇ Project Structure
springboot-hibernate-crud/
 ‚îú‚îÄ‚îÄ src/main/java/in/sp/Application.java
 ‚îú‚îÄ‚îÄ src/main/java/in/sp/config/HibernateUtil.java
 ‚îú‚îÄ‚îÄ src/main/java/in/sp/entities/User.java
 ‚îú‚îÄ‚îÄ src/main/java/in/sp/repository/DbOperations.java
 ‚îú‚îÄ‚îÄ src/main/java/in/sp/repository/UserRepositoryImpl.java
 ‚îî‚îÄ‚îÄ src/main/resources/hibernate.cfg.xml
 ‚îî‚îÄ‚îÄ pom.xml

1. pom.xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">

    <modelVersion>4.0.0</modelVersion>
    <groupId>in.sp</groupId>
    <artifactId>springboot-hibernate-crud</artifactId>
    <version>1.0-SNAPSHOT</version>

    <dependencies>
        <!-- Spring Boot Starter (basic) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>

        <!-- Hibernate Core -->
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-core</artifactId>
            <version>5.6.15.Final</version>
        </dependency>

        <!-- MySQL Driver -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <version>8.0.33</version>
        </dependency>

        <!-- JAXB (needed in Java 11+ for Hibernate config parsing) -->
        <dependency>
            <groupId>javax.xml.bind</groupId>
            <artifactId>jaxb-api</artifactId>
            <version>2.3.1</version>
        </dependency>
        <dependency>
            <groupId>com.sun.xml.bind</groupId>
            <artifactId>jaxb-core</artifactId>
            <version>2.3.0.1</version>
        </dependency>
        <dependency>
            <groupId>com.sun.xml.bind</groupId>
            <artifactId>jaxb-impl</artifactId>
            <version>2.3.2</version>
        </dependency>
    </dependencies>
</project>

2. Entity ‚Äì User.java
package in.sp.entities;

import javax.persistence.*;

@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(unique = true, nullable = false)
    private String email;

    public User() {}
    public User(String name, String email) {
        this.name = name;
        this.email = email;
    }

    // getters & setters
    public int getId() { return id; }
    public void setId(int id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    @Override
    public String toString() {
        return "User [id=" + id + ", name=" + name + ", email=" + email + "]";
    }
}

3. Hibernate Config ‚Äì hibernate.cfg.xml
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd">

<hibernate-configuration>
    <session-factory>
        <!-- DB Config -->
        <property name="hibernate.connection.driver_class">com.mysql.cj.jdbc.Driver</property>
        <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/hibernate_demo</property>
        <property name="hibernate.connection.username">root</property>
        <property name="hibernate.connection.password">yourpassword</property>

        <!-- Hibernate Dialect -->
        <property name="hibernate.dialect">org.hibernate.dialect.MySQL8Dialect</property>

        <!-- Schema auto-creation -->
        <property name="hibernate.hbm2ddl.auto">update</property>

        <!-- Show SQL -->
        <property name="hibernate.show_sql">true</property>
        <property name="hibernate.format_sql">true</property>

        <!-- Mapping -->
        <mapping class="in.sp.entities.User"/>
    </session-factory>
</hibernate-configuration>

4. SessionFactory Utility ‚Äì HibernateUtil.java
package in.sp.config;

import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

public class HibernateUtil {
    private static SessionFactory sessionFactory;

    static {
        try {
            Configuration cfg = new Configuration();
            cfg.configure("hibernate.cfg.xml");
            sessionFactory = cfg.buildSessionFactory();
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("Failed to initialize Hibernate SessionFactory");
        }
    }

    public static SessionFactory getSessionFactory() {
        return sessionFactory;
    }
}

5. Repository Interface ‚Äì DbOperations.java
package in.sp.repository;

import in.sp.entities.User;

public interface DbOperations {
    void saveUser(User user);
    User getUserById(int id);
}

6. Repository Implementation ‚Äì UserRepositoryImpl.java
package in.sp.repository;

import in.sp.config.HibernateUtil;
import in.sp.entities.User;
import org.hibernate.Session;
import org.hibernate.Transaction;
import org.springframework.stereotype.Repository;

@Repository
public class UserRepositoryImpl implements DbOperations {

    @Override
    public void saveUser(User user) {
        Session session = HibernateUtil.getSessionFactory().openSession();
        Transaction tx = session.beginTransaction();
        session.save(user);
        tx.commit();
        session.close();
        System.out.println("User saved: " + user);
    }

    @Override
    public User getUserById(int id) {
        Session session = HibernateUtil.getSessionFactory().openSession();
        User user = session.get(User.class, id);
        session.close();
        return user;
    }
}

7. Main App ‚Äì Application.java
package in.sp;

import in.sp.entities.User;
import in.sp.repository.DbOperations;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;

@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(Application.class, args);

        // Get Repository Bean
        DbOperations userRepo = context.getBean(UserRepositoryImpl.class);

        // Save user
        User user1 = new User("Neha", "neha@example.com");
        userRepo.saveUser(user1);

        // Fetch user
        User fetched = userRepo.getUserById(1);
        System.out.println("Fetched User: " + fetched);
    }
}

8. Database Setup

Create database (Hibernate will create table automatically):

CREATE DATABASE hibernate_demo;


‚úÖ Now you have:

Spring Boot project (but using Hibernate manually, not Spring Data JPA).

Clean separation:

HibernateUtil manages SessionFactory.

DbOperations interface defines CRUD methods.

UserRepositoryImpl implements it and is marked @Repository so Spring can inject.

Application runs and gets the repo bean from ApplicationContext.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------














----------------------------------------------------------------------------------------------------------------------------------------------------------------
Sheet questios
1.What are the object class methods and how many of them you have overridden and implemented in your project?
*Every class in Java implicitly extends Object class (if no other superclass is specified).

The Object class is in java.lang package.

It provides several methods that every Java class inherits.

1.. toString()

üëâ Used for logging/debugging (instead of default ClassName@hashCode).
class Employee {
    int id;
    String name;

    Employee(int id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Employee{id=" + id + ", name='" + name + "'}";
    }
}

public class Test {
    public static void main(String[] args) {
        Employee e = new Employee(101, "Neha");
        System.out.println(e); // Employee{id=101, name='Neha'}
    }
}



2.Why are we overriding equals() here?

By default, equals() in Object class just checks reference equality (i.e., whether two references point to the exact same object in memory).

In most business cases, we want to check logical equality (i.e., whether two objects have the same state/values).

üëâ Example: Two Student objects with the same roll number should be considered equal, even if they are stored at different memory locations.

Without overriding
class Student {
    int roll;
    Student(int roll) { this.roll = roll; }
}

public class Test {
    public static void main(String[] args) {
        Student s1 = new Student(1);
        Student s2 = new Student(1);

        System.out.println(s1.equals(s2)); // false ‚ùå (compares references)
    }
}

With overriding equals()
class Student {
    int roll;
    Student(int roll) { this.roll = roll; }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Student)) return false;
        Student s = (Student) obj;
        return this.roll == s.roll;
    }
}

public class Test {
    public static void main(String[] args) {
        Student s1 = new Student(1);
        Student s2 = new Student(1);

        System.out.println(s1.equals(s2)); // true ‚úÖ (compares state)
    }
}

üîπ What happens if we don‚Äôt override?

Objects with same data but different references ‚Üí equals() returns false.

Collections that rely on equality (HashSet, HashMap, contains(), etc.) won‚Äôt behave correctly.

Example with HashSet
import java.util.*;

class Student {
    int roll;
    Student(int roll) { this.roll = roll; }
    // equals() not overridden
}

public class Test {
    public static void main(String[] args) {
        HashSet<Student> set = new HashSet<>();
        set.add(new Student(1));
        set.add(new Student(1));

        System.out.println(set.size()); // 2 ‚ùå (duplicates allowed!)
    }
}

After overriding equals() + hashCode()
import java.util.*;

class Student {
    int roll;
    Student(int roll) { this.roll = roll; }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Student)) return false;
        Student s = (Student) obj;
        return this.roll == s.roll;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(roll);
    }
}

public class Test {
    public static void main(String[] args) {
        HashSet<Student> set = new HashSet<>();
        set.add(new Student(1));
        set.add(new Student(1));

        System.out.println(set.size()); // 1 ‚úÖ (duplicate prevented)
    }
}

‚úÖ Final Interview-style Answer

"We override equals() when we want two objects to be compared by their state (like roll number in Student) instead of their memory reference.



3.class Address implements Cloneable {
    String city;
    Address(String city) { this.city = city; }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone(); // shallow copy
    }
}

public class Test {
    public static void main(String[] args) throws CloneNotSupportedException {
        Address a1 = new Address("Delhi");
        Address a2 = (Address) a1.clone();
        a2.city = "Mumbai";
        System.out.println(a1.city); // Delhi
        System.out.println(a2.city); // Mumbai
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
2.What is the advantage of overriding hashcode() and equals() ?

By default:

equals() in Object checks reference equality.

hashCode() in Object returns a unique integer for each object‚Äôs memory address.


So if you don‚Äôt override them:

Two objects with same data will be treated as different, even if logically equal.

Collections like HashMap, HashSet, Hashtable will misbehave.



Correct behavior in hashing-based collections (HashMap, HashSet, HashTable)

These collections use hashCode() first to find the "bucket" where the object might be stored, and then use equals() to resolve collisions.

If you override only equals() but not hashCode(), equal objects may end up in different buckets ‚Üí duplicates allowed.

If you override only hashCode() but not equals(), objects in the same bucket may still not match
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
Types of cloning 
üîπ What is Cloning?

In Java, cloning means creating a copy of an object.
Java provides clone() method in the Object class for this.

But the way the copy is made depends on the type of cloning.

üîπ Types of Cloning
1. Shallow Cloning

Creates a copy of the object, but does not clone nested objects (it copies their references).

So both original and clone share the same nested object.

Default behavior of Object.clone().

Example
class Address {
    String city;
    Address(String city) { this.city = city; }
}

class Student implements Cloneable {
    int id;
    Address address;

    Student(int id, Address address) {
        this.id = id;
        this.address = address;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone(); // Shallow copy
    }
}

public class Test {
    public static void main(String[] args) throws CloneNotSupportedException {
        Address addr = new Address("Delhi");
        Student s1 = new Student(1, addr);

        Student s2 = (Student) s1.clone();
        s2.address.city = "Mumbai"; // changes shared object

        System.out.println(s1.address.city); // Mumbai ‚ùå
        System.out.println(s2.address.city); // Mumbai
    }
}


üëâ Problem: Both objects share the same nested reference.

2. Deep Cloning

Creates a full independent copy of the object and all nested objects.

No references are shared ‚Üí modifying clone doesn‚Äôt affect original.

You must override clone() and clone nested objects manually.

Example
class Address implements Cloneable {
    String city;
    Address(String city) { this.city = city; }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

class Student implements Cloneable {
    int id;
    Address address;

    Student(int id, Address address) {
        this.id = id;
        this.address = address;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        Student cloned = (Student) super.clone();
        cloned.address = (Address) address.clone(); // Deep copy
        return cloned;
    }
}

public class Test {
    public static void main(String[] args) throws CloneNotSupportedException {
        Address addr = new Address("Delhi");
        Student s1 = new Student(1, addr);

        Student s2 = (Student) s1.clone();
        s2.address.city = "Mumbai"; // change only in clone

        System.out.println(s1.address.city); // Delhi ‚úÖ
        System.out.println(s2.address.city); // Mumbai
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is use of serialization ? What is Deserialization
*Serialization

Definition: Serialization is the process of converting a Java object into a byte stream (sequence of bytes).

This byte stream can be:

Stored in a file / database, or

Transferred over a network.

The class must implement java.io.Serializable interface (a marker interface ‚Üí no methods).

Example: Serialization
import java.io.*;

class Student implements Serializable {
    int id;
    String name;

    Student(int id, String name) {
        this.id = id;
        this.name = name;
    }
}

public class SerializeDemo {
    public static void main(String[] args) throws Exception {
        Student s1 = new Student(101, "Neha");

        FileOutputStream fos = new FileOutputStream("student.ser");
        ObjectOutputStream oos = new ObjectOutputStream(fos);

        oos.writeObject(s1);  // Serialization
        oos.close();
        fos.close();

        System.out.println("Object serialized successfully!");
    }
}


This creates a file student.ser containing the object data in byte format.

üîπ Deserialization

Definition: Deserialization is the reverse process ‚Äî converting the byte stream back into a Java object.

In other words, reconstructing the object from its serialized form.

Example: Deserialization
import java.io.*;

public class DeserializeDemo {
    public static void main(String[] args) throws Exception {
        FileInputStream fis = new FileInputStream("student.ser");
        ObjectInputStream ois = new ObjectInputStream(fis);

        Student s2 = (Student) ois.readObject(); // Deserialization
        ois.close();
        fis.close();

        System.out.println("Object deserialized successfully!");
        System.out.println("Id: " + s2.id + ", Name: " + s2.name);
    }
}

üîπ Use of Serialization

Persistence

Save object‚Äôs state into a file/database so it can be restored later.

Communication

Send Java objects over a network (RMI, sockets, messaging systems).

Caching

Store serialized objects temporarily for faster retrieval.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
transient Keyword in Java
‚úÖ Definition

The transient keyword in Java is used to mark a variable so that it is not serialized.

During serialization, all non-transient instance variables are saved, but transient variables are skipped.

When the object is deserialized, transient variables are initialized with their default values (e.g., null for objects, 0 for numbers, false for booleans).

‚úÖ Why use transient?

Sensitive Information

We don‚Äôt want to store passwords, credit card details, or security tokens in plain serialized form.

class User implements Serializable {
    String username;
    transient String password; // will not be serialized
}


Derived or Computed Values

If a field can be recalculated from other data, no need to serialize it.

class Employee implements Serializable {
    double salary;
    transient double bonus; // can be recalculated later
}


Non-Serializable Objects

If a field refers to an object that doesn‚Äôt implement Serializable, marking it transient prevents errors.

class Manager implements Serializable {
    String name;
    transient Thread thread; // Thread is not serializable
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
We can implement custom serialization in Java by providing writeObject() and readObject() methods in our class. These methods override the default serialization behavior and allow us to control how fields are written to and read from the stream ‚Äî for example, encrypting sensitive data or handling transient/non-serializable fields."

import java.io.*;

class User implements Serializable {
    private String username;
    private transient String password; // not directly serialized

    public User(String username, String password) {
        this.username = username;
        this.password = password;
    }

    public String getUsername() { return username; }
    public String getPassword() { return password; }

    // Custom serialization
    private void writeObject(ObjectOutputStream oos) throws IOException {
        oos.defaultWriteObject(); // serialize non-transient fields normally

        // Custom logic: encrypt password before writing
        String encryptedPassword = "123" + password; // dummy encryption
        oos.writeObject(encryptedPassword);
    }

    // Custom deserialization
    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
        ois.defaultReadObject(); // deserialize non-transient fields

        // Custom logic: decrypt password after reading
        String encryptedPassword = (String) ois.readObject();
        this.password = encryptedPassword.substring(3); // dummy decryption
    }
}

public class CustomSerializationDemo {
    public static void main(String[] args) throws Exception {
        User user = new User("neha", "secret123");

        // Serialize
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("user.ser"));
        oos.writeObject(user);
        oos.close();

        // Deserialize
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("user.ser"));
        User deserializedUser = (User) ois.readObject();
        ois.close();

        System.out.println("Username: " + deserializedUser.getUsername());
        System.out.println("Password: " + deserializedUser.getPassword()); // restored correctly
    }
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Which is more efficient to use between HahMap and LinkedHashMap ?
HashMap vs LinkedHashMap Efficiency
1. HashMap

Structure ‚Üí Backed by hash table only.

Order ‚Üí No guarantee of order (insertion or access).

Performance:

Insertion / Lookup / Deletion ‚Üí O(1) average.

Memory overhead ‚Üí Lower (only stores keys/values + hash structure).

Best for: When you only care about fast lookups and don‚Äôt care about order.

2. LinkedHashMap

Structure ‚Üí Hash table + doubly linked list.

Order ‚Üí Maintains insertion order (or access order if configured).

Performance:

Insertion / Lookup / Deletion ‚Üí Still O(1) average, but slightly slower than HashMap due to maintaining the linked list.

Memory overhead ‚Üí Higher (extra pointers for before/after nodes).

Best for: When you need both fast lookups AND predictable iteration order.
Map<String, Integer> hashMap = new HashMap<>();
hashMap.put("one", 1);
hashMap.put("two", 2);
hashMap.put("three", 3);
System.out.println(hashMap); 
// Order unpredictable: {two=2, one=1, three=3}

Map<String, Integer> linkedMap = new LinkedHashMap<>();
linkedMap.put("one", 1);
linkedMap.put("two", 2);
linkedMap.put("three", 3);
System.out.println(linkedMap); 
// Predictable order: {one=1, two=2, three=3}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What are the java 8 features ?
1.lambda function
befor java 8
*import java.util.*;

public class LambdaExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Neha", "Raghav", "OpenAI", "Java");

        // Before Java 8: Anonymous inner class
        Collections.sort(names, new Comparator<String>() {
            @Override
            public int compare(String s1, String s2) {
                return Integer.compare(s1.length(), s2.length());
            }
        });

        System.out.println(names);
    }
}

Here, we are creating an anonymous class (new Comparator<String>() {...}) just to implement a small function.
import java.util.*;

public class LambdaExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Neha", "Raghav", "OpenAI", "Java");

        // Using Lambda Expression
        Collections.sort(names, (s1, s2) -> Integer.compare(s1.length(), s2.length()));

        System.out.println(names);
    }
}

What‚Äôs happening?

Before Java 8: We had to write a lot of boilerplate (new Comparator... override compare...).

With Lambda: We just write the logic ((s1, s2) -> ...).

‚úÖ Another Simple Example

// Without Lambda
List<String> list = Arrays.asList("a", "b", "c");
list.forEach(new Consumer<String>() {
    public void accept(String s) {
        System.out.println(s);
    }
});

// With Lambda
list.forEach(s -> System.out.println(s));


‚ö° In short:
Lambda = shortcut to write anonymous functions (especially for interfaces with a single abstract method, i.e., functional interfaces like Runnable, Comparator, Consumer).




2.Functional Interfaces

What: An interface with exactly one abstract method.

Why: Provides target type for lambdas.

Where to Use: Java 8 built-in ones like Predicate, Consumer, Supplier.

@FunctionalInterface
interface Greeting {
    void sayHello();
}

Greeting g = () -> System.out.println("Hello!");
g.sayHello();



3.Stream api

List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// Filter even numbers and square them
List<Integer> result = numbers.stream()
    .filter(n -> n % 2 == 0)   // keep only even numbers
    .map(n -> n * n)           // square each number
    .collect(Collectors.toList()); // convert Stream back to List

System.out.println(result); // [4, 16]
Why Streams API is Powerful

Declarative ‚Üí You just say what to do, not how to loop.

Compact ‚Üí No need for multiple loops/if-statements.

Parallelizable ‚Üí Can easily use .parallelStream() for multi-core processing.

Functional style ‚Üí Works nicely with Lambdas.

Streams API

What: Process collections declaratively (like SQL).

Why: Simplifies data filtering, mapping, reducing.

Where: Working with large data, transformations, aggregations.

4.1Ô∏è‚É£ Optional Class

What:

A container object introduced in Java 8.

Used to wrap values that may be null to avoid NullPointerException.

Why:

Before Optional, we had to write manual null checks like:

if(name != null) {
    return name;
} else {
    return "Default";
}


Optional provides cleaner, safer ways.

Example:

Optional<String> name = Optional.ofNullable(null);

// if value is null ‚Üí return "Default Name"
System.out.println(name.orElse("Default Name"));  // Default Name

// Another example
Optional<String> city = Optional.of("Delhi");
city.ifPresent(c -> System.out.println("City: " + c)); // prints "City: Delhi"


üëâ Key methods:

ofNullable(value) ‚Üí wraps value (can be null).

orElse(defaultValue) ‚Üí returns default if empty.

ifPresent(action) ‚Üí runs action only if value exists.




4.2Ô∏è‚É£ New Date & Time API (java.time)

What:

Introduced in Java 8 (java.time package).

Classes: LocalDate, LocalTime, LocalDateTime, ZonedDateTime, Period, etc.

Why:

Old classes (Date, Calendar) were mutable, confusing, and not thread-safe.

New API is immutable, clear, and powerful.

Example:

LocalDate today = LocalDate.now();  
System.out.println("Today: " + today);  // e.g., 2025-08-22

LocalDate birth = LocalDate.of(1998, 5, 22);  

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
üîπ Why do we use Lambda Expressions?

Before Java 8, if you wanted to write inline functionality (like passing a block of code), you had to use anonymous inner classes which were verbose and repetitive.

Example without lambda:

// Runnable using anonymous inner class
Runnable r = new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello from thread!");
    }
};
new Thread(r).start();


Using Lambda Expression:

Runnable r = () -> System.out.println("Hello from thread!");
new Thread(r).start();


üëâ Much cleaner and more concise.
üëâ Lambda = a short block of code that can be passed around as if it‚Äôs data.

üîπ Advantages of Lambda Expressions

Concise Code (Less Boilerplate)

No need to write unnecessary class, method, or override syntax.

Makes code shorter and cleaner.

// Without lambda
List<String> list = Arrays.asList("a", "b", "c");
list.forEach(new Consumer<String>() {
    public void accept(String s) {
        System.out.println(s);
    }
});

// With lambda
list.forEach(s -> System.out.println(s));


Functional Programming Style

Enables Java to support functional programming.

You can pass behavior (functions) as parameters, not just data.

List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5);
nums.stream()
    .filter(n -> n % 2 == 0)  // behavior passed as lambda
    .forEach(System.out::println);


Improves Readability & Maintainability

Code looks more like "what to do" rather than "how to do".

Easier to understand logic at a glance.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
üîπ Key Differences (Comparison Table)
Feature	Synchronized HashMap	ConcurrentHashMap
Thread-safety	Yes (via synchronized methods)	Yes (via fine-grained locking)
Locking	Whole map locked	Bucket/segment level locking
Performance	Slower in concurrent access	Faster in concurrent access
Iteration	Must synchronize manually, fail-fast	No need to synchronize, fail-safe
Null keys/values	Allows 1 null key, multiple null values	Does NOT allow null keys/values
Best use case	Few threads, small map	Many threads, large map
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
Difference between stack and heap

*Stacks
Method call frames (each method execution has its own "box").

Local variables:

Primitive values (int, double, etc.).

References (addresses) to objects in the heap.

Thread-specific: Each thread has its own stack.

Fast access because it‚Äôs very structured.

Limited size: Too many calls (like infinite recursion) ‚Üí StackOverflowError.

public class StackExample {
    public static void main(String[] args) {
        int x = 10;          // stored in stack (primitive)
        int y = 20;          // stored in stack
        int result = add(x, y); // method call pushed onto stack
        System.out.println(result);
    }

    static int add(int a, int b) {
        int sum = a + b;     // stored in stack (primitive)
        return sum;          // frame is popped after return
    }
}


*Heap
*Heap Memory
‚úÖ What it stores

Objects (all new objects).

Instance variables of those objects.

Static variables (in special area of heap called "metaspace" in modern JVMs).

‚úÖ Characteristics

Shared among all threads.

Larger than stack but slower.

Garbage collected (JVM frees unused objects).

üìå Example: Heap behavior
class Person {
    String name;
    int age;
}

public class HeapExample {
    public static void main(String[] args) {
        Person p1 = new Person();   // object stored in heap
        p1.name = "Alice";          // instance variables in heap
        p1.age = 25;

        Person p2 = new Person();   // another object in heap
        p2.name = "Bob";
        p2.age = 30;

        // References p1, p2 are in stack, but they point to heap objects
        System.out.println(p1.name + " & " + p2.name);
    }
}


Memory layout:

Stack: contains references p1 and p2.

Heap: contains two Person objects (Alice,25 and Bob,30).

When main ends, references vanish, objects become eligible for Garbage Collection.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
üîπ 1. final (Keyword)

What it is: Modifier (used with variables, methods, classes).

Purpose: To restrict modification/inheritance.

‚úÖ Usage:

final variable ‚Üí value cannot change (constant).

final method ‚Üí cannot be overridden by subclasses.

final class ‚Üí cannot be extended (no subclass).

final class Vehicle {} // cannot be inherited

class Car {
    final int speed = 100; // cannot reassign speed
    final void drive() {   // cannot override
        System.out.println("Driving safely");
    }
}

üîπ 2. finally (Block)

What it is: A block in exception handling (try-catch-finally).

Purpose: To ensure cleanup code always executes (like closing DB connections, file streams, etc.).

Always runs whether exception occurs or not, except in case of System.exit(0).

‚úÖ Usage:

try {
    int result = 10 / 0; // ArithmeticException
} catch (Exception e) {
    System.out.println("Exception caught: " + e);
} finally {
    System.out.println("Finally block always executes"); 
}

üîπ 3. finalize() (Method)

What it is: A method in Object class.

Purpose: Called by Garbage Collector (GC) before destroying an object ‚Üí used for cleanup.

Not guaranteed to run immediately, or even at all (GC decides).

Deprecated in Java 9+ (better to use try-with-resources or explicit cleanup).

‚úÖ Usage:

class TestFinalize {
    @Override
    protected void finalize() throws Throwable {
        System.out.println("Object is being garbage collected");
    }

    public static void main(String[] args) {
        TestFinalize t = new TestFinalize();
        t = null; // eligible for GC
        System.gc(); // Request GC (not guaranteed)
    }
}

üîπ Key Differences at a Glance
Feature	final	finally	finalize()
Type	Keyword	Block	Method
Used for	Restriction (variables, methods, classes)	Cleanup code in exception handling	Cleanup before GC destroys object
When executed	Compile-time restriction	Always after try-catch	Before object destruction (GC)
Control	Programmer	Programmer	JVM/GC
Example use	final int x=10;	finally { closeConnection(); }	protected void finalize()

‚úÖ Quick way to remember:

final ‚Üí restriction üö´

finally ‚Üí cleanup üßπ

finalize ‚Üí last wish before death ‚ò†Ô∏è

Do you want me to also give you a real-world analogy (like comparing them to rules, safety nets, and last rites üòÖ) so you remember them instantly in interviews?
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is the Java Collection Framework (JCF)?
*A unified architecture to store and manipulate groups of objects.

*Provides interfaces, implementations (classes), and algorithms (utility methods).

*Located in the package java.util.

*Core Interfaces of Collections

Collection (root interface)

Represents a group of objects (called elements).

Subinterfaces: List, Set, Queue.


1.List (ordered, allows duplicates)

Elements stored in insertion order.

Can contain duplicates.

Access via index.

üëâ Implementations:

ArrayList ‚Üí resizable array, fast random access, slow insertion/removal.

LinkedList ‚Üí doubly linked list, fast insertion/deletion, slower random access.

Vector (legacy) ‚Üí synchronized version of ArrayList.

Stack ‚Üí subclass of Vector, LIFO order.


2.2. Set (unordered, no duplicates)

Stores unique elements only.

No duplicates allowed.

üëâ Implementations:

HashSet ‚Üí based on hash table, fast lookup, no order guarantee.

LinkedHashSet ‚Üí maintains insertion order.

TreeSet ‚Üí sorted order, uses Red-Black tree, no null allowed.


3.3Queue (FIFO order, some variations)

Used for holding elements prior to processing.

üëâ Implementations:

PriorityQueue ‚Üí elements ordered by priority (natural ordering or comparator).

ArrayDeque ‚Üí double-ended queue, can act as stack/queue.

LinkedList ‚Üí also implements Queue.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
ArrayList vs Vector

eature	ArrayList	Vector
Thread-Safety	Not synchronized ‚Üí faster in single-threaded apps	Synchronized ‚Üí thread-safe but slower
Performance	Faster (no synchronization overhead)	Slower (synchronization cost)
Legacy vs Modern	Introduced in Java 1.2 (part of Collections framework)	Introduced in Java 1.0 (legacy class)
Growth	Increases capacity by 50% when full	Doubles capacity when full
Use Case	Best for single-threaded applications	Best for multi-threaded apps (though CopyOnWriteArrayList or other concurrent classes are preferred in modern code)

Feature	HashMap	Hashtable
Thread-Safety	Not synchronized ‚Üí not thread-safe	Synchronized ‚Üí thread-safe
Performance	Faster (no synchronization overhead)	Slower (synchronization overhead)
Null Keys/Values	1 null key allowed, multiple null values allowed	‚ùå No null keys or values allowed
Legacy vs Modern	Introduced in Java 1.2 (part of Collections framework)	Introduced in Java 1.0 (legacy class)
Iteration	Uses Iterator (fail-fast)	Uses Enumerator (not fail-fast)
Use Case	Best for single-threaded or concurrent apps with explicit control (use ConcurrentHashMap for threads)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Explain Java class loaders? Explain static class vs. dynamic class loading?
A ClassLoader in Java is part of the JVM responsible for loading classes into memory (from .class files, JARs, or network).

When you run a Java program:

.java ‚Üí compiled into .class (bytecode).

ClassLoader loads bytecode into JVM.

JVM links and initializes the class.

‚úÖ Static Class Loading

Class is loaded at compile-time (via new keyword).

Example:

Dog d = new Dog();  // static loading


JVM knows at compile time which class to load.

Used in most normal Java code.

Faster, but less flexible.


Dynamic Class Loading

Class is loaded at runtime (via reflection, Class.forName(), or ClassLoader.loadClass()).

Example:

Class<?> cls = Class.forName("com.example.Dog");  
Object obj = cls.getDeclaredConstructor().newInstance();


Used in:

JDBC (loading driver classes dynamically).

Frameworks like Spring, Hibernate.

Servlets & containers.

More flexible, but slower.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
A marker interface is an interface with no methods or fields defined.
Its purpose is not to define behavior, but to mark a class as having a special property so that the JVM or frameworks can treat it differently.

üëâ In other words, it‚Äôs a tag or label for classes.

‚úÖ Examples of Marker Interfaces in Java

Serializable ‚Üí Marks a class as serializable (objects can be converted into a byte stream).

Cloneable ‚Üí Marks a class as cloneable (objects can use .clone() method).

Remote (RMI) ‚Üí Marks a class whose methods can be invoked from another JVM.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Give an example where you might use a static method?

A static method belongs to the class, not to objects.

You don‚Äôt need to create an object to call it ‚Üí just use ClassName.methodName().

Best for utility/helper methods that don‚Äôt depend on instance variables.

class MathUtil {
    // static method for factorial
    public static int factorial(int n) {
        int result = 1;
        for(int i = 1; i <= n; i++) {
            result *= i;
        }
        return result;
    }
}

public class TestStatic {
    public static void main(String[] args) {
        // No need to create object of MathUtil
        int fact = MathUtil.factorial(5);
        System.out.println("Factorial of 5 is: " + fact);
    }
}

For singleton/factory design patterns (to provide one global access point).
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Where and how can you use a private constructor?

Where & How to Use a Private Constructor?
1. Singleton Pattern

Ensures only one object is created.

class Singleton {
    private static Singleton instance;

    // private constructor prevents external instantiation
    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();  // created only once
        }
        return instance;
    }
}


‚úÖ Prevents multiple objects of Singleton.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
24. What do you know about the Java garbage collector? When does the garbage collection occur? Explain different
types of references in Java?
Types of References in Java

Java provides 4 levels of references (java.lang.ref package). These control how GC treats an object:

1. Strong Reference (default)

Normal reference in Java.

String s = new String("Hello");


As long as s points to object, GC won‚Äôt collect it.

Most commonly used.

2. Weak Reference

GC can reclaim object if only weak references exist.

import java.lang.ref.WeakReference;

String str = new String("Hello");
WeakReference<String> weakRef = new WeakReference<>(str);

str = null;  // remove strong reference
System.gc();

System.out.println(weakRef.get()); // may print null if GC collected it


‚úÖ Used in caches (e.g., WeakHashMap).

3. Soft Reference

GC collects them only if memory is low (not immediately like Weak Reference).

import java.lang.ref.SoftReference;

String str = new String("Hello");
SoftReference<String> softRef = new SoftReference<>(str);

str = null;
System.gc();

System.out.println(softRef.get()); // likely still available unless memory is low


‚úÖ Used for memory-sensitive caching (images, documents).

4. Phantom Reference

Doesn‚Äôt prevent GC at all.
Object is already finalized, but you can get notified before memory is reclaimed.

import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;

String str = new String("Hello");
ReferenceQueue<String> queue = new ReferenceQueue<>();
PhantomReference<String> phantomRef = new PhantomReference<>(str, queue);

str = null;
System.gc();

System.out.println(phantomRef.get()); // always null


‚úÖ Used in cleanup tasks (like deallocating native resources).

üîë Summary

Garbage Collector: Frees memory by removing unreachable objects.

GC occurs automatically when heap is low or at JVM discretion.

Reference types:

Strong ‚Üí normal, never GC‚Äôd until unreachable.

Soft ‚Üí collected if memory is low.

Weak ‚Üí collected eagerly (used in caches).

Phantom ‚Üí collected, but lets you do cleanup via ReferenceQueue.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is conscurrenctmodification exception
What is ConcurrentModificationException?

ConcurrentModificationException is a runtime exception in Java that occurs when a collection (like ArrayList, HashMap, etc.) is structurally modified while being iterated in a way that is not allowed.

üëâ In simple words:
If one thread (or even the same thread) is iterating over a collection and modifies it structurally (add/remove/change size) at the same time, Java throws this exception.

üîπ Example
import java.util.*;

public class CMEExample {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");

        for (String s : list) {
            if (s.equals("B")) {
                list.remove(s); // ‚ùå causes ConcurrentModificationException
            }
        }
    }
}


üëâ Output:

Exception in thread "main" java.util.ConcurrentModificationException

üîπ Why does this happen?

Java collection classes like ArrayList, HashMap maintain an internal modCount (modification count).

The iterator checks if the collection is modified after the iterator was created.

If modCount changes unexpectedly ‚Üí fail-fast behavior ‚Üí ConcurrentModificationException.

üîπ How to Avoid It
‚úÖ 1. Use Iterator‚Äôs own remove() method
Iterator<String> it = list.iterator();
while (it.hasNext()) {
    String s = it.next();
    if (s.equals("B")) {
        it.remove();  // ‚úÖ Safe way
    }
}

‚úÖ 2. Use CopyOnWriteArrayList (thread-safe)
import java.util.concurrent.CopyOnWriteArrayList;

CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
list.add("A");
list.add("B");
list.add("C");

for (String s : list) {
    if (s.equals("B")) {
        list.remove(s);  // ‚úÖ No exception
    }
}

‚úÖ 3. Use ConcurrentHashMap (for maps)
import java.util.concurrent.ConcurrentHashMap;

ConcurrentHashMap<Integer, String> map = new ConcurrentHashMap<>();
map.put(1, "A");
map.put(2, "B");

for (Integer key : map.keySet()) {
    if (key == 2) {
        map.remove(key); // ‚úÖ Allowed
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
How to remove even number from collections ArrayList without using iteration
‚úÖ 1. Using removeIf() (introduced in Java 8)
import java.util.ArrayList;

public class RemoveEven {
    public static void main(String[] args) {
        ArrayList<Integer> numbers = new ArrayList<>();
        numbers.add(1);
        numbers.add(2);
        numbers.add(3);
        numbers.add(4);
        numbers.add(5);
        numbers.add(6);

        // Removes all even numbers
        numbers.removeIf(n -> n % 2 == 0);

        System.out.println(numbers); // [1, 3, 5]
    }
}


üëâ Here removeIf(Predicate) internally iterates, but you don‚Äôt explicitly write iteration.

‚úÖ 2. Using Streams (filter)
import java.util.*;
import java.util.stream.Collectors;

public class RemoveEvenStream {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);

        // Create a new list with only odd numbers
        List<Integer> oddNumbers = numbers.stream()
                                          .filter(n -> n % 2 != 0)
                                          .collect(Collectors.toList());

        System.out.println(oddNumbers); // [1, 3, 5]
    }
}


üëâ Here we don‚Äôt modify the original list, but generate a new filtered list.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Explain different ways of creating a thread and  implementations ?
There are 4 main ways of creating threads (with variations). Let‚Äôs go step by step üëá
1.1. By Extending Thread class

You create a class that extends Thread and override the run() method.

Then call start() to create a new thread.

class MyThread extends Thread {
    public void run() {
        System.out.println("Thread running: " + Thread.currentThread().getName());
    }
}

public class ThreadExample1 {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start();  // creates a new thread
    }
}


üëâ Not recommended in practice (because Java doesn‚Äôt support multiple inheritance, you lose flexibility).


2.2. By Implementing Runnable interface

You create a class that implements Runnable and pass it to a Thread object.

class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Thread running: " + Thread.currentThread().getName());
    }
}

public class ThreadExample2 {
    public static void main(String[] args) {
        Thread t1 = new Thread(new MyRunnable());
        t1.start();
    }
}


üëâ Better than extending Thread, because your class can still extend another class.


3. Using Anonymous Inner Class

No need for a separate class ‚Äî define Runnable inline.

public class ThreadExample3 {
    public static void main(String[] args) {
        Thread t1 = new Thread(new Runnable() {
            public void run() {
                System.out.println("Thread running with anonymous class!");
            }
        });
        t1.start();
    }
}

4. Using Lambda Expression (Java 8+)

Clean and concise.

public class ThreadExample4 {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            System.out.println("Thread running with lambda!");
        });
        t1.start();
    }
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
How can we achieve thread safety in Java?
A class/object is thread-safe if it behaves correctly when accessed by multiple threads simultaneously without causing data corruption or inconsistent state
Ways to Achieve Thread Safety in Java

1.1. Synchronization (synchronized keyword)

Ensures only one thread at a time can access a critical section (method/block).

class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}



2.22. Using synchronized Block

More fine-grained control (lock only the necessary code).
class Counter {
    private int count = 0;
    private final Object lock = new Object();

    public void increment() {
        synchronized(lock) {
            count++;
        }
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is Volatile keyword in java and usage of Volatile

*The volatile keyword in Java is a modifier used for variables.
*It tells the JVM that the value of this variable will be modified by multiple threads
*should always be read/written directly from main memory
*should always be read/written directly from main memory, not from the thread‚Äôs local cache (CPU cache or register).
*Normally, for performance, each thread may cache variables locally
*But if a variable is declared volatile, every read/write happens from main memory, ensuring visibility across threads.
*Key Points of volatile:

1.Visibility Guarantee
Changes made by one thread are immediately visible to other threads.

2.No Caching
Thread always reads the most recent value from main memory.

3.Atomicity
volatile guarantees atomicity only for reads/writes of single variables (like int, boolean, long if not split on 32-bit systems).
volatile int x = 5; ‚Üí Read/write is atomic.
‚ùå volatile++ (increment) is not atomic, because it involves read-modify-write.

Does not replace synchronization

Usage of volatile
1. Flags / Status variables
Used for variables that act as a signal between threads.


Note:lets understood different ways of creating thread 
Class implements Runnable

class VolatileExample implements Runnable {
    public void run() {
        // task
    }
}
Thread t1 = new Thread(new VolatileExample());


Anonymous Runnable

Thread t1 = new Thread(new Runnable() {
    public void run() {
        example.runTask();
    }
});


Lambda (Java 8)

Thread t1 = new Thread(() -> example.runTask());


Method Reference (Java 8) ‚Üê what I used

Thread t1 = new Thread(example::runTask);


All of these end up creating a Thread that executes example.runTask() when started.


1Ô∏è‚É£ t1.start();

Here, t1 is a Thread object.

Calling .start() creates a new thread of execution.

That new thread will internally call the run() method of the Runnable you passed (in our case, example.runTask()).

üëâ Important:
If you called t1.run(); instead of t1.start();, it would just run on the main thread, not create a new thread.

So:

t1.start(); // ‚úÖ spawns a new thread
t1.run();   // ‚ùå just calls the method in current thread

2Ô∏è‚É£ Thread.sleep(1000);

This is being executed by the main thread.

It makes the main thread pause for 1000 milliseconds (1 second).

During this time, t1 (the new thread) is running independently.





public class Test {
    public static void main(String[] args) throws InterruptedException {
        VolatileExample example = new VolatileExample();

        // Thread 1 -> runs the task
        Thread t1 = new Thread(example::runTask);
        t1.start();

        // Give it some time to run
        Thread.sleep(1000);

        // Thread 2 -> stops the task
        example.stopTask();
    }
}
here t1.start execute example ,runtask than main thread sleep ,then the main thread change the flag

so without volatile
Why volatile matters here

Without volatile:

Thread-1 may cache the value of flag in a CPU register or thread-local memory when it enters the loop.

Even though the main thread updates flag = false, Thread-1 might never go back to main memory to see the updated value.

As a result, while(flag) could run forever (infinite loop).

With volatile:

The JVM ensures that Thread-1 always reads flag from main memory, not from its cache.

So when main thread sets flag = false, Thread-1 will see the change immediately and exit the loop.




2.How does this affect Singleton?

When you write:

instance = new Singleton();


The JVM has to do 3 steps under the hood:

Allocate memory for the object.

Initialize the object (run the constructor).

Assign the reference to instance.

The JVM guarantees correctness only within a single thread, so without volatile the compiler/CPU may reorder 2 and 3:

Correct order (intended):

1. Allocate memory
2. Initialize object
3. Set instance reference


Possible reordered order (optimization):

1. Allocate memory
3. Set instance reference (non-null now!)
2. Initialize object
What‚Äôs the risk?

Thread A is creating the Singleton.

Before finishing step 2 (constructor), step 3 executes ‚Üí instance is non-null.

Thread B calls getInstance() and sees instance != null.

It returns the reference ‚Äî but the object is partially constructed ‚ùå (fields may still be default values).

This is why you could get subtle, hard-to-debug errors.


Singleton with Double-Checked Locking

To prevent instruction reordering in object initialization.

class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton(); // volatile prevents reordering
                }
            }
        }
        return instance;
    }
}


Here, volatile ensures that threads don‚Äôt see a partially constructed object due to compiler/CPU reordering.



3.3. Producer-Consumer signaling
class SharedResource {
    private volatile boolean available = false;

    public void produce() {
        // produce something
        available = true; // signal consumer
    }

    public void consume() {
        while (!available) {
            // wait until producer sets it
        }
        // consume
    }
}

üîπ When to Use volatile

When one thread writes and other threads read the variable.


When the variable is used as a status flag, configuration toggle, or completion signal.

When you need to prevent reordering issues in multi-threading.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Which is more preferred ‚Äì Synchronized method or synchronized block?


1.Example: Synchronized Method
class SharedResource {
    public synchronized void printMessage(String msg) {
        System.out.print("[" + msg);
        try {
            Thread.sleep(1000); // simulate some work
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("]");
    }
}
public class Test {
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();

        // Create 2 threads
        Thread t1 = new Thread(() -> resource.printMessage("Hello"));
        Thread t2 = new Thread(() -> resource.printMessage("World"));

        t1.start();
        t2.start();
    }
}
What happens here?

printMessage() is synchronized ‚Üí which means it locks on the intrinsic lock of resource (the this object).

If Thread-1 calls printMessage("Hello"):

It acquires the lock on resource.

While it holds the lock, Thread-2 cannot enter printMessage("World").

Thread-2 is blocked until Thread-1 releases the lock.
[Hello]
[World]
Meaning of "Method is Locked"

Only one thread at a time can execute this method on the same object instance.

Other threads calling the same method on the same object must wait.

Note:üîπ Rule:

A thread automatically acquires the lock when it enters a synchronized method (or block), and it automatically releases the lock when it exits that method (or block).

Pros:

Very simple and readable.

Good if the entire method truly needs synchronization.

‚ùå Cons:

Less efficient ‚Üí lock is held for the whole method, even for code that doesn‚Äôt access shared resources.

Reduces concurrency.




2.2. Synchronized Block
public void doWork() {
    // some non-critical code
    
    synchronized (this) {
        // only critical section locked
    }
    
    // other non-critical code
}


Locks only a specific block of code.

You can choose what object to lock on (not always this).
Example:

synchronized (lockObject) {
    // critical section
}


More fine-grained control over synchronization.

‚úÖ Pros:

More efficient ‚Üí only the critical section is synchronized.

Can choose a different lock object, allowing finer concurrency control.

Reduces the risk of bottlenecks.

‚ùå Cons:

Slightly more complex than a synchronized method.

Easier to misuse if you pick the wrong lock object.

class BankAccount {
    private int balance = 0;

    public void deposit(int amount) {
        // Non-critical: logging (can be done by multiple threads in parallel)
        System.out.println(Thread.currentThread().getName() + " is depositing...");

        // Critical section: updating shared balance
        synchronized (this) {
            balance += amount;
            System.out.println(Thread.currentThread().getName() + 
                               " updated balance: " + balance);
        }

        // Non-critical: notification
        System.out.println(Thread.currentThread().getName() + " finished deposit.");
    }
}

BankAccount account = new BankAccount();

Thread t1 = new Thread(() -> account.deposit(100), "Thread-1");
Thread t2 = new Thread(() -> account.deposit(200), "Thread-2");

t1.start();
t2.start();
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is ThreadLocal?
*So unlike static or instance variables (shared across threads), ThreadLocal variables are isolated per thread.

Think of it like:
üëâ A global variable where each thread has its own separate copy.

Why use ThreadLocal?
*Why use ThreadLocal?

To avoid sharing mutable state across threads.

To store thread-specific context (like user session, database connection, transaction info, etc.).

Used heavily in frameworks like Spring, Hibernate, Servlets, etc.


class MyCounter {
    private static ThreadLocal<Integer> threadLocalCounter = ThreadLocal.withInitial(() -> 0);

    public void increment() {
        threadLocalCounter.set(threadLocalCounter.get() + 1);
        System.out.println(Thread.currentThread().getName() + 
                           " -> Counter: " + threadLocalCounter.get());
    }
}

public class ThreadLocalExample {
    public static void main(String[] args) {
        MyCounter counter = new MyCounter();

        Runnable task = () -> {
            for (int i = 0; i < 3; i++) {
                counter.increment();
            }
        };

        Thread t1 = new Thread(task, "Thread-1");
        Thread t2 = new Thread(task, "Thread-2");

        t1.start();
        t2.start();
    }
}
1,2,3
1,2,3

Example 2: User Session (real-world)

Imagine a web server where each request runs in its own thread. You want to store current user info per thread:

class UserContext {
    private static ThreadLocal<String> currentUser = new ThreadLocal<>();

    public static void setUser(String user) {
        currentUser.set(user);
    }

    public static String getUser() {
        return currentUser.get();
    }

    public static void clear() {
        currentUser.remove(); // prevent memory leaks
    }
}


Usage:

Runnable request1 = () -> {
    UserContext.setUser("Alice");
    System.out.println(Thread.currentThread().getName() + " -> " + UserContext.getUser());
    UserContext.clear();
};

Runnable request2 = () -> {
    UserContext.setUser("Bob");
    System.out.println(Thread.currentThread().getName() + " -> " + UserContext.getUser());
    UserContext.clear();
};

new Thread(request1, "Request-1").start();
new Thread(request2, "Request-2").start();
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is Deadlock? How to analyze and avoid deadlock situation?

class DeadlockExample {
    private final Object lockA = new Object();
    private final Object lockB = new Object();

    public void method1() {
        synchronized (lockA) {
            System.out.println("Thread 1: Locked A");

            try { Thread.sleep(100); } catch (InterruptedException e) {}

            synchronized (lockB) {
                System.out.println("Thread 1: Locked B");
            }
        }
    }

    public void method2() {
        synchronized (lockB) {
            System.out.println("Thread 2: Locked B");

            try { Thread.sleep(100); } catch (InterruptedException e) {}

            synchronized (lockA) {
                System.out.println("Thread 2: Locked A");
            }
        }
    }
}

What happens?

Thread 1 enters method1() ‚Üí locks A.

Thread 2 enters method2() ‚Üí locks B.

Thread 1 tries to lock B ‚Üí but B is already locked by Thread 2 ‚Üí Thread 1 waits.

Thread 2 tries to lock A ‚Üí but A is already locked by Thread 1 ‚Üí Thread 2 waits.

‚û°Ô∏è Now both threads are waiting forever on each other ‚Üí that‚Äôs a deadlock.


Deadlock Detection / Analysis

Thread dumps (using jstack <pid>) show threads stuck in BLOCKED state waiting for each other‚Äôs lock.

Example in logs:

Thread-1 waiting to lock B, already held by Thread-2
Thread-2 waiting to lock A, already held by Thread-1


to avoid deadlock

1. Always acquire locks in the same order

In the deadlock example, the problem was:

Thread 1 locked A then tried to lock B.

Thread 2 locked B then tried to lock A.
‚û°Ô∏è Opposite order ‚Üí deadlock.

‚úÖ Fix ‚Üí make both methods lock A first, then B.

class DeadlockFixedOrder {
    private final Object lockA = new Object();
    private final Object lockB = new Object();

    public void method1() {
        synchronized (lockA) {              // always lock A first
            System.out.println("Thread 1: Locked A");

            synchronized (lockB) {          // then lock B
                System.out.println("Thread 1: Locked B");
            }
        }
    }

    public void method2() {
        synchronized (lockA) {              // Thread 2 also locks A first
            System.out.println("Thread 2: Locked A");

            synchronized (lockB) {          // then B
                System.out.println("Thread 2: Locked B");
            }
        }
    }
}


üëâ Now both threads wait for A first.

If Thread 1 already has A, Thread 2 must wait.

Once Thread 1 releases A, Thread 2 gets it and then safely locks B.
‚û°Ô∏è No circular waiting ‚Üí no deadlock.

üîπ 2. Use tryLock() with timeout (ReentrantLock)

Here instead of waiting forever for a lock, a thread tries to acquire it for some time. If it can‚Äôt, it backs off and releases already-acquired locks.

import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.TimeUnit;

class DeadlockAvoidTryLock {
    private final ReentrantLock lockA = new ReentrantLock();
    private final ReentrantLock lockB = new ReentrantLock();

    public void method1() throws InterruptedException {
        if (lockA.tryLock(100, TimeUnit.MILLISECONDS)) { // try for A
            try {
                System.out.println("Thread 1: Locked A");

                if (lockB.tryLock(100, TimeUnit.MILLISECONDS)) { // try for B
                    try {
                        System.out.println("Thread 1: Locked B");
                    } finally {
                        lockB.unlock();
                    }
                } else {
                    System.out.println("Thread 1: Couldn‚Äôt lock B, backing off");
                }
            } finally {
                lockA.unlock();
            }
        }
    }

    public void method2() throws InterruptedException {
        if (lockB.tryLock(100, TimeUnit.MILLISECONDS)) { // try for B
            try {
                System.out.println("Thread 2: Locked B");

                if (lockA.tryLock(100, TimeUnit.MILLISECONDS)) { // try for A
                    try {
                        System.out.println("Thread 2: Locked A");
                    } finally {
                        lockA.unlock();
                    }
                } else {
                    System.out.println("Thread 2: Couldn‚Äôt lock A, backing off");
                }
            } finally {
                lockB.unlock();
            }
        }
    }
}


üëâ What happens now?

If Thread 1 locks A but can‚Äôt get B in 100 ms ‚Üí it releases A and retries later.

Same for Thread 2.
‚û°Ô∏è Deadlock is avoided bec
1. Always acquire locks in the same order

In the deadlock example, the problem was:

Thread 1 locked A then tried to lock B.

Thread 2 locked B then tried to lock A.
‚û°Ô∏è Opposite order ‚Üí deadlock.

‚úÖ Fix ‚Üí make both methods lock A first, then B.

class DeadlockFixedOrder {
    private final Object lockA = new Object();
    private final Object lockB = new Object();

    public void method1() {
        synchronized (lockA) {              // always lock A first
            System.out.println("Thread 1: Locked A");

            synchronized (lockB) {          // then lock B
                System.out.println("Thread 1: Locked B");
            }
        }
    }

    public void method2() {
        synchronized (lockA) {              // Thread 2 also locks A first
            System.out.println("Thread 2: Locked A");

            synchronized (lockB) {          // then B
                System.out.println("Thread 2: Locked B");
            }
        }
    }
}


üëâ Now both threads wait for A first.

If Thread 1 already has A, Thread 2 must wait.

Once Thread 1 releases A, Thread 2 gets it and then safely locks B.
‚û°Ô∏è No circular waiting ‚Üí no deadlock.

üîπ 2. Use tryLock() with timeout (ReentrantLock)

Here instead of waiting forever for a lock, a thread tries to acquire it for some time. If it can‚Äôt, it backs off and releases already-acquired locks.

import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.TimeUnit;

class DeadlockAvoidTryLock {
    private final ReentrantLock lockA = new ReentrantLock();
    private final ReentrantLock lockB = new ReentrantLock();

    public void method1() throws InterruptedException {
        if (lockA.tryLock(100, TimeUnit.MILLISECONDS)) { // try for A
            try {
                System.out.println("Thread 1: Locked A");

                if (lockB.tryLock(100, TimeUnit.MILLISECONDS)) { // try for B
                    try {
                        System.out.println("Thread 1: Locked B");
                    } finally {
                        lockB.unlock();
                    }
                } else {
                    System.out.println("Thread 1: Couldn‚Äôt lock B, backing off");
                }
            } finally {
                lockA.unlock();
            }
        }
    }

    public void method2() throws InterruptedException {
        if (lockB.tryLock(100, TimeUnit.MILLISECONDS)) { // try for B
            try {
                System.out.println("Thread 2: Locked B");

                if (lockA.tryLock(100, TimeUnit.MILLISECONDS)) { // try for A
                    try {
                        System.out.println("Thread 2: Locked A");
                    } finally {
                        lockA.unlock();
                    }
                } else {
                    System.out.println("Thread 2: Couldn‚Äôt lock A, backing off");
                }
            } finally {
                lockB.unlock();
            }
        }
    }
}


üëâ What happens now?

If Thread 1 locks A but can‚Äôt get B in 100 ms ‚Üí it releases A and retries later.

Same for Thread 2.
‚û°Ô∏è Deadlock is avoided because threads don‚Äôt wait forever; they detect contention and retry.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is a Thread Pool?

*A Thread Pool is a collection of pre-created worker threads that are reused to execute multiple tasks.
*insteadof creatig a new thread for eac task we sumit all tak tothe theradpool n thradpools assign the thread to the tas
*if some task are left it will be executed by thread which has been release ,so thead once task completed goes to threadpoool nd can be reused

üîπ How to Create a Thread Pool in Java?

Java provides the ExecutorService interface and the utility class Executors to create thread pools.

1. Fixed Thread Pool

A pool with a fixed number of threads.

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(3); // pool of 3 threads

        for (int i = 1; i <= 5; i++) {
            int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId + " executed by " + Thread.currentThread().getName());
            });
        }

        executor.shutdown(); // shutdown pool after tasks finish
    }
}

22. Cached Thread Pool
*Creates new threads as needed,
*but reuses previously created ones if available.


3.3.3. Scheduled Thread Pool
3. Scheduled Thread Pool

Executes tasks after a delay or periodically (like a timer).

import java.util.concurrent.*;

public class ScheduledExample {
    public static void main(String[] args) {
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);

        scheduler.schedule(() -> {
            System.out.println("Task executed after 3 seconds");
        }, 3, TimeUnit.SECONDS);

        scheduler.shutdown();
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is atomic operation? What are atomic classes in Java Concurrency API?
*An atomic operation is an operation that is executed completely or not at all ‚Äî meaning no other thread can see it in an intermediate state.
*It is indivisible ‚Üí can‚Äôt be interrupted by other threads.

Example of atomic operations in Java:
Reading/writing a volatile int or boolean

Reading/writing a reference (like Object obj = ref;)
but ++ is not atomic lets see what happens

Code Reminder
class Counter {
    private int count = 0;

    public void increment() {
        count++;  // Not atomic! (read + add + write)
    }

    public int getCount() {
        return count;
    }
}

üîπ Why count++ is NOT Atomic

The statement:

count++;


is actually 3 steps under the hood:

Read ‚Üí Load the current value of count from memory.

Add ‚Üí Add 1 to the value.

Write ‚Üí Store the new value back to memory.

If two threads do this at the same time, they can interfere.

üîπ Example With Two Threads

Let‚Äôs say:

count = 0 initially.

Thread 1 and Thread 2 both call increment() at the same time.

‚úÖ What we EXPECT:

After both increments ‚Üí count = 2.

‚ùå What can actually happen:

Thread 1 reads count = 0.

Thread 2 reads count = 0 (at the same time, before Thread 1 writes).

Thread 1 adds 1 ‚Üí 0 + 1 = 1.

Thread 1 writes back count = 1.

Thread 2 adds 1 to its copy ‚Üí 0 + 1 = 1.

Thread 2 writes back count = 1.

üëâ Final result = 1 instead of 2 (update lost).

This is called the Lost Update Problem.

üîπ Visual Timeline
Initial count = 0

Thread 1: Read (0)
Thread 2: Read (0)

Thread 1: Add (0+1=1)
Thread 1: Write (count=1)

Thread 2: Add (0+1=1)
Thread 2: Write (count=1)   <-- Overwrites Thread 1‚Äôs update


üëâ End result = 1 (wrong).
üëâ Expected result = 2.

to solve this problem 
o solve this, Java provides atomic classes that use Compare-And-Swap (CAS) under the hood (hardware support, very fast, lock-free).
AtomicInteger

Methods:

incrementAndGet()

getAndIncrement()

addAndGet(int delta)

AtomicInteger count = new AtomicInteger(0);
count.incrementAndGet(); // atomical
class AtomicCounter {
    private AtomicInteger count = new AtomicInteger(0);

    public void increment() {
        count.incrementAndGet(); // atomic, thread-safe
    }

    public int getCount() {
        return count.get();
    }
}

public class TestAtomic {
    public static void main(String[] args) throws InterruptedException {
        AtomicCounter counter = new AtomicCounter();

        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);

        t1.start(); t2.start();
        t1.join(); t2.join();

        System.out.println("Final Count: " + counter.getCount()); // ‚úÖ 2000 always
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is Executors Framework?
*The Executors Framework (introduced in Java 5, java.util.concurrent) is a high-level concurrency API that makes it easier to work with threads.
*Instead of manually creating and managing threads with new Thread(...), you use an Executor (a thread pool) to run tasks.

Why Executors Framework?
Before Executors:
*You create threads manually.
*No easy way to reuse threads.
*No control over scheduling, queuing, etc.


Executors Framework Solution
1.Provides thread pooling (reuse threads instead of creating new ones) and queying mens more task will be stored in quyeue and once thread is freee it will pcik task from the queue

Lets understand by example:
*What happens without Executors?

If you create threads manually:

for (int i = 0; i < 100; i++) {
    new Thread(() -> {
        // some task
    }).start();

This will create 100 threads at once.

Threads are expensive (memory, context switching).

You don‚Äôt have control over how many run at the same time.

If too many threads run, system may crash or slow down.


*What Executors do (Control concurrency)?
Executors manage how many threads can run at the same time and what happens when there are more tasks than threads available.

Example with Fixed Thread Pool:
import java.util.concurrent.*;

public class ExecutorExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(3); // pool size = 3

        for (int i = 1; i <= 10; i++) {
            int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId + " executed by " + Thread.currentThread().getName());
                try { Thread.sleep(1000); } catch (InterruptedException ignored) {}
            });
        }

        executor.shutdown();
    }
}
What happens here?

newFixedThreadPool(3) ‚Üí only 3 threads exist.

We submit 10 tasks.

First 3 tasks start immediately (1 per thread).

The remaining 7 tasks are put into a queue (waiting list).

As soon as a thread finishes, it picks the next task from the queue.

So instead of running 10 tasks at once, Executor controls concurrency:

‚úÖ Pool size ‚Üí limits how many threads run simultaneously.

‚úÖ Queueing ‚Üí stores extra tasks safely until a thread is free.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
In Java, we have normal collections like:

ArrayList, HashMap, HashSet, LinkedList, etc.

But these are not thread-safe.
üëâ If multiple threads read/write at the same time, we can get:

ConcurrentModificationException

Data corruption (lost updates, inconsistent state).


Solution1:
1.. First Attempt ‚Üí Synchronized Collections

Java provides Collections.synchronizedList(), etc. Example:
These are thread-safe, but synchronization is done with a single lock.

Problem ‚Üí low performance under high concurrency (all threads must wait for the lock).


Solution2.:Java Concurrency API (java.util.concurrent) provides specialized collection classes designed for multi-threaded environments.

They use:

Fine-grained locking (locks only part of the structure).

Or lock-free algorithms (like Compare-And-Swap).
üëâ This makes them safe + high-performance in concurrency.



4. Common Concurrent Collection Classes
‚úÖ (a) ConcurrentHashMap

Thread-safe version of HashMap.

Uses bucket-level locking (segments) ‚Üí multiple threads can update different buckets in parallel.

Much faster than Collections.synchronizedMap().

ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
map.put("A", 1);
map.put("B", 2);
System.out.println(map.get("A"));

‚úÖ (b) CopyOnWriteArrayList

Thread-safe version of ArrayList.

On every write (add/remove) ‚Üí it makes a new copy of the array.

Reads are very fast (no locking).

Best for read-mostly, write-rarely scenarios (like caching).

CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
list.add("one");
list.add("two");
System.out.println(list);

‚úÖ (c) CopyOnWriteArraySet

Same as above but for Set.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What are some of the improvements in Concurrency API in Java 8?

1/What was wrong with plain Future (before Java 8)?
*Future could only represent a result of an async computation.

To get the result you had to call get(), which blocks the thread.

No way to chain tasks (do something after result is ready).

No way to combine multiple async tasks easily.

No exception handling built-in.
ExecutorService executor = Executors.newFixedThreadPool(1);
Future<String> future = executor.submit(() -> "Hello");

// This blocks until result is available
String result = future.get();  
System.out.println(result + " World");
executor.shutdown();

It‚Äôs final class (java.util.concurrent.CompletableFuture)

Implements both:	

Future<T> ‚Üí represents a result

CompletionStage<T> ‚Üí allows chaining async stages

Provides non-blocking APIs with callbacks instead of blocking.

Java 8: CompletableFuture

It‚Äôs final class (java.util.concurrent.CompletableFuture)

Implements both:

Future<T> ‚Üí represents a result

CompletionStage<T> ‚Üí allows chaining async stages

Provides non-blocking APIs with callbacks instead of blocking.

üîπ Example with CompletableFuture
import java.util.concurrent.CompletableFuture;

public class Example {
    public static void main(String[] args) {
        CompletableFuture.supplyAsync(() -> "Hello")  // async task returns "Hello"
            .thenApply(s -> s + " World")             // transform result
            .thenAccept(System.out::println);         // consume result
    }
}


‚úÖ Output (non-blocking, printed by async thread):

Hello World





2.2. Parallel Streams (Java 8)

Normal streams run sequentially.

.parallelStream() or .parallel() executes the stream in parallel using the Fork/Join framework internally.

You don‚Äôt need to manually create threads or manage synchronization.

‚úÖ Example: Sequential vs Parallel

import java.util.*;

public class ParallelStreamExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        // Sequential sum
        int sequentialSum = numbers.stream()
                                   .mapToInt(Integer::intValue)
                                   .sum();

        // Parallel sum (runs tasks in multiple threads)
        int parallelSum = numbers.parallelStream()
                                 .mapToInt(Integer::intValue)
                                 .sum();

        System.out.println("Sequential: " + sequentialSum);
        System.out.println("Parallel: " + parallelSum);
    }
}


üëâ Internally, .parallelStream() uses a common ForkJoinPool to split and process data in chunks.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is Exception in Java?What are the Exception Handling Keywords in Java?  

An exception is an event that disrupts the normal flow of a program.

Happens when something unexpected occurs (e.g., divide by zero, file not found, null reference).

Java represents these events as objects of type Throwable (mainly Exception and Error).

Exception Handling Keywords in Java
*Java provides 5 main keywords:

try ‚Üí defines a block of code to monitor for exceptions.

catch ‚Üí handles the exception thrown in try.

finally ‚Üí block that always executes (cleanup code).

throw ‚Üí used to explicitly throw an exception.

throws ‚Üí declares exceptions a method can throw.

public class ExceptionExample {
    public static void main(String[] args) {
        try {
            int a = 10 / 0;   // ArithmeticException
        } catch (ArithmeticException e) {
            System.out.println("Error: " + e.getMessage());
        } finally {
            System.out.println("This block always executes.");
        }
    }

    // Example of throw & throws
    public void checkAge(int age) throws Exception {
        if (age < 18) {
            throw new Exception("Age must be 18 or above.");
        }
    }
}





‚úÖ Key Points:

Throwable

It is a class, not an interface.

Base class for all exceptions and errors.

Only objects that are instances of Throwable (or subclasses) can be thrown with throw.

Error

Subclass of Throwable.

Represents serious problems (e.g., OutOfMemoryError).

Not meant to be caught in normal code.

Exception

Subclass of Throwable.

Represents conditions that a program might want to catch and handle.

Divided into:

Checked Exceptions (must handle or declare)

Unchecked Exceptions (Runtime exceptions)

public class HierarchyDemo {
    public static void main(String[] args) {
        Throwable t = new Exception("This is throwable"); // ‚úÖ valid
        Exception e = new RuntimeException("Unchecked exception"); 
        Error err = new OutOfMemoryError("Serious error");

        // throw t;  // compiler allows only if method declares `throws Throwable`
    }
}


1.1. Checked Exceptions

Checked at compile-time.

Must be either handled (try-catch) or declared with throws.

Usually external issues (I/O, DB, network).
Examples:

IOException

SQLException

ClassNotFoundException
import java.io.*;

public class CheckedExample {
    public static void main(String[] args) {
        try {
            FileReader fr = new FileReader("file.txt"); // may throw IOException
        } catch (IOException e) {
            System.out.println("File not found!");
        }
    }
}




2.22. Unchecked Exceptions

Also called Runtime Exceptions.

Occur at runtime, compiler does NOT force handling.

Usually programming mistakes (logic, nulls, array bounds).
Examples:

NullPointerException

ArrayIndexOutOfBoundsException

ArithmeticException

public class UncheckedExample {
    public static void main(String[] args) {
        int a = 10 / 0; // ArithmeticException at runtime
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
. What are important methods of Java Exception Class?

Method	Description	Example
1.getMessage()	Returns the detail message string.	e.getMessage() ‚Üí "Divide by zero"
2.toString()	Returns a short description (className: message).	e.toString() ‚Üí "java.lang.ArithmeticException: / by zero"
3.What is a Stack Trace?

A stack trace is a list of method calls that the program was executing when an exception occurred.

It shows:

Type of exception

Error message

Sequence of method calls (call stack) from where the exception originated

public class StackTraceDemo {
    public static void main(String[] args) {
        try {
            divide(10, 0);
        } catch (ArithmeticException e) {
            e.printStackTrace(); // prints the stack trace
        }
    }

    static int divide(int a, int b) {
        return a / b; // will throw ArithmeticException
    }
}
java.lang.ArithmeticException: / by zero
    at StackTraceDemo.divide(StackTraceDemo.java:14)
    at StackTraceDemo.main(StackTraceDemo.java:6)

How to Read It

java.lang.ArithmeticException: / by zero ‚Üí Exception type + message.

at StackTraceDemo.divide(StackTraceDemo.java:14) ‚Üí Error occurred in divide() method at line 14.

at StackTraceDemo.main(StackTraceDemo.java:6) ‚Üí That method was called by main() at line 6.

üëâ This helps developers trace back to the exact cause of failure.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Aspect	throw	throws
Usage	Used to actually throw an exception object.	Used in a method declaration to declare that the method may throw exceptions.
Position	Inside a method/block.	In method signature (after parameters).
Followed by	A single exception object (instance).	One or more exception class types.
Execution	Transfers control immediately to the nearest matching catch block.	Just informs the caller that they must handle the exception.


import java.io.*;

public class Example {
    // declares exception
    void readFile() throws IOException {
        FileReader fr = new FileReader("file.txt"); // may throw IOException
    }

    void testThrow() {
        throw new ArithmeticException("Demo Exception"); // actually throws
    }

    public static void main(String[] args) {
        Example ex = new Example();

        try {
            ex.readFile();   // must handle IOException
        } catch (IOException e) {
            System.out.println("Handled: " + e);
        }

        ex.testThrow();  // will throw ArithmeticException
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Writing a Custom Exception in Java

Decide whether it should be:

Checked Exception ‚Üí extend Exception

Unchecked Exception ‚Üí extend RuntimeException

Create a class with constructors (usually one default + one with a message).

‚úÖ Example 1: Custom Checked Exception
// Custom checked exception
class InvalidAgeException extends Exception {
    public InvalidAgeException(String message) {
        super(message);
    }
}

public class TestCustomException {
    static void validateAge(int age) throws InvalidAgeException {
        if (age < 18) {
            throw new InvalidAgeException("Age must be 18 or above.");
        }
        System.out.println("Valid age: " + age);
    }

    public static void main(String[] args) {
        try {
            validateAge(15);
        } catch (InvalidAgeException e) {
            e.printStackTrace();
        }
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

What is OutOfMemoryError in Java? how do you handle and prevent out of memory issues 

What is OutOfMemoryError in Java?

OutOfMemoryError is a subclass of Error (under Throwable).

It occurs when the JVM cannot allocate more memory for objects.

It‚Äôs not an Exception, but an Error ‚Üí usually indicates a serious problem.

üëâ Example:

import java.util.*;

public class OOMExample {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        while (true) {
            list.add("OOM test " + System.nanoTime()); // keeps adding
        }
    }
}


üìå Eventually, this will throw:

Exception in thread "main" java.lang.OutOfMemoryError: Java heap space

üîπ Common Types of OutOfMemoryError

Java heap space ‚Äì Not enough heap memory for new objects.

GC overhead limit exceeded ‚Äì Too much time spent in Garbage Collection.

Metaspace (Java 8+) / PermGen (Java 7-) ‚Äì Too many classes loaded.

Direct buffer memory ‚Äì If using NIO/direct buffers.

Native memory exhausted ‚Äì System memory shortage.




How to Prevent OutOfMemory Issues

‚úÖ Code-level practices:

Avoid memory leaks (e.g., unclosed resources, static collections holding references).

Use weak references (WeakHashMap) for cache-like structures.

Clear unused objects manually (list.clear(), nullify when appropriate).

Use streams/iterators instead of loading huge data sets in memory.

Profile memory with tools like VisualVM, JConsole, YourKit.


Real-world Billing Example of OutOfMemoryError

üëâ Imagine you are building a Billing UI/API:

Requirement: Show all invoices for a customer in a single API call.

Suppose a customer has 2 million invoices.

If your code tries to load all invoices into memory (ArrayList) at once ‚Üí JVM heap will blow up ‚Üí OutOfMemoryError: Java heap space.

‚ùå Bad Implementation (causing OOM)
public List<Invoice> getInvoices(Long customerId) {
    // Query loads ALL invoices at once
    return invoiceRepository.findAllByCustomerId(customerId);  
}


If DB returns 2 million rows, Java heap may run out.

UI/API fails with OOM.

‚úÖ Optimized Solution
1. Pagination
public Page<Invoice> getInvoices(Long customerId, int page, int size) {
    return invoiceRepository.findByCustomerId(customerId, PageRequest.of(page, size));
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
. How would you go about minimising memory leaks in your Java/J2EE application?
1.‚úÖ Common Practices to Minimize Memory Leaks

Close Resources Properly (DB, Files, Streams, Connections)

Use try-with-resources (Java 7+) so resources auto-close.

try (Connection conn = dataSource.getConnection();
     PreparedStatement ps = conn.prepareStatement("SELECT * FROM invoices")) {
    // use connection
} catch (SQLException e) {
    e.printStackTrace();
} 



2.Avoid Static References Holding Big Objects
Don‚Äôt store large collections (e.g., all invoices) in static variables.

Example: A static Map<Long, Invoice> can hold millions of invoices forever ‚Üí leak.


3.Use Weak References for Caches

Instead of strong references, use WeakHashMap or libraries like Caffeine/Ehcache.

Map<InvoiceKey, Invoice> cache = new WeakHashMap<>();


4.Watch Out for ThreadLocal Misuse

Always remove ThreadLocal values (threadLocal.remove()) after use.

Otherwise, long-lived threads (e.g., in app servers) keep holding data.

Proper Session Management (in J2EE/Web)

Don‚Äôt put huge objects (like invoice PDFs) in HttpSession.

Use session timeout and clean up on logout.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
omponent	Full Form	Purpose	Contains
JVM	Java Virtual Machine	Executes Java bytecode on a platform (runtime engine).	Just the runtime engine ‚Äî loads, verifies, and executes .class files.
JRE	Java Runtime Environment	Provides JVM + standard libraries to run Java programs.	JVM + core Java libraries (like java.lang, java.util).
JDK	Java Development Kit	Development + runtime environment ‚Äî for compiling and running Java apps.	JRE + development tools (javac, javadoc, jar, debugger).
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Can an interface implement another interface?

‚ùå No.

In Java, interfaces cannot implement another interface.

‚ÄúImplement‚Äù is reserved for classes that provide concrete method bodies.

üîπ Can an interface extend another interface?

‚úÖ Yes.

Interfaces can extend one or more interfaces using extends.

The extending interface inherits abstract methods of the parent interface.

A class that implements the child interface must provide concrete implementations for all inherited methods.

üîπ Example
interface Readable {
    void read();
}

interface Writable extends Readable { // extends, not implements
    void write();
}

// Class implementing child interface
class File implements Writable {
    public void read() {
        System.out.println("Reading file");
    }
    public void write() {
        System.out.println("Writing file");
    }
}

public class Main {
    public static void main(String[] args) {
        File f = new File();
        f.read();
        f.write();
    }
}


Output:

Reading file
Writing file
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Why Wrapper Classes?

Convert primitives to objects ‚Üí needed for collections (ArrayList<Integer>).

Utility methods ‚Üí parsing strings, converting types (Integer.parseInt()).

Autoboxing / Unboxing ‚Üí automatic conversion between primitive and wrapper.

üîπ Example
import java.util.*;

public class WrapperExample {
    public static void main(String[] args) {
        // Primitive
        int num = 10;

        // Convert primitive to wrapper (Autoboxing)
        Integer numObj = num;

        // Convert wrapper to primitive (Unboxing)
        int n = numObj;

        // Using wrapper methods
        String str = "123";
        int parsed = Integer.parseInt(str); // converts String to int

        // Using wrapper in collections
        List<Integer> list = new ArrayList<>();
        list.add(num); // autoboxed to Integer
        list.add(456);

        System.out.println("numObj: " + numObj);
        System.out.println("parsed: " + parsed);
        System.out.println("List: " + list);
    }
}


Output:

numObj: 10
parsed: 123
List: [10, 456]

üîπ Key Points

Wrapper classes wrap primitives in objects.

Support autoboxing/unboxing in Java 5+.

Useful in collections, utility methods, and generic APIs.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is Enum in Java?
*enum (short for enumeration) is a special Java type used to define a collection of constant values (fixed set of constants).
*Enums are more powerful than constants (final static) because they are type-safe.
*enum Day {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}

public class TestEnum {
    public static void main(String[] args) {
        Day today = Day.MONDAY;
        
        System.out.println(today);         // MONDAY
        System.out.println(today.ordinal()); // 0 (index of MONDAY)
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is Java Reflection API? Why it‚Äôs so important to have?
*he Reflection API in Java is a feature that allows a program to inspect and manipulate the runtime behavior of classes, methods, fields, and constructors ‚Äî even if you don‚Äôt know them at compile time.

It‚Äôs part of the package:

import java.lang.reflect.Method;
class Student
{
    private String name="neha";
    void showName()
    {
        System.out.println(name);
    }
}
class Main {
    public static void main(String[] args) {
        System.out.println("Try programiz.pro");
        try{
        Class<?>classz=Class.forName("Student");
         Object obj=classz.getDeclaredConstructor().newInstance();
        Method method=classz.getDeclaredMethod("showName");
        method.invoke(obj);
        }catch(Exception e)
        {
            System.out.println(e);
        }
       
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Java Annotations
1. Definition

Annotations in Java are metadata (data about data) that provide additional information to the compiler, JVM, or frameworks.

They do not affect program logic directly.

Instead, they are used by compilers, tools, and frameworks to generate code, configure behavior, or provide instructions.

They were introduced in Java 5.

2. Basic Example
class Student {
    @Override
    public String toString() {
        return "Student class";
    }
}


Here:

@Override tells the compiler that toString() is overriding a parent method.

If you mistype the method name, the compiler gives an error. ‚úÖ
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is the benefit of Composition over Inheritance?
Composition vs Inheritance
1. Inheritance

Mechanism where one class inherits properties/behaviors from another using extends.

IS-A relationship.

Example:

class Engine {
    void start() { System.out.println("Engine starts"); }
}

class Car extends Engine {
    void drive() { System.out.println("Car drives"); }
}


Here, Car IS-A Engine ‚Üí but that‚Äôs not semantically true (a car has an engine, it‚Äôs not an engine).

2. Composition

Instead of inheriting, a class contains an instance of another class.

HAS-A relationship.

Example:

class Engine {
    void start() { System.out.println("Engine starts"); }
}

class Car {
    private Engine engine = new Engine();

    void drive() {
        engine.start();
        System.out.println("Car drives");
    }
}


Here, Car HAS-A Engine ‚Üí which makes more sense.

Benefits of Composition over Inheritance

Better Modeling (HAS-A vs IS-A)

1.Inheritance can create wrong relationships.

Composition models reality more naturally.
Example: Car has an Engine ‚úÖ vs Car is an Engine ‚ùå.

2.Loose Coupling

With composition, classes depend on interfaces or objects, not tightly bound hierarchies.

You can swap dependencies easily (e.g., different Engine types: DieselEngine, ElectricEngine).

class Car {
    private Engine engine;
    Car(Engine engine) { this.engine = engine; }
    void drive() { engine.start(); }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
How to sort a collection of custom Objects in Java?
Note:Collections.sort()//internally uses the uses compareTo() when class implement the Comparable interface

1.Using Comparable (Natural Ordering)
*mplement the Comparable<T> interface in your class.
*Override the compareTo() method.
import java.util.*;

class Student implements Comparable<Student> {
    private int id;
    private String name;

    Student(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public String getName() { return name; }
    public int getId() { return id; }

    // Natural order: by id
    @Override
    public int compareTo(Student other) {
        return this.id - other.id;  // ascending order
    }

    @Override
    public String toString() {
        return id + " - " + name;
    }
}

public class Main {
    public static void main(String[] args) {
        List<Student> list = new ArrayList<>();
        list.add(new Student(3, "Neha"));
        list.add(new Student(1, "Amit"));
        list.add(new Student(2, "Ravi"));

        Collections.sort(list); // uses compareTo()
        System.out.println(list);
    }
}



2.2. Using Comparator (Custom Sorting)
*
import java.util.*;

class Student {
    private int id;
    private String name;

    Student(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public String getName() { return name; }
    public int getId() { return id; }

    @Override
    public String toString() {
        return id + " - " + name;
    }
}

public class Main {
    public static void main(String[] args) {
        List<Student> list = new ArrayList<>();
        list.add(new Student(3, "Neha"));
        list.add(new Student(1, "Amit"));
        list.add(new Student(2, "Ravi"));

        // Sort by name
        Collections.sort(list, new Comparator<Student>() {
            @Override
            public int compare(Student s1, Student s2) {
                return s1.getName().compareTo(s2.getName());
            }
        });

        System.out.println(list);
    }
}



3.3. Using Java 8+ Lambdas

Much cleaner way with Comparator.comparing().

list.sort(Comparator.comparing(Student::getName)); // sort by name
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is immutable in java & How to write immutable class?
*Immutable object = an object whose state (fields/values) cannot be changed once it is created.

Example:

String in Java is immutable. Once created, you cannot modify it. Any operation like concat or replace creates a new object.

public class StringImmutableExample {
    public static void main(String[] args) {
        String str = "Hello";

        // Try to change it
        str.concat(" World");

        System.out.println(str); // Output: Hello (unchanged!)

        // If we assign the result to str
        str = str.concat(" World");
        System.out.println(str); // Output: Hello World (new String object)
    }
}

Why Immutable is Useful?
Thread safety ‚Üí No synchronization needed since state never changes.

Caching & performance ‚Üí Safe to cache immutable objects.

Security ‚Üí Prevents unintended modifications (e.g., keys in HashMap).

How to Create an Immutable Class in Java?
*Declare the class as final ‚Üí prevents subclassing.
*Make all fields private final.
*Don‚Äôt provide setters.

Initialize all fields via constructor.
*or mutable fields (like arrays, collections, Date), return deep copies instead of direct references.

import java.util.*;

final class Employee {
    private final String name;
    private final int age;
    private final List<String> skills; // mutable field

    public Employee(String name, int age, List<String> skills) {
        this.name = name;
        this.age = age;
        // Deep copy for mutable objects
        this.skills = new ArrayList<>(skills);
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    // Return a copy to prevent modification of internal list
    public List<String> getSkills() {
        return new ArrayList<>(skills);
    }
}

public class Main {
    public static void main(String[] args) {
        List<String> skills = new ArrayList<>();
        skills.add("Java");
        Employee emp = new Employee("Neha", 25, skills);

        System.out.println(emp.getSkills()); // [Java]

        // Try modifying external list
        skills.add("React");
        System.out.println(emp.getSkills()); // Still [Java] ‚úÖ Immutable

        // Try modifying returned list
        emp.getSkills().add("Spring");
        System.out.println(emp.getSkills()); // Still [Java] ‚úÖ Immutable
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is the difference between comparable and comparator interfaces 
1.1. Comparable Interface
*Package: java.lang
*Used for natural ordering of objects.
*A class implements Comparable to define its own default sorting logic.
*Contains one method:

class Student implements Comparable<Student> {
    int id;
    String name;

    Student(int id, String name) {
        this.id = id;
        this.name = name;
    }

    // Natural ordering by id
    @Override
    public int compareTo(Student other) {
        return this.id - other.id;
    }
}

public class ComparableExample {
    public static void main(String[] args) {
        List<Student> list = new ArrayList<>();
        list.add(new Student(2, "Neha"));
        list.add(new Student(1, "Ravi"));

        Collections.sort(list); // uses compareTo

        for (Student s : list) {
            System.out.println(s.id + " " + s.name);
        }
    }
}



2.Comparator
Package: java.util
*Used for customized/multiple sorting logics (not fixed like Comparable).
*You create a separate class (or lambda) that implements Comparator.
*Contains one method:
*class Student {
    int id;
    String name;

    Student(int id, String name) {
        this.id = id;
        this.name = name;
    }
}

public class ComparatorExample {
    public static void main(String[] args) {
        List<Student> list = new ArrayList<>();
        list.add(new Student(2, "Neha"));
        list.add(new Student(1, "Ravi"));

        // Sort by name using Comparator
        Collections.sort(list, new Comparator<Student>() {
            @Override
            public int compare(Student s1, Student s2) {
                return s1.name.compareTo(s2.name);
            }
        });

        for (Student s : list) {
            System.out.println(s.id + " " + s.name);
        }
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
‚úÖ Reasons:
1. Security

Strings are widely used for sensitive operations like:

Database connections ("jdbc:mysql://...")

File paths

Network URLs

Class loading

If String were mutable:

String password = "Admin123";
// Malicious code could change the value:
password.setValue("Hacked!");


That would compromise system security.

Immutability ensures once created, String values cannot be changed.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What are Collection related features in Java 8?
*In Java 8, collections got a big upgrade with the introduction of Streams API, lambda expressions, and new default methods in the Collection interfaces.
1.1. forEach() method
List<String> names = Arrays.asList("A", "B", "C");

// Java 7 style
for (String name : names) {
    System.out.println(name);
}

// Java 8 style
names.forEach(n -> System.out.println(n));


2.2
2. removeIf() method

Added in Collection interface.

Removes elements that match a given predicate.

List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
numbers.removeIf(n -> n % 2 == 0); // removes even numbers
System.out.println(numbers); // [1, 3, 5]




3.6. Streams API (Biggest Feature)

Collections can be converted into Streams for functional-style operations like map, filter, reduce.

List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// Stream with filter + map + collect
List<Integer> squares = numbers.stream()
                               .filter(n -> n % 2 != 0)   // keep odd
                               .map(n -> n * n)           // square them
                               .toList();

System.out.println(squares); // [1, 9, 25]


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is the benefit of Generics in Collections Framework?
*In Collections Framework, they let you specify the type of objects a collection can hold.
*List<String> list = new ArrayList<>(); 
list.add("Hello");
// list.add(123); // ‚ùå Compile-time error

Benefits of Generics in Collections Framework
*1. Type Safety

Ensures that only objects of a specified type are stored in a collection.

Prevents accidental insertion of the wrong type.

List<Integer> numbers = new ArrayList<>();
numbers.add(10);
// numbers.add("abc"); // Compile-time error ‚úÖ


2.2. Elimination of Type Casting

Before Java 5 (no generics), we had to cast objects when retrieving from collections.

// Without generics
List list = new ArrayList();
list.add("Hello");
String s = (String) list.get(0); // manual cast needed

// With generics
List<String> list2 = new ArrayList<>();
list2.add("Hello");
String s2 = list2.get(0); // No casting ‚úÖ



3.33. Compile-time Checking

Errors are caught at compile time, not at runtime.

Reduces ClassCastException at runtime.


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is Java Collections Framework? List out some benefits of Collections framework? 
     And What are the basic interfaces of Java Collections Framework?

*It provides interfaces, classes, and algorithms to store, retrieve, and process data efficiently.

Benefits of Collections Framework

Consistent API ‚Äì Common interfaces (List, Set, Map, etc.) make it easy to learn and use.

Reusability ‚Äì Ready-made classes (ArrayList, HashSet, HashMap, etc.) can be reused.

Type Safety (with Generics) ‚Äì Prevents runtime errors and avoids casting.


1.1. List Interface

Ordered collection (sequence).

Allows duplicates.

Index-based access.

Implementations: ArrayList, LinkedList, Vector, Stack.

List<String> list = new ArrayList<>();


2.22. Set Interface

No duplicates allowed.

Unordered collection (some implementations maintain order).

Implementations: HashSet, LinkedHashSet, TreeSet.

3.33. Queue Interface

Represents a FIFO (First In, First Out) structure.

Implementations: PriorityQueue, LinkedList, ArrayDeque.

Queue<String> queue = new LinkedList<>();
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is difference between Iterator and ListIterator?
1.Iterator
*Used to traverse elements of a collection sequentially
*Applicable to all collection classes
*Cannot modify the list except by using remove() method.


2.ListIterator?
Specialized Iterator ‚Üí works only for List implementations (ArrayList, LinkedList, Vector).

Can traverse both directions (forward + backward).

Provides extra methods to add, replace, or modify elements during iteration.

import java.util.*;

public class IteratorVsListIterator {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");

        // ‚úÖ Iterator (forward only)
        Iterator<String> itr = list.iterator();
        System.out.println("Using Iterator:");
        while (itr.hasNext()) {
            System.out.println(itr.next());
        }

        // ‚úÖ ListIterator (forward + backward)
        ListIterator<String> listItr = list.listIterator();
        System.out.println("\nUsing ListIterator Forward:");
        while (listItr.hasNext()) {
            System.out.println(listItr.next());
        }

        System.out.println("\nUsing ListIterator Backward:");
        while (listItr.hasPrevious()) {
            System.out.println(listItr.previous());
        }

        // Modify element using ListIterator
        listItr = list.listIterator();
        if (listItr.hasNext()) {
            listItr.next();  // Move to "A"
            listItr.set("X"); // Replace "A" with "X"
        }
        System.out.println("\nModified List: " + list);
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Feature	Fail-Fast	Fail-Safe
Definition	Iterator that throws ConcurrentModificationException if the collection is modified while iterating (except via iterator‚Äôs own methods).	Iterator that doesn‚Äôt throw exception even if collection is modified during iteration (works on a copy).
Examples	ArrayList, HashMap, HashSet iterators.	CopyOnWriteArrayList, ConcurrentHashMap iterators.
Working	Works directly on the collection‚Äôs structure. Any structural modification (add/remove) outside iterator ‚Üí exception.	Works on a cloned copy of the collection. Modifications don‚Äôt affect current iteration.
Exception	Throws ConcurrentModificationException.	No exception.
Performance	Faster (no extra memory used).	Slower (because of cloning / concurrent safety).
Use Case	Non-concurrent applications.	Multi-threaded / concurrent applications.

import java.util.*;

public class FailFastExample {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");

        Iterator<String> itr = list.iterator();
        while (itr.hasNext()) {
            System.out.println(itr.next());
            // Modifying list during iteration
            list.add("D");  // ‚ùå Causes ConcurrentModificationException
        }
    }
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
üîπ Ways to Avoid ConcurrentModificationException in Java

When you iterate a collection (like ArrayList, HashMap), you cannot modify it structurally (add/remove) outside the iterator.
If you do ‚Üí ConcurrentModificationException occurs.

Here‚Äôs how to avoid it:

‚úÖ 1. Use Iterator‚Äôs own methods (remove())

Instead of modifying the collection directly, use Iterator.remove().

import java.util.*;

public class AvoidCME1 {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");

        Iterator<String> itr = list.iterator();
        while (itr.hasNext()) {
            String val = itr.next();
            if (val.equals("B")) {
                itr.remove(); // ‚úÖ Safe removal
            }
        }
        System.out.println(list); // [A, C]
    }
}

‚úÖ 2. Use CopyOnWriteArrayList (Fail-Safe Iterator)

This class allows modifications while iterating.

import java.util.concurrent.CopyOnWriteArrayList;

public class AvoidCME2 {
    public static void main(String[] args) {
        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");

        for (String s : list) {
            if (s.equals("B")) {
                list.remove("B");  // ‚úÖ No exception
            }
        }
        System.out.println(list); // [A, C]
    }
}

‚úÖ 3. Use ConcurrentHashMap (for Maps)

When working with maps in multi-threaded environments, use ConcurrentHashMap.

import java.util.concurrent.ConcurrentHashMap;

public class AvoidCME3 {
    public static void main(String[] args) {
        ConcurrentHashMap<Integer, String> map = new ConcurrentHashMap<>();
        map.put(1, "A");
        map.put(2, "B");

        for (Integer key : map.keySet()) {
            if (key == 1) {
                map.put(3, "C"); // ‚úÖ No exception
            }
        }
        System.out.println(map); // {1=A, 2=B, 3=C}
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
How HashMap works in Java?
*HashMap<K,V> is a hash table‚Äìbased implementation of Map.
*It stores key-value pairs and allows O(1) average-time complexity for insertion, deletion, and lookup.


1.1. Data Structure of HashMap
*Internally, HashMap uses:

*Array of buckets (Node<K,V>[])
*Internally, HashMap uses:

Array of buckets (Node<K,V>[])

Each bucket is a linked list (or balanced tree since Java 8 when collisions are high).

2. How it Works (Step by Step)
üîπ (a) Put Operation
map.put("India", 91);


Compute hash code of the key:

int hash = hash("India");


Find the bucket index:

index = hash % capacity; // capacity = array size (default 16)


Insert the entry:

If no entry in that bucket ‚Üí store directly.

If bucket already has nodes ‚Üí collision happens:

Compare keys using equals()

If key already exists ‚Üí update value.

If different key ‚Üí add new node to linked list/tree.

üîπ (b) Get Operation
map.get("India");


Compute hash ‚Üí find bucket index.

Search in bucket:

If only one node ‚Üí return value.

If multiple nodes (collision) ‚Üí traverse linked list / tree and compare using equals().

3. Collision Handling

Collisions occur when two keys map to the same index.
HashMap handles collisions using Chaining:

Before Java 8 ‚Üí Linked List

Java 8+ ‚Üí If a bucket has > 8 nodes, it converts to a Balanced Tree (Red-Black Tree) ‚Üí improves worst-case lookup to O(log n) instead of O(n).
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is difference between Array and ArrayList? When will you use Array over ArrayList?
1.Array
*Can store both primitives and objects.
*Fixed size ‚Üí once created, cannot grow or shrink.
*Access is fast (constant time O(1)).
*


2.ArrayList

Dynamic size ‚Üí automatically grows or shrinks when elements are added/removed.

Stores only objects (e.g., Integer, not int).

Part of Collections Framework.

More flexible with many utility methods: add(), remove(), contains(), etc.

ArrayList<Integer> list = new ArrayList<>();
list.add(10);
list.add(20);


Slightly slower than array (because of resizing, boxing/unboxing, and overhead).
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Which collection classes are thread-safe?
1.1. Legacy synchronized classes (from JDK 1.0 / 1.2)

*These are synchronized internally, meaning all their methods are thread-safe:

Vector (like ArrayList, but synchronized)

Stack (extends Vector)

Hashtable (like HashMap, but synchronized)



2.22. Collections.synchronizedXXX() Wrappers
Java provides utility methods in Collections class to make collections thread-safe:

Collections.synchronizedList(new ArrayList<>())

Collections.synchronizedSet(new HashSet<>())

Collections.synchronizedMap(new HashMap<>())

‚ö†Ô∏è These wrappers synchronize every method call, so they are thread-safe but may reduce performance due to blocking.


3.33. java.util.concurrent Package (preferred modern approach)

Introduced in Java 5 for better scalability & concurrency (non-blocking in many cases):

ConcurrentHashMap (better alternative to Hashtable)

CopyOnWriteArrayList (thread-safe alternative to ArrayList)

CopyOnWriteArraySet (thread-safe alternative to HashSet)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
In Java, Concurrent Collection Classes are the special implementations of the Java Collections Framework introduced in java.util.concurrent package (since Java 5).

They are designed for multi-threaded / concurrent environments where multiple threads need to access or modify collections safely and efficiently.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What are the benefits of multi-threaded programming?
1.1. Improved Application Performance (Responsiveness)
A single-threaded program might freeze if one long task is running.

With multiple threads, the app can still respond to the user.
public class ResponsiveApp {
    public static void main(String[] args) {
        // Thread 1 - handles background task
        Thread backgroundTask = new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                System.out.println("Processing file " + i);
                try { Thread.sleep(2000); } catch (InterruptedException e) {}
            }
        });

        backgroundTask.start();

        // Main thread - keeps UI responsive
        System.out.println("You can still click buttons in UI while files are processed!");
    }
}


2.public class CpuUtilization {
    public static void main(String[] args) {
        Runnable task1 = () -> {
            for (int i = 0; i < 5; i++) System.out.println("Task 1 running");
        };
        Runnable task2 = () -> {
            for (int i = 0; i < 5; i++) System.out.println("Task 2 running");
        };

        new Thread(task1).start();
        new Thread(task2).start();
    }
}


3.3. Better Resource Sharing

Threads share the same memory ‚Üí easier communication



4.4Independent tasks can run in parallel.

‚úÖ Example: Image Processing + File Upload

public class IndependentTasks {
    public static void main(String[] args) {
        new Thread(() -> System.out.println("Compressing image...")).start();
        new Thread(() -> System.out.println("Uploading file...")).start();
    }
}


üëâ Both tasks run simultaneously instead of waiting for each other.


5.55. Scalability (Servers Handling Multiple Clients)

A server can spawn a new thread for each client request.

‚úÖ Example: Multi-client Chat Server (simplified)

class ClientHandler extends Thread {
    private int clientId;

    ClientHandler(int clientId) { this.clientId = clientId; }

    public void run() {
        System.out.println("Handling client " + clientId);
    }
}

public class ChatServer {
    public static void main(String[] args) {
        for (int i = 1; i <= 3; i++) {
            new ClientHandler(i).start();
        }
    }
}


üëâ Each client is handled by a separate thread ‚Üí scalable.

6. Asynchronous & Parallel Execution

Tasks can run in the background without blocking the main flow.

‚úÖ Example: File Download + Music Playing

public class AsyncExample {
    public static void main(String[] args) {
        new Thread(() -> {
            System.out.println("Downloading file...");
            try { Thread.sleep(3000); } catch (InterruptedException e) {}
            System.out.println("Download complete!");
        }).start();

        System.out.println("Meanwhile... keep playing music üéµ");
    }
}


üëâ The user enjoys music while the file downloads in the background.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is Hashing Technique mechanism and how it will work internally 
*Hashing is a technique of mapping data (keys) into a fixed-size value (called a hash code) using a hash function.
*This hash code is then used to determine where to store or retrieve the data in a hash-based data structure (like HashMap, HashSet, Hashtable).


How Hashing Works Internally (Java HashMap example)
*Let‚Äôs say we store (key, value) in a HashMap.
1.1. Hash Function

Every key‚Äôs hashCode() method is called ‚Üí produces an integer hash value.
Then Java uses a formula like:

bucketIndex = hashCode(key) & (n - 1);


where n = number of buckets (capacity).
This ensures the key maps to a specific bucket index in the internal array.


2.2. Bucket (Array + LinkedList/Tree)

Internally, HashMap maintains an array of buckets.

Each bucket can store multiple entries (to handle collisions).


3.33. Collision Handling

A collision happens when two keys produce the same bucket index.
HashMap handles collisions using:

Before Java 8: Linked List inside each bucket.

Java 8 onwards:

If many collisions happen, the bucket‚Äôs linked list is converted into a balanced tree (Red-Black Tree) for better performance (O(log n)).
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 What is JDBC and Different types of JDBC and Different types of statements and advantages,explain with examples?
*JDBC = Java Database Connectivity.

*It‚Äôs a standard API (set of interfaces and classes) in java.sql package.

*It allows Java programs to:

*Connect to a database.

*Execute SQL queries.

*Retrieve results.

*Perform updates.

2. Types of JDBC Drivers

JDBC provides 4 types of drivers to connect to databases.
*1.java jdbc odbc driver
*Uses ODBC (Open Database Connectivity) driver under the hood.
*onverts JDBC calls into ODBC calls.

Disadvantage: Requires ODBC installation, platform dependent, very slow.



2.Native API Driver
*Converts JDBC calls into native database-specific API calls (using C/C++ libraries).

Faster than Type 1 but requires native libraries on client machine.

Example: Oracle OCI driver.



3.Type 3: Network Protocol Driver
*Uses a middle-tier server to convert JDBC calls into DB-specific protocol.

*Good for internet-based apps.

Adds an extra network hop ‚Üí slower.


4.Type 4: Thin Driver (Pure Java)

Most commonly used today.

Directly converts JDBC calls to database protocol (pure Java).

Platform-independent, high performance.

Example: com.mysql.cj.jdbc.Driver for MySQL, org.postgresql.Driver for PostgreSQL.


Types of JDBC Statements

JDBC provides 3 main types of statements to execute SQL:
1.Statement
*Used for simple SQL queries without parameters.
*Each query is compiled every time ‚Üí slower.
*Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM users");
while (rs.next()) {
    System.out.println(rs.getString("username"));
}


2.PreparedStement
*Faster because query is compiled once and reused.
*Protects against SQL Injection.

String sql = "SELECT * FROM users WHERE id = ?";
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.setInt(1, 101);
ResultSet rs = pstmt.executeQuery();
if (rs.next()) {
    System.out.println(rs.getString("username"));
}


3.
CallableStatement cstmt = conn.prepareCall("{call getUser(?)}");
cstmt.setInt(1, 101);
ResultSet rs = cstmt.executeQuery();
if (rs.next()) {
    System.out.println(rs.getString("username"));
}


import java.sql.*;

public class JDBCDemo {
    public static void main(String[] args) {
        try {
            // 1. Load Driver (for MySQL)
            Class.forName("com.mysql.cj.jdbc.Driver");

            // 2. Establish Connection
            Connection conn = DriverManager.getConnection(
                    "jdbc:mysql://localhost:3306/testdb", "root", "password");

            // 3. Create PreparedStatement
            String sql = "INSERT INTO users (id, username, email) VALUES (?, ?, ?)";
            PreparedStatement pstmt = conn.prepareStatement(sql);
            pstmt.setInt(1, 101);
            pstmt.setString(2, "neha");
            pstmt.setString(3, "neha@example.com");

            // 4. Execute
            int rows = pstmt.executeUpdate();
            System.out.println(rows + " row(s) inserted.");

            // 5. Query
            Statement stmt = conn.createStatement();
            ResultSet rs = stmt.executeQuery("SELECT * FROM users");
            while (rs.next()) {
                System.out.println(rs.getInt("id") + " " + rs.getString("username"));
            }

            // 6. Close connection
            conn.close();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}





-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
‚ÄúIn my billing project, I mostly used ArrayList for storing invoice lists and transaction history, HashMap/LinkedHashMap for mapping customer IDs to bill/payment details, and HashSet/TreeSet for ensuring unique bill cycle IDs or keeping billing dates sorted. For background jobs, I used Queue/PriorityQueue to process pending billing or retry tasks, and in multithreaded modules I used ConcurrentHashMap to safely update payment statuses.‚Äù
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
    Scanner sc = new Scanner(System.in);
        System.out.print("Enter string: ");
        String input = sc.nextLine();

        Map<Character, Integer> freqMap = new LinkedHashMap<>();

        // Count characters in easy way
        for (char ch : input.toCharArray()) {
            if (freqMap.containsKey(ch)) {
                freqMap.put(ch, freqMap.get(ch) + 1);
            } else {
                freqMap.put(ch, 1);
            }
        }

        // Print frequency in order
        for (Map.Entry<Character, Integer> entry : freqMap.entrySet()) {
            System.out.print(entry.getKey() + "=" + entry.getValue() + ", ");

        }
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
J2EE: What is J2EE? What are J2EE components and services
*An enterprise application (EA) is a large-scale software system designed to support the operations of a business, government, or other organization.
They are mission-critical, meaning downtime or errors can directly affect revenue, customers, or operations
Key Characteristics
*Scalable ‚Üí can handle thousands or millions of users/transactions.
Example: Banking systems processing payments every second.
*Distributed ‚Üí runs on multiple servers and often across different locations.
Example: An airline reservation system accessed from multiple countries.
*Transactional ‚Üí need ACID transactions (Atomicity, Consistency, Isolation, Durability).
Example: If money is deducted from one account, it must be credited to another.
*Secure ‚Üí must handle authentication, authorization, encryption.
Example: An HR payroll system storing confidential employee data.

Reliable & available ‚Üí 24/7 uptime with failover and clustering.
Example: Telecom billing systems must run nonstop.




What is J2EE?

*J2EE (Java 2 Platform, Enterprise Edition) is/was a set of specifications for building enterprise applications in Java.

j2ee componnets
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
1.Web componnets





1.. Servlets
*Java classes that run inside a Servlet Container (like Tomcat, Jetty, or the web tier of WildFly/GlassFish).
They respond to HTTP requests (GET, POST, etc.) and generate responses (HTML, JSON, XML‚Ä¶).

Use Case: Controllers in MVC; handling form submissions, login, etc.
import jakarta.servlet.*;
import jakarta.servlet.http.*;
import java.io.IOException;

public class HelloServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
            throws ServletException, IOException {
        resp.setContentType("text/plain");
        resp.getWriter().write("Hello from Servlet!");
    }
}

import jakarta.servlet.annotation.WebServlet;

@WebServlet("/hello")
public class HelloServlet extends HttpServlet { ... }
Visiting http://localhost:8080/app/hello ‚Üí shows Hello from Servlet!


2.2. JSP (JavaServer Pages) / JSF (JavaServer Faces)
*
JSP

What:
JSP is basically HTML with embedded Java (<% %> scriptlets or JSTL tags).
The container compiles JSP into a servlet behind the scenes.

Use Case: Simple server-rendered UI.

JSP Example (hello.jsp)
<html>
  <body>
    <h1>Hello, <%= request.getParameter("name") %>!</h1>
  </body>
</html>


üìå Request: http://localhost:8080/app/hello.jsp?name=Neha ‚Üí shows Hello, Neha!


3.33. JAX-RS Resources (REST API)
*Part of Jakarta EE for building RESTful APIs.
Uses annotations like @Path, @GET, @POST.

Use Case: REST endpoints for SPA apps (React, Angular), mobile apps, or microservices.
What:
Part of Jakarta EE for building RESTful APIs.
Uses annotations like @Path, @GET, @POST.

Use Case: REST endpoints for SPA apps (React, Angular), mobile apps, or microservices.

Example REST Resource
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;

@Path("/hello")
public class HelloResource {

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String sayHello(@QueryParam("name") String name) {
        return "Hello, " + name;
    }
}

Application Activator:

import jakarta.ws.rs.ApplicationPath;
import jakarta.ws.rs.core.Application;

@ApplicationPath("/api")
public class RestConfig extends Application {} ,extends means start point and application pat means exposed where means where tostart


üìå Request: http://localhost:8080/app/api/hello?name=Neha ‚Üí response Hello, Neha


4.WebSocket Endpoints

What:
Provides full-duplex bi-directional communication between client and server.
Unlike HTTP (request/response), WebSocket keeps a persistent connection open.

Use Case: Chat apps, stock ticker, live dashboards, multiplayer games.
Example WebSocket Endpoint
import jakarta.websocket.*;
import jakarta.websocket.server.ServerEndpoint;

@ServerEndpoint("/chat")
public class ChatEndpoint {

    @OnOpen
    public void onOpen(Session session) {
        System.out.println("Client connected: " + session.getId());
    }

    @OnMessage
    public void onMessage(String msg, Session session) throws Exception {
        // Echo back the same message
        session.getBasicRemote().sendText("Server received: " + msg);
    }

    @OnClose
    public void onClose(Session session) {
        System.out.println("Client disconnected: " + session.getId());
    }
}


üìå Client-side (JS in browser):

let ws = new WebSocket("ws://localhost:8080/app/chat");
ws.onmessage = (event) => console.log(event.data);
ws.onopen = () => ws.send("Hello Server!");


‚û°Ô∏è Logs: Server received: Hello Server!
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
2.Business components


1.1. Stateless Session Beans
*A service where each method call is independent. No client-specific state is kept.
import jakarta.ejb.Stateless;

1.@Stateless
public class OrderService {

    public String placeOrder(String product, int qty) {
        return "Order placed: " + qty + " x " + product;
    }
}

import jakarta.inject.Inject;
import jakarta.servlet.*;
import jakarta.servlet.http.*;
import java.io.IOException;

public class OrderServlet extends HttpServlet {

    @Inject
    private OrderService orderService;

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        String result = orderService.placeOrder("Laptop", 2);
        resp.getWriter().write(result);
    }
}



2.Stateful beans 
Keeps client-specific data between calls. Like a shopping cart.
import jakarta.ejb.Stateful;
import java.util.ArrayList;
import java.util.List;

@Stateful
public class ShoppingCart {

    private List<String> items = new ArrayList<>();

    public void addItem(String item) {
        items.add(item);
    }

    public List<String> viewCart() {
        return items;
    }
}
import jakarta.inject.Inject;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import java.util.List;

@Path("/cart")
public class CartResource {

    @Inject
    private ShoppingCart cart;

    @POST
    @Path("/add/{item}")
    public String addItem(@PathParam("item") String item) {
        cart.addItem(item);
        return item + " added!";
    }

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public List<String> view() {
        return cart.viewCart();
    }
}




3.Singleto session beans

4.Message-Driven Bean (MDB)
*A web layer (Servlet, REST, etc.) sends an order message (like "Order#1234") into a JMS Queue.
*A Message-Driven Bean (MDB) listens to that queue.
*Whenever a new message arrives, the MDB is automatically triggered and processes the order.


 Queue Setup

Most Java EE / Jakarta EE servers (like WildFly, Payara, GlassFish) come with JMS built-in. You configure a Queue in the server (e.g., jms/OrderQueue).

Example (server configuration XML or admin console):

<jms-queue name="OrderQueue" entries="java:/jms/queue/OrderQueue"/>


Now the queue is available at the JNDI name:
üëâ jms/OrderQueue


3. The MDB (Message-Driven Bean)
import jakarta.ejb.ActivationConfigProperty;
import jakarta.ejb.MessageDriven;
import jakarta.jms.Message;
import jakarta.jms.MessageListener;
import jakarta.jms.TextMessage;

@MessageDriven(activationConfig = {
    @ActivationConfigProperty(propertyName = "destinationLookup", propertyValue = "jms/OrderQueue"),
    @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "jakarta.jms.Queue")
})
public class OrderProcessorMDB implements MessageListener {

    @Override
    public void onMessage(Message message) {
        try {
            if (message instanceof TextMessage) {
                String order = ((TextMessage) message).getText();
                System.out.println("üì¶ Processing order in MDB: " + order);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}


‚úî This MDB is not called manually.
‚úî The server automatically calls onMessage() whenever a message appears in the queue.

4. Sending a Message to the Queue

We need a producer that sends messages into jms/OrderQueue. This could be a Servlet, REST API, or even another EJB.

Example: Servlet that places an order:

import jakarta.annotation.Resource;
import jakarta.jms.ConnectionFactory;
import jakarta.jms.JMSContext;
import jakarta.jms.Queue;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/placeOrder")
public class OrderServlet extends HttpServlet {

    @Resource(lookup = "jms/ConnectionFactory")
    private ConnectionFactory connectionFactory;

    @Resource(lookup = "jms/OrderQueue")
    private Queue orderQueue;

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
            throws ServletException, IOException {

        String orderId = req.getParameter("id"); // e.g., ?id=123
        try (JMSContext context = connectionFactory.createContext()) {
            context.createProducer().send(orderQueue, "Order#" + orderId);
            resp.getWriter().write("‚úÖ Order placed: " + orderId);
        }
    }
}







5.5. CDI Beans (Contexts & Dependency Injection)

üëâ Lightweight beans that glue everything together using @Inject.

Example
import jakarta.enterprise.context.RequestScoped;

@RequestScoped
public class GreetingService {
    public String greet(String name) {
        return "Hello, " + name;
    }
}


Usage in REST Resource:

import jakarta.inject.Inject;
import jakarta.ws.rs.*;

@Path("/greet")
public class GreetingResource {

    @Inject
    private GreetingService greetingService;

    @GET
    public String greet(@QueryParam("name") String name) {
        return greetingService.greet(name);
    }
}


üìå CDI beans are very common now ‚Üí lighter than EJBs and preferred for business logic.



--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Persistence componenets
1.JPA Entities ‚Üí Java classes mapped to database tables (like ORM).

import jakarta.persistence.*;

@Entity
@Table(name = "customers")
public class Customer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // Auto-increment
    private Long id;

    private String name;
    private String email;

    // Constructors
    public Customer() {}
    public Customer(String name, String email) {
        this.name = name;
        this.email = email;
    }

    // Getters & Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
}



2.EntityManager ‚Üí API to perform CRUD (Create, Read, Update, Delete).

Repositories (DAOs) ‚Üí Classes that use EntityManager to access entities

import jakarta.persistence.*;

@Entity
@Table(name = "customers")
public class Customer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // Auto-increment
    private Long id;

    private String name;
    private String email;

    // Constructors
    public Customer() {}
    public Customer(String name, String email) {
        this.name = name;
        this.email = email;
    }

    // Getters & Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
}

Repository (DAO) ‚Äì CustomerRepository
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.transaction.Transactional;
import java.util.List;

public class CustomerRepository {

    @PersistenceContext
    private EntityManager em;

    @Transactional
    public void save(Customer customer) {
        em.persist(customer); // insert
    }

    public Customer find(Long id) {
        return em.find(Customer.class, id); // select by ID
    }

    public List<Customer> findAll() {
        return em.createQuery("SELECT c FROM Customer c", Customer.class).getResultList();
    }

    @Transactional
    public void update(Customer customer) {
        em.merge(customer); // update
    }

    @Transactional
    public void delete(Long id) {
        Customer c = em.find(Customer.class, id);
        if (c != null) {
            em.remove(c); // delete
        }
    }
}
Repository (DAO) ‚Äì CustomerRepository
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.transaction.Transactional;
import java.util.List;

public class CustomerRepository {

    @PersistenceContext
    private EntityManager em;

    @Transactional
    public void save(Customer customer) {
        em.persist(customer); // insert
    }

    public Customer find(Long id) {
        return em.find(Customer.class, id); // select by ID
    }

    public List<Customer> findAll() {
        return em.createQuery("SELECT c FROM Customer c", Customer.class).getResultList();
    }

    @Transactional
    public void update(Customer customer) {
        em.merge(customer); // update
    }

    @Transactional
    public void delete(Long id) {
        Customer c = em.find(Customer.class, id);
        if (c != null) {
            em.remove(c); // delete
        }
    }
}


üëâ The repository uses EntityManager for CRUD.

3Ô∏è‚É£ EJB Service ‚Äì CustomerService
import jakarta.ejb.Stateless;
import jakarta.inject.Inject;
import java.util.List;

@Stateless
public class CustomerService {

    @Inject
    private CustomerRepository repository;

    public void createCustomer(String name, String email) {
        Customer c = new Customer(name, email);
        repository.save(c);
    }

    public Customer getCustomer(Long id) {
        return repository.find(id);
    }

    public List<Customer> getAllCustomers() {
        return repository.findAll();
    }

    public void updateCustomer(Customer customer) {
        repository.update(customer);
    }

    public void deleteCustomer(Long id) {
        repository.delete(id);
    }
}


üëâ Business logic sits here, using the repository.

4Ô∏è‚É£ REST API ‚Äì CustomerResource
import jakarta.inject.Inject;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import java.util.List;

@Path("/customers")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class CustomerResource {

    @Inject
    private CustomerService service;

    @POST
    public void create(Customer customer) {
        service.createCustomer(customer.getName(), customer.getEmail());
    }

    @GET
    @Path("/{id}")
    public Customer find(@PathParam("id") Long id) {
        return service.getCustomer(id);
    }

    @GET
    public List<Customer> findAll() {
        return service.getAllCustomers();
    }

    @PUT
    public void update(Customer customer) {
        service.updateCustomer(customer);
    }

    @DELETE
    @Path("/{id}")
    public void delete(@PathParam("id") Long id) {
        service.deleteCustomer(id);
    }
}


üëâ Now you can call APIs like:

POST /api/customers ‚Üí create customer

GET /api/customers/1 ‚Üí get customer with ID 1

GET /api/customers ‚Üí list all customers

PUT /api/customers ‚Üí update

DELETE /api/customers/1 ‚Üí delete


5Ô∏è‚É£ Persistence Configuration ‚Äì persistence.xml
<persistence xmlns="https://jakarta.ee/xml/ns/persistence"
             version="3.0">
    <persistence-unit name="MyPU" transaction-type="JTA">
        <jta-data-source>jdbc/MyDS</jta-data-source>
        <properties>
            <property name="jakarta.persistence.schema-generation.database.action" value="create"/>
            <property name="jakarta.persistence.jdbc.show_sql" value="true"/>
        </properties>
    </persistence-unit>
</persistence>


üëâ This tells JPA to use a datasource jdbc/MyDS.

Why do we need persistence.xml?

Purpose:
persistence.xml is the configuration file for JPA (Java Persistence API).
It tells the application server (WildFly, Payara, GlassFish, JBoss, TomEE, etc.) how to connect to the database and how JPA entities should behave.

Without it: JPA would not know where to store entities (tables, database connection, etc.), or what persistence provider (Hibernate, EclipseLink, etc.) to use.

üîπ Key Parts of the Example
<persistence xmlns="https://jakarta.ee/xml/ns/persistence"
             version="3.0">
    <persistence-unit name="MyPU" transaction-type="JTA">
        <jta-data-source>jdbc/MyDS</jta-data-source>
        <properties>
            <property name="jakarta.persistence.schema-generation.database.action" value="create"/>
            <property name="jakarta.persistence.jdbc.show_sql" value="true"/>
        </properties>
    </persistence-unit>
</persistence>


<persistence-unit name="MyPU">

A persistence unit is like a named configuration of database + entities.

You can have multiple persistence units (e.g., one for MySQL, one for PostgreSQL).

MyPU is later used in code with @PersistenceContext(unitName="MyPU").

transaction-type="JTA"

Tells JPA that transactions are managed by the application server (standard in J2EE).

Alternative: "RESOURCE_LOCAL" ‚Üí for standalone apps (transactions managed manually).

<jta-data-source>jdbc/MyDS</jta-data-source>

Refers to a JNDI DataSource configured in the application server.

Example: WildFly/Payara/TomEE define jdbc/MyDS with DB URL, username, password in server config.

So JPA doesn‚Äôt store DB credentials here ‚Üí instead, it looks up jdbc/MyDS.

<property name="jakarta.persistence.schema-generation.database.action" value="create"/>

Auto-generate database schema (tables). Options:

none ‚Üí don‚Äôt touch DB

create ‚Üí drop + create schema each time

drop-and-create ‚Üí recreate on each deploy

update ‚Üí update schema (safe for dev, risky in prod)

jakarta.persistence.jdbc.show_sql

Show SQL queries in logs (useful for debugging).

üîπ Where is Database Address Stored?

üëâ Not in persistence.xml (when using JTA).
Instead, it‚Äôs stored in the Application Server‚Äôs DataSource configuration.

Example ‚Äì WildFly standalone.xml
<datasources>
    <datasource jndi-name="java:/jdbc/MyDS" pool-name="MyDS">
        <connection-url>jdbc:mysql://localhost:3306/mydb</connection-url>
        <driver>mysql</driver>
        <security>
            <user-name>root</user-name>
            <password>password</password>
        </security>
    </datasource>
</datasources>


Here:

Database address: jdbc:mysql://localhost:3306/mydb

Username/password: stored securely in server config

JPA only needs to know jdbc/MyDS ‚Üí server resolves it.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is hibernate
*Hibernate is an ORM (Object Relational Mapping) framework for Java.
*t allows you to map Java classes (objects) to database tables
*automatically handle the SQL queries behind the scenes.
*Why Hibernate?

Without Hibernate (using plain JDBC):

You write lots of boilerplate code (connection handling, statements, result sets, closing resources).

SQL queries are scattered across your code.

Hard to maintain and switch databases.



With Hibernate:

You work directly with entities (POJOs).

Hibernate generates SQL automatically.

It supports caching, lazy loading, transactions, and multiple DB dialects.


*Core Features of Hibernate

1.ORM (Object Relational Mapping)

Maps Java classes ‚Üí DB tables

Maps Java fields ‚Üí DB columns

2.Database independence

Just change the dialect (e.g., MySQL ‚Üí PostgreSQL)

HQL (Hibernate Query Language)

3.Similar to SQL, but operates on objects, not tables.

4.Transaction management

Works with JTA, JDBC, or Spring Transaction Manager.

Caching

Improves performance with first-level (default) and second-level cache.

Automatic table creation (optional, via hbm2ddl.auto).


*Hibernate Architecture

Configuration ‚Üí Reads hibernate.cfg.xml or Java config.

SessionFactory ‚Üí Heavy, one per database.

Session ‚Üí Lightweight, represents a single unit of work (connection to DB).

Transaction ‚Üí Manages commit/rollback.

Query ‚Üí HQL/SQL execution.

import jakarta.persistence.*;

@Entity
@Table(name="users")
public class User {
    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String email;

    // getters & setters
}
Hibernate Configuration (hibernate.cfg.xml)
xml
Copy code
<!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd">

<hibernate-configuration>
    <session-factory>
        <property name="hibernate.connection.driver_class">com.mysql.cj.jdbc.Driver</property>
        <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/mydb</property>
        <property name="hibernate.connection.username">root</property>
        <property name="hibernate.connection.password">password</property>
        <property name="hibernate.dialect">org.hibernate.dialect.MySQL8Dialect</property>
        <property name="hibernate.hbm2ddl.auto">update</property>
        <property name="hibernate.show_sql">true</property>

        <mapping class="com.example.User"/>
    </session-factory>
</hibernate-configuration>
Saving an Object
java
Copy code
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

public class Main {
    public static void main(String[] args) {
        SessionFactory factory = new Configuration().configure("hibernate.cfg.xml").buildSessionFactory();
        Session session = factory.openSession();

        try {
            session.beginTransaction();

            User user = new User();
            user.setName("Neha");
            user.setEmail("neha@example.com");

            session.persist(user); // Hibernate will generate INSERT INTO users ...
            session.getTransaction().commit();
        } finally {
            session.close();
            factory.close();
        }
    }




-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
How many sessionfactory objects are needed to be configured when you are integrating with spring 

*What is SessionFactory in Hibernate?
SessionFactory is a thread-safe, heavyweight object in Hibernate.
It is responsible for:

Creating Session objects (which are lightweight and not thread-safe).

Holding metadata (mapping information, DB connection pool, SQL dialect, etc.).

Managing caching (first-level & optional second-level).


*How many SessionFactory objects do we need?
One SessionFactory per database.

If your Spring application connects to one database, you configure only one SessionFactory.

*<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-orm</artifactId>
    <version>6.1.2</version>
</dependency>
<dependency>
    <groupId>org.hibernate.orm</groupId>
    <artifactId>hibernate-core</artifactId>
    <version>6.4.0.Final</version>
</dependency>
<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <version>8.3.0</version>
</dependency>




import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.orm.hibernate5.LocalSessionFactoryBean;
import org.springframework.jdbc.datasource.DriverManagerDataSource;

import javax.sql.DataSource;
import java.util.Properties;

@Configuration
public class AppConfig {

    @Bean
    public DataSource dataSource() {
        DriverManagerDataSource ds = new DriverManagerDataSource();
        ds.setDriverClassName("com.mysql.cj.jdbc.Driver");
        ds.setUrl("jdbc:mysql://localhost:3306/mydb");
        ds.setUsername("root");
        ds.setPassword("password");
        return ds;
    }

    @Bean
    public LocalSessionFactoryBean sessionFactory() {
        LocalSessionFactoryBean factoryBean = new LocalSessionFactoryBean();
        factoryBean.setDataSource(dataSource());
        factoryBean.setPackagesToScan("com.example.entity"); // where your @Entity classes are
        factoryBean.setHibernateProperties(hibernateProperties());
        return factoryBean;
    }

    private Properties hibernateProperties() {
        Properties props = new Properties();
        props.put("hibernate.dialect", "org.hibernate.dialect.MySQL8Dialect");
        props.put("hibernate.hbm2ddl.auto", "update");
        props.put("hibernate.show_sql", "true");
        return props;
    }
}


‚úÖ Final Answer:

1 SessionFactory per database.

In 99% of Spring-Hibernate apps ‚Üí one SessionFactory is enough.

Multiple SessionFactory objects are only needed when integrating with multiple different databases.


Lets create the spig oot application with hibernate but here we will use the spring data jpa which uses the hibernate undershood
*Example: Spring Boot + Hibernate + MySQL

*
----<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">

    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>spring-hibernate-demo</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.4</version>
    </parent>

    <dependencies>
        <!-- Spring Boot Web -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <!-- Spring Data JPA (uses Hibernate under the hood) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>

        <!-- MySQL driver -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- Lombok (optional, for getters/setters) -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
    </dependencies>

</project>


2Ô∏è‚É£ Application Properties (src/main/resources/application.properties)

Here we configure database connection and Hibernate:

spring.datasource.url=jdbc:mysql://localhost:3306/testdb
spring.datasource.username=root
spring.datasource.password=yourpassword
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# JPA/Hibernate properties
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect


üìå Here Spring Boot auto-creates one SessionFactory for this datasource.


3Ô∏è‚É£ Entity Class (User.java)
package com.example.springhibernatedemo.entity;

import jakarta.persistence.*;
import lombok.Data;

@Data
@Entity
@Table(name = "users")
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String email;
}


4Ô∏è‚É£ Repository Interface

Spring Data JPA automatically implements CRUD:

package com.example.springhibernatedemo.repository;

import com.example.springhibernatedemo.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;

public interface UserRepository extends JpaRepository<User, Long> {


Service Layer (UserService.java)
package com.example.springhibernatedemo.service;

import com.example.springhibernatedemo.entity.User;
import com.example.springhibernatedemo.repository.UserRepository;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class UserService {
    
    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public User saveUser(User user) {
        return userRepository.save(user);
    }

    public List<User> getAllUsers() {
        return userRepository.findAll();
    }
}



6Ô∏è‚É£ REST Controller (UserController.java)
package com.example.springhibernatedemo.controller;

import com.example.springhibernatedemo.entity.User;
import com.example.springhibernatedemo.service.UserService;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @PostMapping
    public User addUser(@RequestBody User user) {
        return userService.saveUser(user);
    }

    @GetMapping
    public List<User> getUsers() {
        return userService.getAllUsers();
    }


6Ô∏è‚É£ REST Controller (UserController.java)
package com.example.springhibernatedemo.controller;

import com.example.springhibernatedemo.entity.User;
import com.example.springhibernatedemo.service.UserService;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @PostMapping
    public User addUser(@RequestBody User user) {
        return userService.saveUser(user);
    }

    @GetMapping
    public List<User> getUsers() {
        return userService.getAllUsers();
    }
------------------------------------------------------------------------------------------------------------------------------------------------------------------
Spring Boot + Spring Data JPA
Difference between Entity, Repository, Service, Controller
1Ô∏è‚É£ Entity

Represents a table in the database.

Each instance of the entity = a row in the table.

Annotated with @Entity.

Only contains fields, constructors, getters/setters.

‚ùå Does NOT contain business logic.

üëâ Example:

import jakarta.persistence.*;

@Entity
@Table(name = "students")
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private int age;

    public Student() {}
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Getters & Setters
}


‚úÖ students table in DB will be mapped to Student class.

2Ô∏è‚É£ Repository

Acts as the Data Access Layer (DAO).

Communicates with DB using JPA / Hibernate under the hood.

You do not write SQL queries for most cases, Spring Data JPA generates them.

Annotated with @Repository (optional, JpaRepository already has it).

üëâ Example:

import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

public interface StudentRepository extends JpaRepository<Student, Long> {
    List<Student> findByName(String name);  // Custom finder
}


‚úÖ Provides built-in CRUD methods:

save()

findAll()

findById()

deleteById()

3Ô∏è‚É£ Service

Contains business logic.

Calls Repository methods.

Keeps your Controller clean.

Annotated with @Service.

üëâ Example:

import org.springframework.stereotype.Service;
import java.util.List;

@Service
public class StudentService {
    private final StudentRepository studentRepository;

    public StudentService(StudentRepository studentRepository) {
        this.studentRepository = studentRepository;
    }

    public Student addStudent(Student student) {
        return studentRepository.save(student);
    }

    public List<Student> getAllStudents() {
        return studentRepository.findAll();
    }

    public List<Student> findStudentsByName(String name) {
        return studentRepository.findByName(name);
    }
}


‚úÖ Handles ‚Äúhow‚Äù things should be done (e.g., validation, transformations, combining multiple repo calls, etc.).

4Ô∏è‚É£ Controller

Acts as the API layer (REST endpoints).

Handles HTTP requests (GET, POST, PUT, DELETE).

Calls the Service layer to perform actions.

Annotated with @RestController.

üëâ Example:

import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping("/students")
public class StudentController {
    private final StudentService studentService;

    public StudentController(StudentService studentService) {
        this.studentService = studentService;
    }

    @PostMapping
    public Student createStudent(@RequestBody Student student) {
        return studentService.addStudent(student);
    }

    @GetMapping
    public List<Student> getAllStudents() {
        return studentService.getAllStudents();
    }

    @GetMapping("/{name}")
    public List<Student> getStudentsByName(@PathVariable String name) {
        return studentService.findStudentsByName(name);
    }
}


‚úÖ Handles HTTP ‚Üí calls Service ‚Üí returns JSON response.

üìå Summary Table
Layer	Responsibility	Example Annotation	Example Code
Entity	Represents DB table	@Entity	Student {id, name, age}
Repository	Data Access (CRUD/Queries)	@Repository (implicit in JpaRepository)	StudentRepository extends JpaRepository
Service	Business Logic, calls Repository	@Service	StudentService {addStudent, findAll}
Controller	Handles HTTP requests, calls Service	@RestController	StudentController {GET, POST endpoints}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
spring boot+hiberfnate->spring data jpa
MySQL connector
spring we bap for the spring mvc

1. Dependencies (pom.xml)
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>spring-boot-hibernate-demo</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.3.2</version>
    </parent>

    <dependencies>
        <!-- Spring Boot + JPA (Hibernate under the hood) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>

        <!-- MySQL Driver -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- Web (REST API) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
    </dependencies>
</project>

üîπ 2. Configuration (application.properties)

We use placeholders so environment variables can override values:

spring.datasource.url=jdbc:mysql://localhost:3306/demo_db
spring.datasource.username=${DB_USER:root}
spring.datasource.password=${DB_PASSWORD:password}
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# Hibernate settings
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect


üëâ Here:

${DB_USER:root} ‚Üí if DB_USER env variable exists, it will be used; otherwise default = root.

${DB_PASSWORD:password} ‚Üí uses environment variable if available, else "password".

üîπ 3. Entity (User.java)
package com.example.demo.entity;

import jakarta.persistence.*;

@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String email;

    public User() {}

    public User(String name, String email) {
        this.name = name;
        this.email = email;
    }

    // getters & setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
}

üîπ 4. Repository (UserRepository.java)
package com.example.demo.repository;

import com.example.demo.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
}

üîπ 5. Service (UserService.java)
package com.example.demo.service;

import com.example.demo.entity.User;
import com.example.demo.repository.UserRepository;
import org.springframework.stereotype.Service;
import java.util.List;

@Service
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public List<User> getAllUsers() {
        return userRepository.findAll();
    }

    public User saveUser(User user) {
        return userRepository.save(user);
    }
}

üîπ 6. Controller (UserController.java)
package com.example.demo.controller;

import com.example.demo.entity.User;
import com.example.demo.service.UserService;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping
    public List<User> getUsers() {
        return userService.getAllUsers();
    }

    @PostMapping
    public User addUser(@RequestBody User user) {
        return userService.saveUser(user);
    }
}

üîπ 7. Main Class (DemoApplication.java)
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}


----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Explain cache and how to implement it?
*A cache stores frequently accessed objects in memory
*so that Hibernate does not hit the database every time.

First level cacahe
*Enabled by default.

*Scoped to a Hibernate Session.

*Stores objects within the session, so if you query the same entity twice in the same session ‚Üí Hibernate fetches it from memory, not DB.
Session session = sessionFactory.openSession();

User user1 = session.get(User.class, 1);  // Hits DB
User user2 = session.get(User.class, 1);  // From cache (no DB hit)

session.close();

Example (First-Level Cache)

Suppose you have an entity User:

@Entity
@Table(name = "users")
public class User {
    @Id
    private Long id;
    private String name;

    // getters and setters
}

Test Code
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

public class FirstLevelCacheExample {
    public static void main(String[] args) {
        SessionFactory factory = new Configuration()
                .configure("hibernate.cfg.xml") // DB config here
                .addAnnotatedClass(User.class)
                .buildSessionFactory();

        Session session = factory.openSession();

        session.beginTransaction();

        // First call ‚Üí Hits DB, stores in Session cache
        User user1 = session.get(User.class, 1L);
        System.out.println("User fetched first time: " + user1.getName());

        // Second call (same session, same ID) ‚Üí Comes from cache (No DB hit)
        User user2 = session.get(User.class, 1L);
        System.out.println("User fetched second time: " + user2.getName());

        session.getTransaction().commit();
        session.close();
        factory.close();
    }
}


Second level cache
*Optional, must be explicitly enabled.

*Works at the SessionFactory scope (shared among sessions).

*Useful when multiple sessions are running in the app and you want to avoid hitting DB for frequently used entities.

*Requires a caching provider like EhCache, Infinispan, Caffeine, or Redis.

Full Example: Hibernate Second-Level Cache with Spring Boot
1Ô∏è‚É£ Dependencies (pom.xml)

We need Web, JPA, Database Driver, and Ehcache:

<dependencies>
    <!-- Spring Boot Web Starter (for REST APIs) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!-- Spring Data JPA -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>

    <!-- H2 Database (you can replace with MySQL/Postgres driver) -->
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
        <scope>runtime</scope>
    </dependency>

    <!-- Hibernate Ehcache for 2nd Level Caching -->
    <dependency>
        <groupId>org.hibernate.orm</groupId>
        <artifactId>hibernate-ehcache</artifactId>
    </dependency>
</dependencies>

2Ô∏è‚É£ application.properties

Here we store DB connection, Hibernate, and caching configs.

# ===============================
# Database Config (H2 in-memory)
# ===============================
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=

# ===============================
# Hibernate Config
# ===============================
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

# ===============================
# Hibernate 2nd Level Cache
# ===============================
spring.jpa.properties.hibernate.cache.use_second_level_cache=true
spring.jpa.properties.hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory
spring.jpa.properties.hibernate.cache.use_query_cache=true

3Ô∏è‚É£ Entity with Cache Enabled
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import org.hibernate.annotations.Cache;
import org.hibernate.annotations.CacheConcurrencyStrategy;

@Entity
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)  // enable Hibernate cache
public class Student {

    @Id
    private Long id;
    private String name;

    public Student() {}
    public Student(Long id, String name) {
        this.id = id;
        this.name = name;
    }

    // getters and setters
}

4Ô∏è‚É£ Repository
import org.springframework.data.jpa.repository.JpaRepository;

public interface StudentRepository extends JpaRepository<Student, Long> {
    Student findByName(String name);
}

5Ô∏è‚É£ Service Layer

Notice here: No EntityManager ‚Äî just repository injection.
Caching works automatically because Hibernate sits behind JpaRepository.

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class StudentService {

    private final StudentRepository repo;

    public StudentService(StudentRepository repo) {
        this.repo = repo;
    }

    @Transactional(readOnly = true)
    public Student getStudentByName(String name) {
        System.out.println("Fetching from DB (first time) or Cache (next time)...");
        return repo.findByName(name);
    }
}

6Ô∏è‚É£ REST Controller
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class StudentController {

    private final StudentService service;

    public StudentController(StudentService service) {
        this.service = service;
    }

    @GetMapping("/student")
    public Student getStudent(@RequestParam String name) {
        return service.getStudentByName(name);
    }
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
Using redis
Perfect üëç You can also use Redis as a Hibernate second-level cache provider in Spring Boot instead of EhCache.

Here‚Äôs how you can set it up step by step:

‚úÖ 1. Add Dependencies (pom.xml)
<!-- MySQL Connector -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <scope>runtime</scope>
</dependency>

<!-- Spring Data JPA -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>

<!-- Redis Starter -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>

<!-- Hibernate Redis 2nd Level Cache -->
<dependency>
    <groupId>com.github.debop</groupId>
    <artifactId>hibernate-redis</artifactId>
    <version>2.6.4</version>
</dependency>

‚úÖ 2. Configure application.properties
# ===============================
# Database (MySQL)
# ===============================
spring.datasource.url=jdbc:mysql://localhost:3306/mydb?useSSL=false&serverTimezone=UTC
spring.datasource.username=root
spring.datasource.password=yourpassword
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

spring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

# ===============================
# Hibernate Second Level Cache (Redis)
# ===============================
spring.jpa.properties.hibernate.cache.use_second_level_cache=true
spring.jpa.properties.hibernate.cache.use_query_cache=true
spring.jpa.properties.hibernate.cache.region.factory_class=com.github.debop.hibernate.redis.RedisRegionFactory

# Point Hibernate to Redis
spring.jpa.properties.hibernate.cache.redis.expiry_in_seconds=120
spring.jpa.properties.hibernate.cache.redis.region_prefix=hibernate

# ===============================
# Redis Connection
# ===============================
spring.redis.host=localhost
spring.redis.port=6379
spring.redis.password=   # if Redis is password-protected
spring.redis.timeout=60000

‚úÖ 3. Entity with Cache
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import org.hibernate.annotations.Cache;
import org.hibernate.annotations.CacheConcurrencyStrategy;

@Entity
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Student {

    @Id
    private Long id;
    private String name;

    public Student() {}
    public Student(Long id, String name) {
        this.id = id;
        this.name = name;
    }

    // getters and setters
}

‚úÖ 4. Repository
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

public interface StudentRepository extends JpaRepository<Student, Long> {
    Optional<Student> findByName(String name);
}

‚úÖ 5. Service
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class StudentService {

    private final StudentRepository repo;

    public StudentService(StudentRepository repo) {
        this.repo = repo;
    }

    @Transactional(readOnly = true)
    public Student getStudentByName(String name) {
        return repo.findByName(name).orElseThrow(() -> new RuntimeException("Not found"));
    }
}

‚úÖ 6. Controller
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/students")
public class StudentController {

    private final StudentService service;

    public StudentController(StudentService service) {
        this.service = service;
    }

    @GetMapping
    public Student getStudent(@RequestParam String name) {
        return service.getStudentByName(name);
    }
}

‚úÖ 7. Test Flow (Redis Second Level Cache in Action)

Start MySQL and Redis.

Insert a record in DB:

INSERT INTO student (id, name) VALUES (1, 'ankitalokhande');


Call API:

GET http://localhost:8080/students?name=ankitalokhande


First call ‚Üí SQL query + Redis entry created.

Next call (even from another transaction/session) ‚Üí No SQL query, data served from Redis cache üéâ.

‚ö° This setup uses Redis as Hibernate 2nd-level cache (entity + query caching).

üëâ Do you want me to also show how to use RedisTemplate / Spring Cache abstraction (@Cacheable) on top of JPA repository instead of Hibernate-native caching? That‚Äôs often simpler in Spring Boot projects.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------



---------------------------------------------------------------------------------------------------------------------------------------------------------------------
JDBC: Direct DB access, you handle SQL + mapping manually ‚Üí best when you need fine control or simple apps.

HQL: Abstraction provided by Hibernate ‚Üí best when using ORM to work with objects instead of raw tables.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
erfect üëç ‚Äî let me explain your whole process step by step, so you clearly see what‚Äôs happening and why each command is needed.

1Ô∏è‚É£ Build image in Jenkins

In your Jenkins pipeline, you built a Docker image for your service (roaming-mcc-api) with version 1.0.6.

The built image is first stored in your internal registry:

cots.comviva.com:5010/roaming-mcc-api:1.0.6


Here:

cots.comviva.com:5010 = private Docker registry host:port

roaming-mcc-api:1.0.6 = image name and tag

2Ô∏è‚É£ Tagging image for AWS ECR

You want to move the image from your internal registry to AWS ECR (Elastic Container Registry).
So you tag it with the ECR repository path:

docker tag cots.comviva.com:5010/roaming-mcc-api:1.0.6 \
227974665651.dkr.ecr.ap-south-1.amazonaws.com/roaming-mcc-api:1.0.6


This does not copy the image ‚Äî it just gives your local image an additional name that points to your ECR repo (ap-south-1 region, AWS account 227974665651).

3Ô∏è‚É£ Push image to ECR

Now push the image to AWS ECR:

docker push 227974665651.dkr.ecr.ap-south-1.amazonaws.com/roaming-mcc-api:1.0.6


This uploads the image layers to the ECR repository.

Now your Kubernetes cluster (or any AWS infra) can pull it directly from ECR.

4Ô∏è‚É£ Go to Helm chart on BSS server

On your BSS server, you deploy applications using Helm charts.
You go to the chart folder for this service:

cd /home/dev-com-adm/helmchart/billing-helm/roaming-mcc-api


This folder contains values.yaml (or values.iml in your case) and Helm templates for deploying the service in Kubernetes.

5Ô∏è‚É£ Update values file

You edit the values file (values.iml) and change the image tag to the new version:

image:
  repository: 227974665651.dkr.ecr.ap-south-1.amazonaws.com/roaming-mcc-api
  tag: "1.0.6"


This ensures that when Helm deploys, it will pull the new image version from ECR.

(You also showed path configuration snippets, but those look like ingress paths mapping /roamingmaster/deleteMobileNetworkCode endpoints in the Helm chart.)

6Ô∏è‚É£ Deploy/Upgrade with Helm

Run Helm upgrade:

helm -n billing upgrade roaming-mcc-api .


-n billing ‚Üí namespace = billing

upgrade roaming-mcc-api . ‚Üí upgrades (or installs) the release named roaming-mcc-api using the Helm chart in the current folder (.).

This command will:

Pull the new image 1.0.6 from ECR

Apply updated Kubernetes manifests (Deployment, Service, Ingress, etc.)

Roll out the new pods with the updated container.

7Ô∏è‚É£ Login to AWS ECR (if needed)

Before pushing/pulling from ECR, you must authenticate Docker to ECR:

aws ecr get-login-password --region ap-southeast-1 \
| docker login --username AWS --password-stdin 147724041653.dkr.ecr.ap-southeast-1.amazonaws.com


This command retrieves a temporary login password from AWS (get-login-password).

Pipes it into docker login so Docker can authenticate against the ECR registry.

147724041653.dkr.ecr.ap-southeast-1.amazonaws.com = another AWS ECR registry (different account/region).

üîÑ Full Workflow in Plain English

Build Docker image in Jenkins.

Tag the image for AWS ECR.

Push image to ECR.

On BSS server, go to Helm chart for service.

Update Helm values.iml with new image version.

Run helm upgrade to roll out new version in Kubernetes.

Use aws ecr get-login-password whenever you need to log in to AWS ECR (to push/pull images).

‚úÖ So basically:
Jenkins builds image ‚Üí You push to ECR ‚Üí Helm pulls updated image from ECR ‚Üí Kubernetes deploys updated service
------------------------------------------------------------------------------------------------------------------------------------------------------------------------üü¶ Kubernetes (K8s)
What is it?

Kubernetes is a container orchestration platform.

It manages, scales, and deploys containers (usually Docker containers) automatically.

Think of it as an operating system for your cluster (a group of servers).

Key Features

Deployment Management

Define how many copies (replicas) of your app should run ‚Üí Kubernetes ensures they are always running.

Scaling

Auto-scale applications up/down based on CPU, memory, or custom metrics.

Self-Healing

If a container crashes, Kubernetes restarts it automatically.

Service Discovery & Load Balancing

Exposes services internally/externally and distributes traffic.

Rolling Updates

Deploy new versions with zero downtime.

Secret & Config Management

Store sensitive values (passwords, API keys) securely.

Example in simple words

You package your app in a Docker image.

You tell Kubernetes:

‚ÄúRun 3 copies of this app, expose it on port 80, and restart if it fails.‚Äù

Kubernetes makes sure that happens ‚Äî across many servers in your cluster.

üü© Jenkins
What is it?

Jenkins is a CI/CD (Continuous Integration / Continuous Delivery) automation server.

It automates building, testing, and deploying your applications.

Key Features

Build Automation

Runs your build scripts (Maven, Gradle, npm, etc.).

Testing

Executes unit tests, integration tests automatically.

CI/CD Pipelines

Automates the process:

Code ‚Üí Build ‚Üí Test ‚Üí Package ‚Üí Deploy.

Plugins

Integrates with GitHub, Docker, Kubernetes, AWS, etc.

Infrastructure as Code

Jenkinsfile (pipeline as code) defines all steps.

Example in simple words

Developer pushes code to GitHub.

Jenkins pipeline runs:

Build the app (e.g., mvn clean install).

Run tests.

Build Docker image.

Push image to AWS ECR.

Deploy new image to Kubernetes via Helm.

üîÑ How Jenkins + Kubernetes Work Together

Jenkins = automation engine (build/test/deploy).

Kubernetes = runtime platform (runs your apps in containers).

üëâ Typical DevOps workflow:

Developer commits code ‚Üí GitHub.

Jenkins pipeline runs ‚Üí builds Docker image ‚Üí pushes to ECR.

Jenkins triggers a Helm/Kubectl command ‚Üí deploys app on Kubernetes.

Kubernetes ensures the app is up, scaled, and load-balanced.

‚úÖ In short:

Jenkins = Factory (builds and delivers apps).

Kubernetes = Warehouse + Delivery system (runs and manages those apps in production).

Do you want me to also draw a workflow diagram (GitHub ‚Üí Jenkins ‚Üí ECR ‚Üí
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Spring boot
*Spring and spring boot are based on the servlet and servlet container
*so basically servlets ae java cases that handle the http request and return response
*Srvletcontainer which manags the servlets

*so what use to happen we have many servlet and web.xml whre servlet maping happens in the web.xml  meand for this api point which servlet to call
*For each servlet we have 4 methods 
*so all servlet and web.xm get deploted at tomcat adn tomcat get request first see the web.xml than find the servlet from servlet mapping and then send response


*Now managing such big web.xml became difficult
*along with this spring has dependency injection due to which the unit testing becomes easier in the spring
*there was difficulty in handling multiple http requests
*Along with it we have the spring ,we can integrate easily like for testing joint,mockito ets and for the database spring data jpa and the hibernate


Lets discuss structure of he spring mvc
first app eployed to tomcat
*request comes it move to tomcat
*tehn goes to dispatcher servlet
*dispatcher servlet throufht the annotation request ampping find which controller to invoke
*then create instance of that controller class by first of doing dependency injection

*then finally invoke controller method
*So basically we require the pom,controller ,appconfig with the annoattaion of anablemvc and component scan ,dispatcher servlet class where we need to oveeride 3 methods



*So in the pom file we need to give the dependency and version and if we want to upgrade version of one dependency ,will it be compatible with other versions,It may or may not
*So here dependency management increases but with springbbot we need not to write the dependency and their version separately and compatible version
*Autoconfiguration menas we need not have separate config for the dispatcher servlet,app config ,spirngboot add internally

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Maven
*so maven basically is project management tool
*that manage build generation
*dcumenttaion 

So where we give command it see pom.xml then download the deoendecy from maven store in local and give to project
*in pom.xml we hav eth parant the repository 
*

We hav emany phase
*project structure
*compile the code
*test
*package
*validate package
*dependencies
*deploy
Note:if one want to run the one phase and all the phase before needs to be completed
*Son in each phase w hve task and running one task all task before needs to be completed
*And one more thing is that the if we want to add task to a particular phase we can add it by the buil blugin in pom file
*Note after mvn compiler there is one more folder generated target folder
*when i do mvn test
*mvn pacakage it produces war or jar file and produces in the jar file
*mvn intall so it will put the jar we created in the local reposity in m2 folder
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Spring boot annotation
*@Controller tells this class is reposnsible for handling incoming request
*@Rst controller is controller with response body
*


1.package com.example.demo.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class HomeController {

    @GetMapping("/hello")
    public String sayHello(Model model) {
        model.addAttribute("message", "Hello from Controller!");
        return "hello";  // returns hello.html (Thymeleaf) or hello.jsp depending on setup
    }
}
so here if we dont give response body it ill consider hello s the view nd lokk for jsp instead of taking as rets response
*Note here @respnsebody is required to ell ts the rest response 
2.*@Controller
public class HomeController {

    @RequestMapping(path='/ap' metod="Post")
@Respose Body
    public String sayHello(Model model) {
        model.addAttribute("message", "Hello from Controller!");
        return "hello";  // returns hello.html (Thymeleaf) or hello.jsp depending on setup
    }
}
*



3.package com.example.demo.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@Requestmaping(value="/api/")
public class ApiController {

    @GetMapping("/api/hello")
    public String sayHello() {
        return "Hello from RestController!";
    }
}

but here restcontrooler s already controller + respose body

Note:basically request mappin map the dn point to cotroller mathod

*Requestpram annotiatio maps the request paramether with the controller method parameter
*
@RestController
public class UserApiController {

    // Example: GET /api/user?name=Neha&age=25
    @GetMapping("/api/user")
    public String getUser(
            @RequestParam(name="firstname") String name, 
            @RequestParam(required = false, defaultValue = "18") int age) {
        
        return "User name: " + name + ", Age: " + age;
    }
}
so url is /api /?firstname="neha" so map the firstname to string name
*By default the all the parameters are required but we can set it to false also
*Note:i want that the beore the url parameter being assign the method paramete we need to validate and then put we can use the propertyeditor 
*package com.example.demo.controller;

import com.example.demo.editor.FirstNamePropertyEditor;
import org.springframework.web.bind.WebDataBinder;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class SampleController {

    // Register custom editor for "firstName" field
    @InitBinder
    protected void initBinder(WebDataBinder binder) {
        binder.registerCustomEditor(String.class, "firstName", new FirstNamePropertyEditor());
    }

    // Example: GET /api/fetchUser?firstName=ShrayAn&lastName=Raghav&age=25
    @GetMapping("/fetchUser")
    public String getUserDetails(
            @RequestParam(name = "firstName") String firstName,
            @RequestParam(name = "lastName", required = false) String lastName,
            @RequestParam(name = "age") int age) {

        return "Fetching and returning user details based on: " +
                "firstName = " + firstName +
                ", lastName = " + lastName +
                ", age = " + age;
    }
}

package com.example.demo.editor;

import java.beans.PropertyEditorSupport;

public class FirstNamePropertyEditor extends PropertyEditorSupport {

    @Override
    public void setAsText(String text) throws IllegalArgumentException {
        // Convert to lowercase and trim spaces
        setValue(text.trim().toLowerCase());
    }
}


*@Patvraiale extract the vale from url and put in the method parameter
*package com.example.demo.controller;

import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class UserController {

    // Example: GET /api/user/101
    @GetMapping("/user/{id}")
    public String getUserById(@PathVariable("id") int userId) {
        return "Fetching user with ID: " + userId;
    }
}


*@RequestBody bind the http request body with the method prameters
*package com.example.demo.controller;

import com.example.demo.model.User;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/users")
public class UserController {

    // Example: POST /api/users/add
    @PostMapping("/add")
    public String addUser(@RequestBody User user) {
        return "User created: Name = " + user.getName() + ", Age = " + user.getAge();
    }
}
Note:heregson and Jackson will map the request body with clas user

*@ResponeEnity is the htpwhole respons eans attaus with the body
*@RestController
@RequestMapping("/api/users")
public class UserController {

    @GetMapping("/{id}")
    public ResponseEntity<String> getUser(@PathVariable int id) {
        if (id == 1) {
            return ResponseEntity.ok("User found: Neha"); // 200 OK wih body as userfound
        } else {
            return ResponseEntity.status(404).body("User not found"); // 404 Not Found with body as suer not found
        }
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Sprig lifecycle
1. Bean Instantiation
*Spring creates an instance of the bean (using reflection or constructor injection).
*@Component
public class MyBean {
    public MyBean() {
        System.out.println("1Ô∏è‚É£ Bean is instantiated");
    }
}



2.Dependency Injection (Populate Properties)
2. Dependency Injection (Populate Properties)

Spring injects dependencies (@Autowired, constructor args, etc.).


3.
üìí Spring Beans ‚Äì Notes
00:00 ‚Äì What is Bean

A Bean is an object managed by the Spring IoC container.

It is created, configured, and maintained by Spring.

Beans are the backbone of a Spring application.

01:00 ‚Äì How to Create Bean (@Component annotation)

Annotate a class with @Component (or stereotypes like @Service, @Repository, @Controller).

Spring automatically detects it using component scanning.

@Component
public class MyService {
    public void serve() {
        System.out.println("Service is running...");
    }
}

05:16 ‚Äì How to Create Bean (@Bean + @Configuration)

Use @Configuration on a class and @Bean on methods.

Useful when you want to create beans manually (e.g., third-party classes).

@Configuration
public class AppConfig {
    @Bean
    public MyService myService() {
        return new MyService();
    }
}

10:55 ‚Äì @ComponentScan annotation

Tells Spring where to search for components.

By default, it scans the package of the main class.

@SpringBootApplication
@ComponentScan(basePackages = "com.example.demo")
public class DemoApplication {}

14:01 ‚Äì Eagerly Initialized vs. Lazy-initialized Bean (@Lazy)

Eager Initialization (default): Bean created at application startup.

Lazy Initialization: Bean created only when it‚Äôs first requested.

@Component
@Lazy
public class LazyService {
    public LazyService() {
        System.out.println("LazyService bean created!");
    }
}

16:40 ‚Äì Lifecycle of Bean (@PostConstruct & @PreDestroy)

Spring beans have a lifecycle (creation ‚Üí initialization ‚Üí destruction).

Hooks:

@PostConstruct ‚Üí Runs after bean initialization.

@PreDestroy ‚Üí Runs before bean is destroyed.

@Component
public class LifecycleBean {

    @PostConstruct
    public void init() {
        System.out.println("Bean is initialized ‚úÖ");
    }

    @PreDestroy
    public void cleanup() {
        System.out.println("Bean is being destroyed ‚ùå");
    }
}


‚úÖ Quick Summary

Bean = Spring-managed object.

Create Beans ‚Üí @Component (auto) OR @Bean in @Configuration (manual).

ComponentScan ‚Üí Tells Spring where to find beans.

Eager vs Lazy ‚Üí Default is eager; @Lazy makes it lazy.

Lifecycle ‚Üí Use @PostConstruct & @PreDestroy for custom init/destroy logic.

Do you want me to also add a diagram of the bean lifecycle here so you can remember it visually during revision?

You said:
Do you want me to also add a diagram of the bean lifecycle here so you can remember it visually during revision?
ChatGPT said:

Yes üëç a diagram will help a lot in remembering the Spring Bean lifecycle.
Here‚Äôs a simple visual flow you can keep in your notes:

üå± Spring Bean Lifecycle
       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ Bean Instantiation ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
               ‚ñº
       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ Dependency Injection ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
               ‚ñº
       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ @PostConstruct (Init Method) ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
               ‚ñº
       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ   Bean is Ready (In Use)   ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
               ‚ñº
       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ @PreDestroy (Destroy Method)‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ
                   ‚ñº
            ‚ùå Bean Destroyed


‚úÖ Key Points in the Diagram

Instantiation ‚Üí Spring creates the bean object.

Dependency Injection ‚Üí Spring injects required dependencies.

Initialization ‚Üí Runs methods annotated with @PostConstruct.

Ready to Use ‚Üí Bean serves requests.

Destruction ‚Üí Before shutdown, @PreDestroy is called.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Dependenc injection was make a loss couling and to remve thedependy of one class on another,spring iternally manage it
*It si done by constructor,getetr an dsetter and field injection also called the autowired
1.1.Field injection
*so when  see autowired seen it say find the beans if found just ijectit here 
*If not found create the bean and inject it

Note:autowired does not work with immutable or we can say the final 
*@Component
public class MyService {
    @Autowired
    private MyRepository repo; // might be null if used too early

    public void serve() {
        repo.findAll(); // ‚ùå can cause NPE if repo not injected yet
    }
}
here Myservice m=new myservice()//caal default constructor and now its initlozed the repo to null and when we get the serve method we get null pointer exception
*Note:so dont create the object using constructor as the dependent object might have not been initialized
*


2Ô∏è‚É£ Setter Injection

Injects dependency through a setter method.

@Component
public class Car {

    private Engine engine;

    @Autowired
    public void setEngine(Engine engine) {
        this.engine = engine;
    }

    public void start() {
        engine.run();
    }
}


‚úÖ Pros

More testable than field injection.

Allows optional dependencies (you can skip calling setter).

Good if dependency can change later.

‚ùå Cons

Still allows the object to be in an incomplete state (engine could be null until setter is called).

3Ô∏è‚É£ Constructor Injection (Recommended ‚úÖ)

Injects dependency via the constructor.

@Component
public class Car {

    private final Engine engine; // final ‚Üí immutability

    @Autowired // optional in Spring Boot 2.5+ if only one constructor
    public Car(Engine engine) {
        this.engine = engine;
    }

    public void start() {
        engine.run();
    }
}


‚úÖ Pros

Best practice in Spring Boot.

Makes class immutable.

Forces all required dependencies to be present at object creation.

Great for unit testing (easy to pass mocks).

‚ùå Cons

More verbose than field injection.

If too many dependencies ‚Üí constructor becomes bloated (which is actually a sign of bad design).



recommendation of the constructor injection is because 
*we are 100% sure our dependency is initialized
*Wecan create th eimmutable objects 
*so by default if we dont add th autowird it will go with constructor injection and initilzw order with null and we get the null pointer exception in the runtime
*
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Perfect üöÄ ‚Äî I‚Äôll give you complete examples with logging for

Field Injection

Setter Injection

Constructor Injection (‚úÖ best practice)

Circular Dependency problem + solutions

And in each example, the Engine bean will log when it is created, so you can see the lifecycle clearly.

‚öôÔ∏è Common Engine Bean (with constructor logging)
import org.springframework.stereotype.Component;

@Component
public class Engine {

    public Engine() {
        System.out.println("‚úÖ Engine object created by Spring");
    }

    public void run() {
        System.out.println("üöó Engine running...");
    }
}

1Ô∏è‚É£ Field Injection Example (‚ùå not recommended)
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class CarFieldInjection {

    @Autowired
    private Engine engine; // FIELD INJECTION

    public CarFieldInjection() {
        System.out.println("CarFieldInjection object created");
    }

    public void start() {
        System.out.println("CarFieldInjection starting...");
        engine.run();
    }
}

Logs
‚úÖ Engine object created by Spring
CarFieldInjection object created
CarFieldInjection starting...
üöó Engine running...


‚ö†Ô∏è Problem ‚Üí engine can be null until Spring injects it. Hard to test/mock.

2Ô∏è‚É£ Setter Injection Example
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class CarSetterInjection {

    private Engine engine;

    public CarSetterInjection() {
        System.out.println("CarSetterInjection object created");
    }

    @Autowired
    public void setEngine(Engine engine) {
        this.engine = engine;
        System.out.println("‚úÖ Engine injected via setter");
    }

    public void start() {
        System.out.println("CarSetterInjection starting...");
        engine.run();
    }
}

Logs
‚úÖ Engine object created by Spring
CarSetterInjection object created
‚úÖ Engine injected via setter
CarSetterInjection starting...
üöó Engine running...


‚ö†Ô∏è Problem ‚Üí Bean can exist without engine until setter runs ‚Üí incomplete state.

3Ô∏è‚É£ Constructor Injection Example (‚úÖ best practice)
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class CarConstructorInjection {

    private final Engine engine;

    @Autowired  // optional if only one constructor
    public CarConstructorInjection(Engine engine) {
        this.engine = engine;
        System.out.println("‚úÖ Engine injected via constructor");
    }

    public void start() {
        System.out.println("CarConstructorInjection starting...");
        engine.run();
    }
}

Logs
‚úÖ Engine object created by Spring
‚úÖ Engine injected via constructor
CarConstructorInjection starting...
üöó Engine running...


‚úÖ Advantage ‚Üí Engine is always available (no null), Car is immutable, easy for unit tests.

4Ô∏è‚É£ Circular Dependency Problem (‚ùå)
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
class A {
    @Autowired
    private B b;
    public A() {
        System.out.println("A created");
    }
}

@Component
class B {
    @Autowired
    private A a;
    public B() {
        System.out.println("B created");
    }
}

Logs / Error
Error creating bean with name 'a': Requested bean is currently in creation: Is there an unresolvable circular re
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
üìí Spring Bean Scopes ‚Äì Notes
00:00 ‚Äì Introduction

A Bean Scope defines the lifecycle and visibility of a bean in the Spring container.

Tells Spring how many instances of a bean to create and how long they should live.

Default scope: Singleton.

01:45 ‚Äì Singleton Bean Scope

Default scope in Spring.

Only one instance per Spring IoC container.

Same object is shared across all requests.

@Component
@Scope("singleton")
public class SingletonService {}


‚úÖ Pros: Memory efficient, global shared state.
‚ùå Cons: Not suitable if unique instance is needed per request.

09:46 ‚Äì Prototype Bean Scope

A new bean instance is created every time it‚Äôs requested from the container.

@Component
@Scope("prototype")
public class PrototypeService {}


‚úÖ Pros: Each usage gets a fresh object.
‚ùå Cons: Higher memory usage, container doesn‚Äôt manage full lifecycle (no destroy callback).

17:23 ‚Äì Request Bean Scope

One bean instance per HTTP request (only in web-aware Spring contexts).

Each request gets its own instance.

@Component
@Scope("request")
public class RequestService {}


‚úÖ Pros: Perfect for request-specific data.
‚ùå Cons: Only valid in web apps (Spring MVC/Spring Boot Web).
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
unsatisfied dependency problem
@RestController
@RequestMapping("/api/orders")
public class UserController {
@autowired
   Order order;



    @GetMapping("/create")
    public String createOrder() {
        order.createOrder();
        return "Order created!";
    }
}


public interface Order {
    void createOrder();
}

@Component
public class OnlineOrder implements Order {
    public OnlineOrder() {
        System.out.println("Online Order Initialized");
    }
    public void createOrder() {
        System.out.println("Created Online Order");
    }
}

@Component
public class OfflineOrder implements Order {
    public OfflineOrder() {
        System.out.println("Offline Order Initialized");
    }
    public void createOrder() {
        System.out.println("Created Offline Order");
    }
}

@RestController
@RequestMapping("/api/orders")
public class UserController {

    private final Order order;

    @Autowired
    public UserController(@Qualifier("onlineOrder") Order order) {
        this.order = order;
    }

    @GetMapping("/create")
    public String createOrder() {
        order.createOrder();
        return "Order created!";
    }
}
so here as autowired it will not decide which beans to create and inject so fue to which user bean creation faila nd app start fails
*Now 1st solution to this will be 


1.add the @Qualifier above the 
@Qualifeir("only eorderobject")
@Component
public class OnlineOrder implements Order {
    public OnlineOrder() {
        System.out.println("Online Order Initialized");
    }
    public void createOrder() {
        System.out.println("Created Online Order");
    }
}
@Qualifeir("offlineeorderobject")

@Component
public class OfflineOrder implements Order {
    public OfflineOrder() {
        System.out.println("Offline Order Initialized");
    }
    public void createOrder() {
        System.out.println("Created Offline Order");
    }
}

and in suercontroller add 
@RestController
@RequestMapping("/api/orders")
public class UserController {
@Qualifier("offlineorderobject")
    @Autowired

    Order order;

    @GetMapping("/create")
    public String createOrder() {
        order.createOrder();
        return "Order created!";
    }
}

Note:bu here we are hardcoding so to amke it dynamic
and in suercontroller add 
@RestController
@RequestMapping("/api/orders")
public class UserController {
@Qualifier("offlineorderobject")
    @Autowired
    Order offlineOrder;

@Qualifier("offlineorderobject")
    @Autowired
    Order Onlineorder;

    @GetMapping("/create")
    public String createOrder() {
        order.createOrder();
        return "Order created!";
    }
}
Note:@value propert takes the value from app.property


2.dynamic remove component from order,order online and order offline and create one config file add bean which take value from app .propertw nd return new object of the online order or offline

---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Condidtional properties annotation
*when we start application beans is created automatically
*Now to control the creation of beans we hav conditiononpropert suppose wehva ebeand bconnection
*it has autowired MySQL and psql now i want to control any one connection 
*so apply cocnditional on roprety with perfc and value and if comparison miising means that object is not autowired
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import java.util.Objects;

@Component
public class DBConnection {

    @Autowired(required = false)
    private MySQLConnection mySQLConnection;

    @Autowired(required = false)
    private NoSQLConnection noSQLConnection;

    @PostConstruct
    public void init() {
        System.out.println("DB Connection Bean Created with dependencies below:");
        System.out.println("is MySQLConnection object null: " + Objects.isNull(mySQLConnection));
        System.out.println("is NoSQLConnection object null: " + Objects.isNull(noSQLConnection));
    }
}
# Choose either SQL or NoSQL
sql.connection.enabled=true
nosql.connection.enabled=false

import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Component;

@Component
@ConditionalOnProperty(prefix = "sql.connection", name = "enabled", havingValue = "true")
public class MySQLConnection {
    public MySQLConnection() {
        System.out.println("Initializing MySQLConnection");
    }
}

@Component
@ConditionalOnProperty(prefix = "nosql.connection", name = "enabled", havingValue = "true")
public class NoSQLConnection {
    public NoSQLConnection() {
        System.out.println("Initializing NoSQLConnection");
    }
}
*Adavantage of which bean to creat and save memory
*
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
@Profile annotation
*so we want that all database uesrnam and password store in app.properteis
*we want in dev this must be taken from app.properteis dev
*then app.propertes sprig,profile.active=dev

*condigure dynamically we can set the pplication start spring-boot.run.profile=dev
*or provide profile in pom.xml

@profile annotation tells create the bean when theis profile is et@Profile("dev")
*
*
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Aop
*so aop wil handelthe cross cuttingconcerns
*Cross cutting concerns are which are nt part of business logic
*like loggng
*joint point is basically the the exact meho from where aop starts
*supposewe have the class A->class b ha methd consistin of business logic and loggin logic sohere method in lass b is an aspect
*and then the we will have lass aop which will contain the logging logic
*so clss a first calls the class aop
*Then calls aop calls class b so class aop is advice and method in lass b is joitnpoint
*pointcut expression telsls on which class the method should be called
*Internal working is that the first of all the when a call b then request first goes to proxy around b and check if there is an aspect in the class b if yes than calls the proxy of that aspect and return reponse and than calls the plain object of b
*so if any business logic impelemt interface than cjib proxy is used otherwise jdk proxy is used
*So @springboot application already have the @enableaspectjautoproxy
*suppose we have product serveice which has many method ike add to product and all
*Now what happens is that @Aspect
@Componnetclass log{
public void log(){
}
}
*Now the thing is that the log is here is the advice method log is the aspect class in product service i want call the logger before add order method
*

1. Service Class (OrderService.java)
package com.example.demo.service;

import org.springframework.stereotype.Service;

@Service
public class OrderService {

    public void addOrder() {
        System.out.println("OrderService: Adding order...");
    }
}

2. Aspect Class (LoggerAOP.java)
package com.example.demo.aop;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class LoggerAOP {

    // log method
@Before("execution(* com.example.demo.service.OrderService.addOrder(..))")

    public void log() {
        System.out.println("LoggerAOP: Logging before method execution...");
    }

    
}
similary will be after
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
System design concurrency control

*suppose many concurrent request come d tehy want one seat
*so crirtical ection s hat piece of code where one resource is hared by many users
*so critical section if row with id has status free than change sttaus to book and update the db
*Now all users get the booked booked booked
*So basically what happens is that the we need to control cocncurrnecy
*So we can say e can make the method as synchronized
*So this code will work when we we havone process(server,1 machine) ,inside it hav many thread
*but wehen we have distributed ystem means many process(ervers) than this synchronise will not 
*So for the distributed concurrency control we ave 2 types the woroptimistic concurency control and pessismist concurrency contr
*Before that we need to understand few terms

1.What is usage of transactio
*Trnsaction lps is used to avoid any inconsistency in the database

begin transaction
debid from a ...success
credit to b fail

*tehn if redit to b success then commit
if credit to be fai than all success db operation will be rollbacked

end transaction
Note:if the transaction not present then there will be data inconsistency



2.What s db lockcing
*it means no other transaction can update the table rows
*so we have the shared lock denoted by the (S)
*Then e have the exclusive lock(E)

*So i say i ahd the shared lock on table row for transaction a ,then transaction b can only read the table using shard lock
*so or transaction a we have exclusive lock than transaction b cant take nor the shared lock or the exclusive lock means transaction b cant do the read or update



3.isolation level
i in acid measn that the even though many transaction are running in pararle but they are isolated
*Lets understand didffrenet roblem and hen  will understand dhow the isolation level will solve these problems
*Dirty code says suppose in transaction b we are awrting ome data in db and not yet commite and transaction a reads that data and if rollback occurs in b ,then transaction  gets the diry code

*Then we have the non repeated ode suppose transactio a raed ame row multiple times it will get different value some ime as nother ransaction had already writtenthe db
*Then we have the phantom code if transaction a write same query multiple timws than it can get different value

*0 lvele is the read uncommited isolation level so here no lck on read and write and here all 3 issue can can occur
*1 level is read commited isolation level,here for read shared lock is acquired ad release as read is done and for write exclusive lock  nd keep till end of transaction and here the proble can be non repeatable code and the phantom code
*2 level repeatable read is on read shared lock and keep till transaction end and also exclusive lock ad keep till end of transaction so dirty ,here phantom can be iisue
*3 serizaible readable level +lock strategy on teh rows which satisy condidtion

Note:0 level have more consistency control than the 1
we csan set the transaction isolation level 


optimistic means avove readable means the read uncommite and read committed
and pessimistic is below
opt concc and consistency is gh
pess is low
in opt deadlock cant be possible but in the pess deadlock can be possible


Optimistci
trans a                                                                                                         trans b                        db
read and lock release version same                                                                              read and lock release
update put exclusive lock and validate if before vrsion and now row versio same than update tran complete
                                                                                                                update valid fais rollback

So its concurrency high

Pessismist
trans a                                                                                                         trans b                        db
read and lock  version same                                                                              read a
update put exclusive lock and validate if before vrsion and now row versio same than update tran complete
                                                                                                                update  no as exclusive lock is lraevalid fais rollback
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Sprinboot  transaction

*Critical section is that pice of code wichis beging shared b multile user
*suppose critical section{car with i and sttaus as avaiable}
*multiple users come and want to access this resource and update the stats booked
*If its not taken care properly then the data inconsistency can appen
*

So to help ere is e can make use of the transaction
*So here transction helps to achieve the acid property
*here a stands for the atomiticity which says that if any operation fails than the whole transactio will get rollback
*c stands for the onsistency which says befoe the transaction and afer the transactin my db must be consistent
*i stands for the isolation it means when many transactions are running in parallel than they donot interfere with each other
*d stands for the durability means if one transaction is committed it will become pesristsnec event after any system failure

*So basically we have many methods in repo which are touching the db and there we need to write begin transaction than operation than comit if suces
*So lot of duplicated code in all method with just change in business logic
*So we use the @transaction annotation

We need to add certainer dependency
1.we need relation db then spring boot starter data jpa
2.database driver and its password in the app.properties

*@Transaction can be applied at the class level and method level
*if applied to class it will be applied to all the public methods butnot private method
*if applied to particular method it will be applied to that particular method only
*Tranaction behind the scene uses aop
*So all the transaction code exclusind the business logic is beging handled by the aop class and inside aop wehav the pontcut expression which execute advice method before the joint point
*and pointcute expression is written as @within(expression(org.springframworg.transactionannottaion)
*It means it will lokk or all pacakges and all class and all method with @transaction nnaottaion
*Ifmatch found than the advice is run with type as aroud
*package com.example.aspect;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class LoggingAspect {

    // Define pointcut expression
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void allServiceMethods() {}

    // Apply advice to pointcut
    @Before("allServiceMethods()")
    public void logBeforeServices() {
        System.out.println(">>> Logging BEFORE any service method");
    }
}
here it says that in service folder befr all methods ru advice logbefore service



*so flow is like usercontroller{
@autowired User user

@getmapping updateuser()
{
user .update()
}
}


class user
{
@transaction 
updateuser()
}
*Now firts the class aop will run behin dfind trnasactin aannotaion yes find match then it will invoke the invokewithin transaction aspect method inside aop where the code for begin transaction is here and then we call finally or update user method
*----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*Transaction manager is bsiaclly an parent interface
*Platform transaction manager is interface that extends the transaction manager interface and has 3 abstract methods they are the commit,rollback,gettransaction
*than one abstarct class implemenst the platform transaction manager called abstracttansaction mamager and provide the implementation of the 3 method
*Then we have many concrete classes of the abtarcttransactionamanger and these are the datasourcetransactionmanager,hibernatetransaction manager ,jpa transaction manager and jta


Types of transaction managemenet:
1.declarative:here transaction managemnet takes place with the help of annotataions
Springboot will choose the trsnacation manager by itself
*We can create our own datasource manager and ask springboot to take it
*

2.Programatic
*so we need to wrte th code without annottaion 
*so we can see we use the programmatic suppose in method we have the update db,external api call,then update the db
*So this call can take many seconds and connection to db is on also so here api call is bottleneck here we ill code manaullay
*import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.stereotype.Service;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;

@Service
public class PaymentService {

    @Autowired
    private JpaTransactionManager transactionManager;

    @PersistenceContext
    private EntityManager entityManager;

    public void processPayment() {
        // Define transaction attributes
        TransactionDefinition def = transactionManager.getTransactionDefinition();

        // Start transaction
        TransactionStatus status = transactionManager.getTransaction(def);

        try {
            // Business logic (DB ops)
            System.out.println("Processing payment...");
            // entityManager.persist(...);

            // Commit transaction
            transactionManager.commit(status);

        } catch (Exception ex) {
            // Rollback transaction
            transactionManager.rollback(status);
            throw ex;
        }
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Transactio propagation
*How the transaction will be propagated to other methods that will be decided by the transaction propagation
*suppse we have the mthod that calls another ethod with annotation asthe transactional
*
üîπ What is Transaction Propagation?

When a method annotated with @Transactional calls another method (also transactional), propagation decides whether the second method will:

Join the existing transaction

Run in a new one

Run without any transaction

üîπ Types of Transaction Propagation in Spring

Spring defines 7 propagation types (from TransactionDefinition):

1. REQUIRED (Default)

üëâ If a transaction exists, join it. If not, start a new one.

@Transactional(propagation = Propagation.REQUIRED)
public void methodA() {
    // Will join current transaction if available, else create new
}

Example:
@Service
public class ServiceA {
    @Transactional
    public void methodA() {
        System.out.println("Inside methodA");
        serviceB.methodB(); // methodB also REQUIRED
    }
}

@Service
public class ServiceB {
    @Transactional(propagation = Propagation.REQUIRED)
    public void methodB() {
        System.out.println("Inside methodB");
    }
}


‚úÖ Both run in one transaction.
If methodB fails ‚Üí rollback affects methodA too.

2. REQUIRES_NEW

üëâ Always starts a new transaction, suspending the current one.

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void methodB() {
    // Always new transaction
}

Example:

methodA() has a transaction.

methodB() is called with REQUIRES_NEW.

Now: methodB() has its own independent transaction.

If methodB() fails, it rolls back only itself, not methodA.

3. SUPPORTS

üëâ If a transaction exists, join it. If not, run without one.

@Transactional(propagation = Propagation.SUPPORTS)
public void methodC() {
    // Run in transaction if available, else non-transactional
}


Good for read-only operations.
4.NOT_SUPPORTED
means ru without trnsaaction

5.MANDATORYs
*mans the inner method will ow execption if the outre function does not have the transaction vcreated or transactional anottaion
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Isolation level
*we have 2 transactin runnin in paralle and how change made in one transaction can e reflected by other
*@Transactional(
    propagation = Propagation.REQUIRED, 
    isolation = Isolation.READ_COMMITTED
)

Note:default isolation level depends on which db u are using
*Mostly db uses the read committed
*----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Multithreading,thread pools and threadpool executor and java multithreading->future ,callable and Completable future


Multithreading
*Process is the instance of programme that is being executed
*Suppose we have the programme as the Test.java
*Then we compile javac test.java it will give bytecode
*now wehen we execute the file using java test and jvm is executing that he new process is created
*Each time the process is created than they have their ownmemeory and does not are any memory with other processa 
*So everytime the process is created that means the jvm instance is created and and given to the process and jvm instance contains the heap stack memory,so much memeory this jvm instnac will take we can define by
java -Xms15g test
 


Thread
*It is lightweight process
*the most important thing is we convert bytecode into achine code and this machine code is executed independenly so thread is he samllest unit of instruction executed by the cpu independently
*when the process is created than it as only one thread called the main thread an from this thread many tread can be made concurrently
*A processs can have many thread


Note:for each thread in the process they have each their register,stack ,counter
*Heap emory from jvm instance per process is ahred by all thread in process and data segment too
*data sement contains the global variable and static variables
*Note:In Java:

MyClass obj = new MyClass();


Compile Time:

The compiler only checks syntax and ensures that the constructor exists.

No object is created yet.

Runtime:

The new keyword is executed.

Memory is allocated on the heap.

The constructor of MyClass is called.

The reference (obj) points to that object.
*So when obect is created in thread v cxusing new memory is allocated in heap for each thread
*and this heap memory is shared by all thread within a process
*Each thread has its own stack and t maintains the method calss and local variable inside the methos
*now each tread has its own register alos so when cpu is running any thread and another thread come and it will store all the completeion stage of the partial thread in thread register and run new thread
*then its called context switching
*

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Async in springboot
*Threadpool
*Thraedpool is collection of thread which are available to perform the submitted tasks
*Once tak is comleted worked thread goes to the threadpool for the new taskto assign
* ThreadPoolExecutor executor = new ThreadPoolExecutor(
                2,                       // corePoolSize (min threads)
                4,                       // maximumPoolSize (max threads)
                10, TimeUnit.SECONDS,    // keepAliveTime for idle threads
                new ArrYBlockingQueue<>(2), // workQueue with capacity 2
                Executors.defaultThreadFactory(), // default thread factory
                new ThreadPoolExecutor.AbortPolicy() // rejection handler
        );


@async annootaion is used on method that should run asynchronously
*It means it will run on the new thread without blocking the main thread
*import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping("/hit")
    public String hitEndpoint() {
        System.out.println("Controller thread: " + Thread.currentThread().getName());
        userService.asyncMethod(); // async call
        return "Request received, processing async!";
    }
}

*import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    @Async
    public void asyncMethod() {
        System.out.println("Executing asyncMethod in thread: " + Thread.currentThread().getName());
        try {
            Thread.sleep(2000); // simulate work
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        System.out.println("Finished asyncMethod in thread: " + Thread.currentThread().getName());
    }
}

*everytime we hit we get ne thrda for the asyncmethod
*so if rrun above code only 8 tim new thread is reated
Case 1:So first when application start check if we have provide threadpool executor or not ,if not then it provides its own deafultthreadpooltaskexeceutor
*with thread pool size of 8 that why 8 new thread were created

*
*But creating defaultthreadpooltaskexecutor is wrong as here queue size is so big that task remais there and new thread is not created
*high latency
*thread exhaustion

Case 2 if we give our own threadpooltask executor
*import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import java.util.concurrent.Executor;

@Configuration
public class AsyncConfig {

    @Bean(name = "myThreadPoolTaskExecutor")
    public Executor myThreadPoolTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(2);          // minimum threads
        executor.setMaxPoolSize(5);           // max threads
        executor.setQueueCapacity(10);        // queue size
        executor.setThreadNamePrefix("MyPool-");
        executor.initialize();
        return executor;
    }
}

import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    @Async("myThreadPoolTaskExecutor")  // use custom executor
    public void asyncMethod() {
        System.out.println("Running asyncMethod in thread: " + Thread.currentThread().getName());
        try {
            Thread.sleep(2000); // simulate work
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        System.out.println("Completed asyncMethod in thread: " + Thread.currentThread().getName());
    }
}

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping("/hit")
    public String hitEndpoint() {
        System.out.println("Controller running on: " + Thread.currentThread().getName());
        userService.asyncMethod();  // async call
        return "Async request submitted!";
    }
}

Note:if in both cases we provide the @aysnc and aour custo threadpoolexecuor tahn springboot will use our if we provide string with @async annottaions or not
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Condidtion for the @async workproperly
1.te method on which async is being applied shuld in diffrenet clas from whre it is called
2.Thn method should be public 

*suuprt we hva ene tread wit the @transaction calling another method whichha asunc in aother class
*then the new thread deos not get the transaction context from the caller method
Note:so industry standard is the first caaler methd has async 
*then alled method has @transactional



now to have the result from this async method thread
*import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.AsyncResult;
import org.springframework.stereotype.Service;

import java.util.concurrent.Future;

@Service
public class UserService {

    @Async
    public Future<String> asyncMethod() {
        System.out.println("Async method running in thread: " + Thread.currentThread().getName());
        try {
            Thread.sleep(2000); // simulate work
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        return new AsyncResult<>("Hello from async method!");
    }
}

*import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;

@RestController
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping("/api/hit")
    public String hitEndpoint() throws ExecutionException, InterruptedException {
        System.out.println("Controller thread: " + Thread.currentThread().getName());

        Future<String> futureResult = userService.asyncMethod();

        // Here we wait for the async task to complete
        String result = futureResult.get();  // blocks until result is ready

        return "Result from async: " + result;
    }
}
*so hre on get it will block the main thread until and unless the result is retrievevd from the new thread

import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

import java.util.concurrent.CompletableFuture;



2.

@Service
public class UserService {

    @Async
    public CompletableFuture<String> asyncMethod() {
        System.out.println("Async method running in thread: " + Thread.currentThread().getName());
        try {
            Thread.sleep(2000); // simulate work
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        return CompletableFuture.completedFuture("Hello from CompletableFuture async method!");
    }
}

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

@RestController
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping("/api/hit-future")
    public String hitCompletableFutureEndpoint() throws ExecutionException, InterruptedException {
        System.out.println("Controller thread: " + Thread.currentThread().getName());

        CompletableFuture<String> futureResult = userService.asyncMethod();

        // Block and wait for result
        String result = futureResult.get();

        return "Result from async: " + result;
    }
}

Note:here on get it will not block the main thread
*


exception handling strategies for async methods in Spring:
*import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

import java.util.concurrent.CompletableFuture;

@Service
public class UserService {

    @Async
    public CompletableFuture<String> asyncMethodWithError() {
        System.out.println("Async running in: " + Thread.currentThread().getName());
        if (true) {
            throw new RuntimeException("Boom! Something went wrong.");
        }
        return CompletableFuture.completedFuture("Success");
    }
}
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.concurrent.CompletableFuture;

@RestController
public class UserController {

    private final UserService service;

    public UserController(UserService service) {
        this.service = service;
    }

    @GetMapping("/api/future-exception")
    public CompletableFuture<String> callFuture() {
System.out.println("Controller thread: " + Thread.currentThread().getName());

        CompletableFuture<String> futureResult = userService.asyncMethod();
try
{
        // Block and wait for result
        String result = futureResult.get();
}catch(){
}


        
    }
}
Note:when we call get method we can catch in main method




2.But when it return the void than 
we can use try catch in the async ,ethod
by default if we springboot code than the uncaughtexceptionhandler class is implemented and handleuncughtcexception is being ovveriden by default but we can create our custom one by 

import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;

@Component
public class CustomAsyncExceptionHandler implements AsyncUncaughtExceptionHandler {

    @Override
    public void handleUncaughtException(Throwable ex, Method method, Object... params) {
        System.err.println("‚ö†Ô∏è Exception in async method: " + method.getName());
        System.err.println("Message: " + ex.getMessage());

        if (params != null) {
            for (Object param : params) {
                System.err.println("Param value: " + param);
            }
        }
    }
}


import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.AsyncConfigurer;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import java.util.concurrent.Executor;

@Configuration
public class AsyncConfig implements AsyncConfigurer {

    private final CustomAsyncExceptionHandler customHandler;

    @Autowired
    public AsyncConfig(CustomAsyncExceptionHandler customHandler) {
        this.customHandler = customHandler;
    }

    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(2);
        executor.setMaxPoolSize(5);
        executor.setQueueCapacity(10);
        executor.setThreadNamePrefix("MyPool-");
        executor.initialize();
        return executor;
    }

    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return this.customHandler;
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Springboot interceptor
*So what happens suppose users send reuest with userid as numeric
*now db store data in uuid only
*so in controller first from the mapper<number,uuid>
*Its found whats uuid and than stored
*Now suppose we have thousand controller so we need to do this in each controller
*So its not feasible
*So is there any way that before reaching the controller making use of mapper we can find tat uuid and pass request to the controller
*Now interceptors is one which is pleaced before the controllers
*Handler interceptor is an interface which allows the interceptor in our application
*so we will implement the handleinterceptor 
*and override the methods gethandle posthandle and aftercompletion
*So basically the gethandle is called when requrest come from user changes made and served to controller
*post vice versa
*Now to register this custominterceptor we make config app config
*and there implemnets webmvcconfigurere
*and there in app config override add interceptor 


üîπ Step 1: Create Custom Interceptor

You extend HandlerInterceptor and override its lifecycle methods:

import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

@Component
public class CustomInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        System.out.println("üîπ preHandle: Before Controller method, URL = " + request.getRequestURI());
        return true; // if false, request will not proceed to controller
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response,
                           Object handler, ModelAndView modelAndView) {
        System.out.println("üîπ postHandle: After Controller method, before view rendering");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,
                                Object handler, Exception ex) {
        System.out.println("üîπ afterCompletion: After view rendered, request fully completed");
    }
}

üîπ Step 2: Register Interceptor in Config

Create a config class that implements WebMvcConfigurer:

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class AppConfig implements WebMvcConfigurer {

    private final CustomInterceptor customInterceptor;

    @Autowired
    public AppConfig(CustomInterceptor customInterceptor) {
        this.customInterceptor = customInterceptor;
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(customInterceptor)
                .addPathPatterns("/api/**"); // apply to specific endpoints
    }
}

üîπ Step 3: Controller for Testing
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class UserController {

    @GetMapping("/api/test")
    public String testInterceptor() {
        System.out.println("‚ö° Inside Controller method");
        return "Hello from Controller!";
    }
}

üîπ Expected Logs When Hitting /api/test
üîπ preHandle: Before Controller method, URL = /api/test
‚ö° Inside Controller method
üîπ postHandle: After Controller method, before view rendering
üîπ afterCompletion: After view rendered, request fully completed


‚úÖ Flow recap:

preHandle() ‚Üí runs before controller (good for auth, logging, etc.).

postHandle() ‚Üí runs after controller, but before view is rendered.

afterCompletion() ‚Üí runs after view rendering, useful for cleanup and logging exceptions.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
HATEOS restful apis
*hateos api tells client whats the next step the client should perform
*suppose we have the post api->user unverified now w can get users or 
*delete user
*or verif
in verify we can verify by sms or verify by the email
*without hateos on poas response is {
  "userId": 101,
  "username": "john_doe",
  "status": "UNVERIFIED"
}

*with hateos its like the {
*{
  "userId": 101,
  "username": "john_doe",
  "status": "UNVERIFIED",
  "_links": [{
    "self": {
      "href": "/users/101"
    },
    "verify-sms": {
      "href": "/users/101/verify/sms"
    },
    "verify-email": {
      "href": "/users/101/verify/email"
    },
    "delete": {
      "href": "/users/101"
    }
  }
}]


WHy to use the hateos is loose coupling and api discovery
*
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Response and response codes
*Response generally contains the 3 parts
*status codes generally 200,500
*Header is the extra information and its optional
*Body means what you need to sent in reposne 
*We can use he generis ResponseEntity<T> where t is the type e wi sent in respose body
*import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class UserController {

    @GetMapping(path = "/get-user")
    public ResponseEntity<String> getUser() {
        HttpHeaders headers = new HttpHeaders();
        headers.add("My-Header1", "SomeValue1");
        headers.add("My-Header2", "SomeValue2");

        return ResponseEntity
                .status(HttpStatus.OK)
                .headers(headers)
                .body("My Response body Object can go here");
    }
}
*here the note body is the last because the sttaus and headers return the bodybuilder object whereas the body returns actual ResponseEntity
*Now if i dont want to send the respone than use the return ResponseEntity
                .status(HttpStatus.OK)
                .headers(headers)
                .build()
*Now if i send the@GetMapping(path = "/get-user")
    public User getUser() {
      User u=new User()

        return User
    }
*then the by default it will wra like ReponseEnity user means in body user will be there
*by default it will go200k
*Response Code:so 1xxx is basically the intrim response measn it just informational
*2xxx measn success 
*3xxx means the Rediection
*Validatio error menas cliethadnt ent orect ata
*500 servre failure


200 codes
1.200k measn the its successful,used in get and post,in et it measn request sent and receive the response wheras the post measn i duplicatd thn not added in db just he same row returned
*201 created,measn post request is successful and new resource is been added
*202 accepted measn post request ccepted buttherad re running
*204 no content means for delte we useand it sys request accepted and and we re nt sendig any data in response body
*206 partialcontent mean post request is partiall successful mens 500 ulk addition measn 40 successful rest faile


300 redirection
*301 moved permanently says when we migrate from old api to new api so on olde get request we say reponse attaus as 302 and in the header location we send the new url
now clinet automatically ffind got to locationa nd move to new url
*import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class RedirectController {

    // Old API endpoint
    @GetMapping("/old-api")
    public ResponseEntity<Void> redirectToNewApi() {
        HttpHeaders headers = new HttpHeaders();
        headers.add("Location", "/new-api"); // redirect target (relative or absolute URL)
        
        return ResponseEntity
                .status(HttpStatus.301) // 302 Found
                .headers(headers)
                .build();
    }

    // New API endpoint
    @GetMapping("/new-api")
    public String newApi() {
        return "Welcome to the NEW API!";
    }
}

*308 permanat redirect means while calling final api http method are not changed if its get its get and if its post than its post
*304 not modified clinet sent the request servier response with last modifier data clinet store it and send again call with this in header if resource s mdified than request is processed otherwise cache data is returnrd,Please do not use it with patch uses when client is using the cacahe
*


400 request when clinet hadn't sent valid details
*400 bad request when clinet missed out some fields
*401 unauthorized when api which require authentication and we are accessing it without token than 
*403 forbidden when the admin can only perform the operations but when api other than admin invoe
*404 not fond means requested resource not found
*405 method not allowed means post with get so this


500 means error at server
*500 internal server error
502 bad gateway means that the suppose nginx try to talk to application but not succesfull than 502 gateway


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Spring boot exception handling
*first is dispatcherservlet 
*so any exception occurs in controller so first it goes to handlerexceptionreolsver classs
*handlerexceptionreolsver its basically an orchestrator
*so it has 3 flowr 
*excetionhandlerexceptioonresolver  class
*responsestatusexceptionresolver class
*Defauthandlerexceptionresolver
*Now before erching out to the an of th flow its checke that the i exception handled or not if yes hen move to defaulterror attribute else move to the exception flow
*package com.example.demo.controller;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;

@RestController
@RequestMapping("/api")
public class DemoController {

    // Example: GET /api/test
    @GetMapping("/test")
    public String testApi() {
        // Instead of returning a normal response, throw Bad Request
        throw new Exception(
                HttpStatus.BAD_REQUEST, "Something went wrong with your request"
        );
    }
}
*so here we will still see 500 in postman
*because w are just theoing we are not rturnig in reeposne enityty
*any other object is doung that and it mena sour class is oing through all flow nd if not handlef goto default attribute and whih add the status as 500
*butwe wn or exeption shoud nt be handle by andlerexception class then wrap it in the response entity 
*package com.example.demo.exception;

import org.springframework.http.HttpStatus;

public class CustomException extends RuntimeException {
    private final HttpStatus status;

    public CustomException(HttpStatus status, String message) {
        super(message);
        this.status = status;
    }

    public HttpStatus getStatus() {
        return status;
    }
}
package com.example.demo.exception;

import java.util.Date;

public class ErrorResponse {
    private Date timestamp;
    private String message;
    private int statusCode;

    public ErrorResponse(Date timestamp, String message, int statusCode) {
        this.timestamp = timestamp;
        this.message = message;
        this.statusCode = statusCode;
    }

    public Date getTimestamp() {
        return timestamp;
    }

    public String getMessage() {
        return message;
    }

    public int getStatusCode() {
        return statusCode;
    }
}

package com.example.demo.controller;

import com.example.demo.exception.CustomException;
import com.example.demo.exception.ErrorResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Date;

@RestController
@RequestMapping("/api")
public class UserController {

    @GetMapping("/get-user")
    public ResponseEntity<?> getUser() {
        try {
            // Your business logic and validations...
            throw new CustomException(HttpStatus.BAD_REQUEST, "UserID is missing");

        } catch (CustomException e) {
            ErrorResponse errorResponse =
                    new ErrorResponse(new Date(), e.getMessage(), e.getStatus().value());
            return new ResponseEntity<>(errorResponse, e.getStatus());

        } catch (Exception e) {
            ErrorResponse errorResponse =
                    new ErrorResponse(new Date(), e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR.value());
            return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
}




Exceptionandlerexeptioresolver is usefulfor handling the annotation s@exceptionhandler and @controlleradvice
*Nice üëç now you‚Äôve shown the version where instead of wrapping try‚Äìcatch inside the controller, the code uses @ExceptionHandler
package com.example.demo.controller;

import com.example.demo.exception.CustomException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class UserController {

    @GetMapping("/get-user")
    public ResponseEntity<String> getUser() {
        // Business logic + validations...
        throw new CustomException(HttpStatus.BAD_REQUEST, "UserID is missing");
    }

    // This method will handle only CustomException
    @ExceptionHandler(CustomException.class)
    public ResponseEntity<String> handleCustomException(CustomException ex) {
        return new ResponseEntity<>(ex.getMessage(), ex.getStatus());
    }
}
so in his controller we hav nay method throwing custome exception that will be handled by exception handler methd handeCustomexecption
*so in the body we hav the usrid misiing it just string and status is 400 ba drequest
*at the global level we male class with controller adviic than the xecption handle
*More priority is being given to exception handler at the controller level
package com.example.demo.exception;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@ControllerAdvice  // applies globally to all controllers
public class GlobalExceptionHandler {

    @ExceptionHandler(CustomException.class)
    public ResponseEntity<String> handleCustomException(CustomException ex) {
        return new ResponseEntity<>(ex.getMessage(), ex.getStatus());
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleGenericException(Exception ex) {
        return ResponseEntity.internalServerError()
                .body("Something went wrong: " + ex.getMessage());
    }
}




2.REsponseStatusexecption 
*handle uncaught exception annotaied with @rsponsesttaus exception
*package com.example.demo.controller;

import com.example.demo.exception.CustomException;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class UserController {

    @GetMapping("/get-user")
    public ResponseEntity<String> getUser() {
        // Business logic + validation
        throw new CustomException("UserID is missing");
    }
}

*package com.example.demo.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.BAD_REQUEST) // sets status to 400 automatically
public class CustomException extends RuntimeException {

    public CustomException(String message) {
        super(message);
    }
}
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Spring data jpa
*jpa is basically an interface
*It provies the api through which we can intercat with
*implementation is provided by the hibernate
*then we have jdbc which is also an interace an ts methods are implemented by the database
*so orm framework that consisist of jpa nd hibernate is a  bridg ebwteen java object and the database 

so jdbc connncetion without springboot 1. DatabaseConnection.java
package com.example.demo.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class DatabaseConnection {

    public Connection getConnection() {
        try {
            // Load H2 Driver
            Class.forName("org.h2.Driver");

            // Establish connection with H2 in-memory database
            return DriverManager.getConnection(
                    "jdbc:h2:mem:userDB", "sa", ""
            );

        } catch (ClassNotFoundException | SQLException e) {
            e.printStackTrace();
        }
        return null;
    }
}

2. UserDAO.java
package com.example.demo.jdbc;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;

public class UserDAO {

    // Create user table
    public void createUserTable() {
        String sql = "CREATE TABLE users (id INT AUTO_INCREMENT PRIMARY KEY, " +
                     "username VARCHAR(255), " +
                     "email VARCHAR(255))";

        try (Connection connection = new DatabaseConnection().getConnection();
             Statement statement = connection.createStatement()) {

            statement.executeUpdate(sql);
            System.out.println("Users table created successfully.");

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    // Insert user into table
    public void createUser(String userName, String email) {
        String sqlQuery = "INSERT INTO users (username, email) VALUES (?, ?)";

        try (Connection connection = new DatabaseConnection().getConnection();
             PreparedStatement preparedQuery = connection.prepareStatement(sqlQuery)) {

            preparedQuery.setString(1, userName);
            preparedQuery.setString(2, email);

            preparedQuery.executeUpdate();
            System.out.println("User inserted successfully.");

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

3. Main.java (for testing)
package com.example.demo.jdbc;

public class Main {
    public static void main(String[] args) {
        UserDAO userDAO = new UserDAO();

        // Create the table
        userDAO.createUserTable();

        // Insert sample users
        userDAO.createUser("Alice", "alice@example.com");
        userDAO.createUser("Bob", "bob@example.com");
    }
}

How it works

DatabaseConnection loads H2 driver and connects to an in-memory DB (jdbc:h2:mem:userDB).

UserDAO provides methods to create a table and insert users using plain JDBC (Statement and PreparedStatement).

Main demonstrates usage.

When you run Main, you‚Äôll see:


Here lot of bilercode like
*driver class loading
*db conncetion making
*exception handled is very parent like  or abstracted


So jdbc with springboot is
*in pom.xml we have the springboot starter jdbc
*h2
*So we create the @repository and it give the granular exception
*and here too in this we willk autowired the jdbctemplace classs which will reduce the boilerplate code
*and make the service fro create table and insert user
*an dthen in app.properties we have spring.datasourec.url and all other stuff url,driverclassname,username,password,enabled
*


so 
*jdbc template class loads the driver class as and when application starts
*Conncetion is being invoked when we run any query
*exception handling at the granular level
*springboot itself handles theclosing of the connection
*default connection pool is hikai cp
*and its default min and max size is 10
*various methods in jdbc templace class are
*1.update(sql query,args)->used for insert,update,delete
2.update(sql,(PeparedStatement ss)->ps.setstring(index,value)
})
3.querey(select * from employee,(row)->{
User u=new User
u.setint(rs.getrollno)
})
*queeryforlist when we want to getch one column
*----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*jpa is an interface 
*it give speceification to rovide connection to db following the orm principles
*jpa architecture and entitylifecycle
*enity is an object that maps to table  in the db
*Entitymanager is an interface which managesthe entity
*Irt pereform operations on the entity
*Entitymanager factory is reposnible for creating the enity manager
*Persistence ceates the entitymanagerFactory
*now persistence context is an accahe like storage which wlllstore all the entities and enityy manager interacts with this persistence context*
*now when we hit sve on enetity manager it willoffload operation fo db on the hibernate provide and hibearnate uses its query to do db oerations
*


Various states of the entity are
*transient-as soon as we create entity it wil be ein transient state
*and its not managed by the entity manager
*as soon as we call persis on enetity is managed by the enetitymanager
*and then enetity will be in manage stste
*when state is managed than persistence contet stores the managed entities
*when we make any changes in enetityin amanged state then it will be directly interacting with db so if we do flush changes will be saved in db
*Entity in detached state when its no longer amnged by the persistence context
*If we want enetity to be in the managed state we can do the merge()
*
*
transisnet->persiste->call persist
removed to persistent-.>call persist
persistenc to detach call detach()
then detach to persistenc call merge
persistent to remove call remove()
*----------------------------------------------------------------------------------------------------------------------------------------------------------------------
spring data jpa impelmenttaion
*so in spring initilazer
*spring web
*spring data jpa
*h2 database
*so create enity than @enity annaoation and on id @id to make it as primary key @generatedvalue (strategy=generationtype.auto)
*we have 3 types of repos
1.crud repository
*so lets implemenst 
*make class then the interface applicationerpo extends crudrepository<Applicant,Long>means here the entty name and data type of the primary key
*and use this repo in the service @autowired the repository
*and then the repo.save(applicant)
*import org.springframework.data.repository.CrudRepository;

public interface ApplicantRepository extends CrudRepository<Applicant, Long> {
}
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class ApplicantService {
    @Autowired
    private ApplicantRepository repository;

    public Applicant saveApplicant(Applicant applicant) {
        return repository.save(applicant);
    }
}





2.Pagingandsorting repo xtends the crud repository
*they have pagination,sortingand the crud operations
*so for this in service make methods as getapplicantwith pagination(int page,int size)
{
repository.findall(Pagerequest.of(page,size)
}
*and we can pick the page andsize bythe reuestparams
*
Note:i latest spring versio now 
*so for now the paging dont extends the crud crud exyends the repository and the pagingandsroting extends the repo
*listcrud extend crudrepo and listpagingand sorting extends the pagingandsorting
*Note:Benefit of listcrud is now the itearable isnit returnd by findall the list o the enityt is returned by te findall method
*In latest paging does not support crud operations
*import org.springframework.data.repository.PagingAndSortingRepository;

public interface ApplicantPageRepository extends PagingAndSortingRepository<Applicant, Long> {
}

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;

@Service
public class ApplicantPageService {
    @Autowired
    private ApplicantPageRepository repository;

    public Page<Applicant> getApplicantsWithPagination(int page, int size) {
        return repository.findAll(PageRequest.of(page, size));
    }
}
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.data.domain.Page;

@RestController
public class ApplicantController {
    @Autowired
    private ApplicantPageService service;

    @GetMapping("/applicants")
    public Page<Applicant> getApplicants(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "5") int size) {
        return service.getApplicantsWithPagination(page, size);
    }
}


3.jpa repository supports the batch operations
*custom query methods
*Here it extends the listpagingandsorting repository and listcrud repo
*here suppose of i want get applicant by statsu so its customquerymethod  so in repository extends jpa we will make mrtodgte bystsays and pass the status as param
*and also by if suppose we want the applicat by first name so here we have no query method we can implement like find byname so we @	q	ueryAnnotaion and write query in itr 
*import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import java.util.List;

public interface ApplicantJpaRepository extends JpaRepository<Applicant, Long> {
    
    // Derived query method
    List<Applicant> findByStatus(String status);

    // Custom JPQL query
    @Query("SELECT a FROM Applicant a WHERE a.firstName = :name")
    List<Applicant> getApplicantsByFirstName(@Param("name") String firstName);
}

*----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Spring data jpa one to ne relationship
*for one to one we have one applicat and one resume
*now the one applicant have one id and that will be fk in resume
I*so in resume make applicat id as thefk by the @joincolumn and give name as pplicant id and nullable as false
*import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToOne;

@Entity
public class Resume {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String filePath;

    @OneToOne
    @JoinColumn(name = "applicant_id", nullable = false) // FK column
    private Applicant applicant;

    // getters and setters
}
if i use this then the it will create application in esume and if we want the bidirectional then the 
*import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToOne;

@Entity
public class Resume {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String filePath;

    @OneToOne
    @JoinColumn(name = "applicant_id", nullable = false) // FK column
    private Applicant applicant;

    // getters and setters
}

*


Unidirectional
*Unidirectional One-to-One Example
Applicant (no reference to Resume)
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class Applicant {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String firstName;
    private String status;

    // No @OneToOne here

    // getters and setters
}

Resume (owns the relationship with FK)
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToOne;

@Entity
public class Resume {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String filePath;

    @OneToOne
    @JoinColumn(name = "applicant_id", nullable = false)  // foreign key column
    private Applicant applicant;

    // getters and setters
}

What will DB look like?

applicant table ‚Üí just applicant data.

resume table ‚Üí has a applicant_id column (FK, NOT NULL).

Save Example
@Autowired
private ApplicantRepository applicantRepo;

@Autowired
private ResumeRepository resumeRepo;

public void saveApplicantWithResume() {
    Applicant applicant = new Applicant();
    applicant.setFirstName("Neha");
    applicant.setStatus("Active");
    applicantRepo.save(applicant);

    Resume resume = new Resume();
    resume.setFilePath("/files/resume.pdf");
    resume.setApplicant(applicant);
    resumeRepo.save(resume);
}


‚úÖ Use unidirectional mapping when:

You only ever need to navigate from Resume ‚Üí Applicant,

You want to keep the model simple and reduce unnecessary bidirectional complexity

*Now in bidirectional suupose on post of the application i gave resume:{}
then run then 500 error
because here it says save resume first then applicant 
*so now import jakarta.persistence.*;

@Entity
public class Applicant {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String firstName;
    private String status;

    @OneToOne(mappedBy = "applicant", cascade = CascadeType.ALL)  
    private Resume resume;

    // getters and setters
}
@Autowired
private ApplicantRepository applicantRepo;

public void saveApplicantWithResume() {
    Applicant applicant = new Applicant();
    applicant.setFirstName("Neha");
    applicant.setStatus("Active");

    Resume resume = new Resume();
    resume.setFilePath("/files/resume.pdf");

    // link both sides
    applicant.setResume(resume);
    resume.setApplicant(applicant);

    // only save applicant ‚Äî resume will also be persisted
    applicantRepo.save(applicant);
}




























import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.persistence.*;

@Entity
public class Applicant {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String firstName;
    private String status;

    @OneToOne(mappedBy = "applicant", cascade = CascadeType.ALL)
    @JsonIgnoreProperties("applicant")  // prevents infinite recursion
    private Resume resume;

    // getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getFirstName() { return firstName; }
    public void setFirstName(String firstName) { this.firstName = firstName; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public Resume getResume() { return resume; }
    public void setResume(Resume resume) { this.resume = resume; }
}
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.persistence.*;

@Entity
public class Resume {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String filePath;

    @OneToOne
    @JoinColumn(name = "applicant_id", nullable = false)
    @JsonIgnoreProperties("resume")  // prevents infinite recursion
    private Applicant applicant;

    // getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getFilePath() { return filePath; }
    public void setFilePath(String filePath) { this.filePath = filePath; }

    public Applicant getApplicant() { return applicant; }
    public void setApplicant(Applicant applicant) { this.applicant = applicant; }
}
import org.springframework.data.jpa.repository.JpaRepository;

public interface ApplicantRepository extends JpaRepository<Applicant, Long> {}
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class ApplicantService {

    @Autowired
    private ApplicantRepository applicantRepo;

    public Applicant saveApplicant(Applicant applicant) {
        // set bi-directional relationship
        if (applicant.getResume() != null) {
            applicant.getResume().setApplicant(applicant);
        }
        return applicantRepo.save(applicant);
    }
}
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/applicants")
public class ApplicantController {

    @Autowired
    private ApplicantService service;

    @PostMapping
    public Applicant createApplicant(@RequestBody Applicant applicant) {
        return service.saveApplicant(applicant);
    }
}
ss
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------
Understandingattacks
*csrf
*its being doe when user is authenticated
*So basicalyit happnens when the attack tricks  browser to make unwanted rquest to a site where user is already authenticated
*Applicable where the session and state is manged 
*
*
*Suppoe we have the we say that every request must be authenticated
*so from login w get the session id and rowser store it  cookie
*now user makes the anoe request taking to rote and ten the browser attack session id automatically so its csrf attack
*so to solve this we s the srf token so that while teh form subiison thais csr token is snt in request from egitmates resource


xss
*cross site reqest scripting
*it make attackers to put malicious scripts in webpage inorder to gete the session id or deform teh website
*like in commnet section page
*so we hi post and write
*<script fatch(docymemt.cookie)
*so when he attacker get the all omment then he gets the cookies 
*So it can be perevneted by escaping the special caharcters from teh user input
*


cors 
*This is not attack its a security feature
*that prevent web pages to make request to difffrenet origin unlessa dn until allowed b the server
*difret origin means protocol+domain+port
*consider client is at https8080 and servet at http so they are different origin than cors errors
*so servre needs to allow this 
*by setting access control origin
*

sql
*where the user manipulate sqlqueries
*suppoe from param name we wrae inding usr with name =request params
*but the name="" or"1"=="1" so it will return all users
*hence its unsafe
*a user can use it to get the table name or db name or drop the tble
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Spring security architecture
*To prvenet from teh attacks
*we need to do 2 things that are 
1.authentication :means identify who u are
2.authorization ;what you can do
*so in teh springboot
*first request goes to tomcat the servlet container
*then goes to the filres chain  which consistens of many filers
*than in this filetr we hav one filter called the spring filter chain
*in sprin filetr chain we have mnay filters
*we hva ediffrent authentication method like the form based wher we pass the username and password and the stateless  we have the jwt and the oath or basic auth
*and for each authentication methid we hav ethe filter chain
*so request goes to security f iletr chain than through one filter than request goes to authentication mager which is interface adn itsimplemnet by provider manager
*so in rquest we hav the authenticate object
*and in the implemented class ther is logic to conncet filetr to authentication orvider
*like for the from based the provider is the daoauthenticationprovider nd for the jwt is jwtauthenticationprovider
*so for the daoauthenticationprovider we have the password encoder in which on registration password in encoded
*and then the there is userdetails service where the where we have the inmemorydetail managre where the usrenam nad pass storedin memory and jdbcdetailsmanager where username password storedin the db
*if authentication pass goes back to filter than if its success then storedin the security contect else 400 bad resquest given
*for the dependency we need to add the spring boot startere security
*
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*so we will make the class
with anntaion as enablwebsecurity(debug=true)
*and then the make it as ckass extends websecurityconfigurer adapter
*This class will help to create the secuiry filter chain
*inmemeory means in the tomcat hen the srver is tarted than the data is stored else its gone
*and in theis class we will override the configure methofs means here in this methods we are basically creating the users
*measn we are mapping the request to correct authenticator provider
*auth.inmemory().withinuser("neha").password().roles()
*but when login with this credentials than aerror
*as the it will show that the password is not encypted
*so we need to create the beans which return the passwordencoder object and there return new opsassrd.getinstance()
*no if we write the login usinga and password and username  its sccesfull
*Note:Noppassword encoder is used when we want to store password in the old plain text
*Note:here if we want store safely we should use the bycrypt password for that calcaultae the password for ayur123 as encytpted and put its value in .password("#$%%%!!1)
*Now if we login using ayur123 and its matcghd 
*so 
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                .authorizeHttpRequests(auth -> auth
                        .anyRequest().authenticated())
                .formLogin().and()
                .build();
    }

    @Bean
    public UserDetailsService userDetailsService(PasswordEncoder encoder) {
        var user1 = User.withUsername("admin")
                .password(encoder.encode("admin123"))
                .roles("ADMIN")
                .build();

        var user2 = User.withUsername("user")
                .password(encoder.encode("user123"))
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(user1, user2);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Form login authentication
*It is stateful authentication
*That means our serveris mainaing the state of clinet or user authentication stat also called the session
*so thatuser doe not need to provide the username and password with every request
*So flow is like that the first time the user providr username and password the server create session and store and return
*now when clinet maks the another reqest than the he provide the session only no username and password
*and server validates the session
*It si default authentication method
*so the first time the http session object is created and it stores the session id ,session created and expiry time and saves it in servlet
*in return the server send response by setting the cookie as jsession id set to session id
*then in further request clinet sends only the cookie with jsession id the servre find and validates if its active htttp session
*if found return response as fulfilled request
*If its invalid than redirect to the login page
*By default time to live for hhtp session is 30 min
*But we can configure it too server.servlet.session.timeout=1m
*now if in 1 min there is no activeity than session will expire if activity than reauthentocate and from that point session will  this session will increase
*
*and then the thing is that we can store session in db too
*


So in pom 
*spring session jdbc for storing the session in db
*in app.properties
*spring.session.store-type=jdbc
*spring.session.jdbc.initilaize-scheme=true
*server.servlet.session.timeout=1m
This will create automatically table for us called spring session table
*


Now the flow
*first request goes to the seceurity filter chain
*Then the usernamepasswordautheticationfilterchain
*than autehtication object created and pass to the authentication manager
*then provider manager implements the authentication manager which invokes the correct authentication provider called the daoautheticationprovider 
*which will first hash the password using bycrypt
*and then the from indetails manger the userdetails are feched
*now authentication provider valide the incoming useramed and hashed password with the stored username and the passowerd
*if validates than update the authentication oject witha ut=true and add the role and retur to the usernamepassowrd secutity filter chain than from there they are stored in security context and sent to httpsessionsecuritycontext repo
*so this repo will create new httpsession object and store the security context in athat object
*

Not autheticated
so first go to login than successful login that send the user to / page
*if first/sers then first login than redirect to users page
*
If authenticated
*then first request goes to security filter chain than the secuirtycontextholder filter than request sent to httpsessionrepo where the http session on based of session id is retrived
*if not find than redirect user to again login
*else'if found than return the security context object this objects gets store insecuritycontextholder filter and is is available in entire lifecyle of componenet
*and then further this it goes to authrizaton filter chain to validates if the user is authorized or not
*

*Now i want not authorize all request than in security filter chain  http
                .authorizeHttpRequests(auth -> auth
                        requestmatcher('/users').permitAll().anyRequest().authenticated())
                .formLogin().and()
                .build();

*Now authorization pahse first come in security filter chain and one at the controller
*lets have lookof auth at the security filter chain
*so here  .authorizeHttpRequests(auth -> auth
                        requestmatcher('/users').hasrole("ADMIN")anyRequest().authenticated())
                .formLogin().and()
                .build();
*setting manullay above
*

*How to control session per user
*we can control the session using.sessionmanagemnet(session->session.maximumsession(1)->so in one session user login file in another session user login than error

Diadvantages of the form based authentication
*csrf and session hijacking can be done
*by default csrf is ebable in form based auth we can undo also
*session management is big overhead and in case of distributed system 
*third issue is that the we need tostore the session idb whenmany session so memory require and lookup required and then the latency issue is there 
*----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Basic authentication 
*so whats happens is that the its stateless means server does not maintains the clinet state called the session
*so every time with the request we need to send username and pass in authorization headers-basic <encoded username and password>
*so as its encodes and hence insecure via http so use th https
*noe send the request/users than the authorization click basic and give username and password so in header we have the encoded username and password and hre ereuwst goes to the basicfilter in the security filter chain and in that we have logic of the decode
*

why we snd username and password in header
*hhtp documentary says ki username nad paswrd should go in the headers
*many webserver can log request body but cant header so thats why
*in pos and put body is ther but in the get no body so header is used

so here flow is simple just like the irts time call then goes to security filter chain than the basicauth filter where it decode header tah the authentication object send to authmanaher than authprovider than daoauthprovider where password is hased than from inmmeory valiadyio is done than authentication object updated then sedn store in securitycontextholder filter but no http session created
* @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                .authorizeHttpRequests(auth -> auth
                        .anyRequest().authenticated())
                .httpBasic().and()//small change here
                .build();
    }
*and also in sessionmanagemnet create policy makeit sttelelss and here csrf should be diable
*Diadvantages:
*hre if not https than the header can be decoded
*and also here we cant make the invalid credential we need to change it
*sending cred with every request is not good for the large scale application as it increases the header size
*----------------------------------------------------------------------------------------------------------------------------------------------------------------------
jwt is a secure way of transmitting the information between 2 parties  as json objects
*and it can be verified easily as this information is digitally signed using rsa or hmac
*so jwt is used for authentication,authrizationa nd sso
*jwt flow is a client make request to auth server means a 3rd party application which generate taojen and return token to client
*now the clinet send the token in auth header along with the request now tha mainserver internally calls the authentication server and check if this token generated by if true than return response to clinet


*Now the thing comes what was popular befor the jwt
*so before that we have login authentication where we qhit db every time giving problem in sdistributed syaytem and latency is too low
*so jwt token does not need db its sessionless it has toke
*token has 3 parts
header consists of metadata about tkone like type and algo ,algo can contains rsa or hmac
*payload store user iformation like iss,sub,aud,exp,nbf,iat,jti these all are registered clain we hve puvlic claim that can be understood by many main server and private claim that can understood by auth server when we are validating the jwt tokemn
*then signature we fit=rst encide the payload than signature than concatenate than create signature by applying rsa tahn again encoding it
*Now so its better than the login auth because here no db usage and better than basic as here header size is not large
*

But issue with jwt is toke invaliadation
*iww nt to blacklist the toke of fraud user
*so possible solution we can store the blaocklisting token in db but it again like session
*decrease the jwt expiration time
*use jwt once 
*as jwt is encoded so less secure we can use jwe
*now jwt is header auth:no that jwt meust be rejeceted and jwsi sheader with auth 
*Now in header a client can pass jwk aour sercre must not read this jwk which is public key so never use this public key
*now code for spring security 
websecurity there we write code for the security filter chaina nd the bycrypt password
*now i dont want to make beans for userdetails erveice which by default uses the inmemory i want the db
*so make class that implement userdetail service and override the loadbyusername methd that make repo call and find the user by username 
*@Service
@RequiredArgsConstructor
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        return userRepository.findByUsername(username).orElseThrow();
    }
}
*import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Entity
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Table(name = "app_user", indexes = {
        @Index(name = "idx_provider_id_provider_type", columnList = "providerId, providerType")
})
public class User implements UserDetails {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @JoinColumn(unique = true, nullable = false)
    private String username;
    private String password;

    private String providerId;

    @Enumerated(EnumType.STRING)
    private AuthProviderType providerType;

    @ElementCollection(fetch = FetchType.EAGER)
    @Enumerated(EnumType.STRING)
    Set<RoleType> roles = new HashSet<>();

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
//        return roles.stream()
//                .map(role -> new SimpleGrantedAuthority("ROLE_"+role.name()))
//                .collect(Collectors.toSet());
        Set<SimpleGrantedAuthority> authorities = new HashSet<>();
    
*then in the authservice we have loin methid where authentication mmanager.autheticate we pass username and password and .aitheticate called fetch details from the db
*and then the if exist get user from the .getPrincipal and we want to return the jwt token as response
*  public LoginResponseDto login(LoginRequestDto loginRequestDto) {

        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(loginRequestDto.getUsername(), loginRequestDto.getPassword())
        );

        User user = (User) authentication.getPrincipal();

        String token = authUtil.generateAccessToken(user);

        return new LoginResponseDto(token, user.getId());
    }
*before that add the security dependencies and in auth utils 
*we provide secret key then generate token public class AuthUtil {

    @Value("${jwt.secretKey}")
    private String jwtSecretKey;

    private SecretKey getSecretKey() {
        return Keys.hmacShaKeyFor(jwtSecretKey.getBytes(StandardCharsets.UTF_8));
    }

    public String generateAccessToken(User user) {
        return Jwts.builder()
                .subject(user.getUsername())
                .claim("userId", user.getId().toString())
                .issuedAt(new Date())
                .expiration(new Date(System.currentTimeMillis() + 1000*60*10))
                .signWith(getSecretKey())
                .compact();
    }
*and from service return loginresponse dto 
*but before the login signup must bethere
*ublic User signUpInternal(SignUpRequestDto signupRequestDto, AuthProviderType authProviderType, String providerId) {
        User user = userRepository.findByUsername(signupRequestDto.getUsername()).orElse(null);

        if(user != null) throw new IllegalArgumentException("User already exists");

        user = User.builder()
                .username(signupRequestDto.getUsername())
                .providerId(providerId)
                .providerType(authProviderType)
                .roles(signupRequestDto.getRoles()) // Role.PATIENT
                .build();
*when using bulder Benefits

Readable object creation ‚Üí You know which field you are setting.

No need for multiple constructors ‚Üí Cleaner code.
*Now i want to insert another filter chain befor teh usernamepasswordauthetication filter
*@Slf4j
@RequiredArgsConstructor
public class JwtAuthFilter extends OncePerRequestFilter {

    private final UserRepository userRepository;
    private final AuthUtil authUtil;

    private final HandlerExceptionResolver handlerExceptionResolver;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        try {
            log.info("incoming request: {}", request.getRequestURI());

            final String requestTokenHeader = request.getHeader("Authorization");
            if (requestTokenHeader == null || !requestTokenHeader.startsWith("Bearer")) {
                filterChain.doFilter(request, response);
                return;
            }

            String token = requestTokenHeader.split("Bearer ")[1];
            String username = authUtil.getUsernameFromToken(token);

            if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                User user = userRepository.findByUsername(username).orElseThrow();
                UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken
                        = new UsernamePasswordAuthenticationToken(user, null, user.getAuthorities());
                SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);
            }
            filterChain.doFilter(request, response);
        } catch (Exception ex) {
            handlerExceptionResolver.resolveException(request, response, null, ex);
        }
    }
}
and in security filter hain   @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception {
        httpSecurity
                .csrf(csrfConfig -> csrfConfig.disable())
                .sessionManagement(sessionConfig ->
                        sessionConfig.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/public/**", "/auth/**").permitAll()
                        .requestMatchers(HttpMethod.DELETE, "/admin/**")
                            .hasAnyAuthority(APPOINTMENT_DELETE.name(),
                                USER_MANAGE.name())
                        .requestMatchers("/admin/**").hasRole(ADMIN.name())
                        .requestMatchers("/doctors/**").hasAnyRole(DOCTOR.name(), ADMIN.name())
                        .anyRequest().authenticated()
                )
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
*So tis is afyer th login send the reuest



* ---------------------------------------------------------------------------------------------------------------------------------------------------------------------
oauth stands for open authorization
*It is authorization framework 
*its allows third party apis to access the user product data
*clinet sends the registration getsthe clinet code and secret key from uth
*then the clinet send request for sign in then auth sercer send the auth code
*then again send auth code reciev access tolken and again give access and then it goes to auth server
*-----------------------------------------------------------------------------------------------------------------------------------------------------------------------Now for the authorization when we have manyaps then we can use he @preauhorze and postauthoize
*for preauthorize in he websecirity config we need to set the @enablemethodsecurity and prepostenable to true
*microservice communications
*00:00 ‚Äì Introduction

Microservices are small, loosely coupled services that work together.
Each microservice:

Has its own database (usually).

Runs independently.

Communicates with others using APIs.

Example:

Order Service ‚Üí Manages orders.

Payment Service ‚Üí Handles payments.

Notification Service ‚Üí Sends emails/SMS.

00:48 ‚Äì Setup of 2 Microservices

Let‚Äôs create 2 microservices:

Order Service (port 8081)

Payment Service (port 8082)

üëâ Add dependencies in pom.xml (for both):

<dependencies>
   <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
   </dependency>
</dependencies>

Order Service (8081)
@RestController
@RequestMapping("/order")
public class OrderController {

    @GetMapping("/{id}")
    public String getOrder(@PathVariable String id) {
        return "Order placed successfully with ID: " + id;
    }
}

Payment Service (8082)
@RestController
@RequestMapping("/payment")
public class PaymentController {

    @GetMapping("/{id}")
    public String getPayment(@PathVariable String id) {
        return "Payment done for Order ID: " + id;
    }
}

02:19 ‚Äì Types of Communication in Spring

Microservices talk in two ways:

Synchronous (blocking) ‚Üí One waits for the other‚Äôs response.

Example: REST API (HTTP request/response).

Asynchronous (non-blocking) ‚Üí Doesn‚Äôt wait, uses messaging.

Example: Kafka, RabbitMQ.

05:09 ‚Äì Understand HTTP Request and Response Call

HTTP communication is the most common between microservices.

Example:

Order Service calls Payment Service like:
GET http://localhost:8082/payment/101

Response from Payment Service:

"Payment done for Order ID: 101"

13:55 ‚Äì Using Plain JAVA (HttpURLConnection)

We can use raw Java to make HTTP calls, but it‚Äôs verbose.

Example in Order Service:
@GetMapping("/callPayment/{id}")
public String callPayment(@PathVariable String id) throws Exception {
    URL url = new URL("http://localhost:8082/payment/" + id);
    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
    connection.setRequestMethod("GET");

    BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
    String response = in.readLine();
    in.close();

    return "Order Service got response: " + response;
}

25:27 ‚Äì Disadvantages of Plain Java

Too much boilerplate code.

No built-in JSON parsing.

Hard to handle exceptions.

Not reusable.

27:15 ‚Äì RestTemplate with Simple Code Example

Spring provides RestTemplate to simplify communication.

üëâ Add Bean in Config:

@Configuration
public class AppConfig {
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}


üëâ Use in Order Service:

@RestController
@RequestMapping("/order")
public class OrderController {

    @Autowired
    private RestTemplate restTemplate;

    @GetMapping("/pay/{id}")
    public String callPayment(@PathVariable String id) {
        String url = "http://localhost:8082/payment/" + id;
        String response = restTemplate.getForObject(url, String.class);
        return "Order Service got response: " + response;
    }
}

33:43 ‚Äì How RestTemplate Works Internally

RestTemplate is built on HTTP client libraries like HttpURLConnection, Apache HttpClient, or OkHttp.

It hides low-level details ‚Üí you just give URL, HTTP method, and response type.

It automatically:

Opens connection

Sends request

Reads response

Converts it to your POJO/string

41:31 ‚Äì Different Methods in RestTemplate

Some commonly used methods:

getForObject(url, responseType)  
getForEntity(url, responseType)  
postForObject(url, request, responseType)  
postForEntity(url, request, responseType)  
exchange(url, HttpMethod, requestEntity, responseType)  
delete(url)

Example:
// GET
String response = restTemplate.getForObject("http://localhost:8082/payment/101", String.class);

// POST
Order order = new Order(1, "Book");
Order created = restTemplate.postForObject("http://localhost:8082/order", order, Order.class);

// DELETE
restTemplate.delete("http://localhost:8082/order/1");

52:22 ‚Äì Closing Notes

Plain Java is possible but not recommended.

RestTemplate simplifies HTTP communication.

For modern apps, WebClient (Reactive) is preferred over RestTemplate.

Async communication can be done via Kafka/RabbitMQ.

‚úÖ Summary:

Setup microservices (Order + Payment).

Synchronous communication using RestTemplate.

Understood how HTTP works in microservices.

Learned limitations of Plain Java and advantages of RestTemplate.

Explored different RestTemplate methods.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Rest clinet
*n 6.1
*It is used to amkes rest api calls
*something bacakenapp needs to act as clinet to make calls to anoter server called third party service where the apis are already exposed
*It is modern way of resttemplate
*so in config make beans of the restclinet and in this wrute builder with baeur of 2rd party apis
*and in service we autowired the restclinet
*and thet clinet.get().uri("/{id},id).retrirv().body(Todo.cleass) what we rae expected from the 3rd part



36:39 ‚Äì Exception Handling with RestClient

When you call another microservice using RestClient, network errors or HTTP status codes like 404 / 500 can occur.
Spring provides structured exception handling for RestClient.

Common exceptions

HttpClientErrorException ‚Üí 4xx status codes (client error).

HttpServerErrorException ‚Üí 5xx status codes (server error).

ResourceAccessException ‚Üí Connection/timeout issues.

RestClientException ‚Üí Base class for all.

Example ‚Äì Handling Exceptions
@RestController
@RequestMapping("/order")
public class OrderController {

    private final RestClient restClient = RestClient.create();

    @GetMapping("/pay/{id}")
    public String callPayment(@PathVariable String id) {
        try {
            String response = restClient.get()
                    .uri("http://localhost:8082/payment/{id}", id)
                    .retrieve()
                    .body(String.class);

            return "Order Service got: " + response;

        } catch (HttpClientErrorException e) {
            return "Client Error: " + e.getStatusCode() + " - " + e.getMessage();
        } catch (HttpServerErrorException e) {
            return "Server Error: " + e.getStatusCode() + " - " + e.getMessage();
        } catch (ResourceAccessException e) {
            return "Service unavailable: " + e.getMessage();
        }
    }
}


‚úÖ Benefits:

You can gracefully handle service downtime or bad requests.

You avoid crashing the caller service.

44:44 ‚Äì RestClient Exchange Framework Flow

The exchange() method is the most flexible way to make requests with RestClient.
It allows you to specify:

HTTP method (GET, POST, PUT, DELETE)

Headers

Request body

Response type

General Flow

Create a RestClient instance.

Build request with .method(HttpMethod, uri).

Add headers with .header().

Attach body with .body().

Call .exchange() ‚Üí returns full ClientResponse.

Extract response with .bodyTo() or .body().

Example ‚Äì Exchange in RestClient
@RestController
@RequestMapping("/order")
public class OrderController {

    private final RestClient restClient = RestClient.create();

    @PostMapping("/create")
    public String createOrder(@RequestBody Order order) {
        ClientResponse response = restClient.post()
                .uri("http://localhost:8082/payment")
                .header("Content-Type", "application/json")
                .body(order)
                .exchange();

        // Full control on response
        if (response.getStatusCode().is2xxSuccessful()) {
            return "Order created, response: " + response.body(String.class);
        } else {
            return "Error: " + response.getStatusCode();
        }
    }
}


‚úÖ Why use exchange()?

When you need full control (headers, status code, cookies).

When response is not always straightforward (e.g., may return error JSON).

50:04 ‚Äì Request Interceptor with RestClient

Request interceptors let you modify outgoing requests or log responses before/after execution.
This is useful for:

Adding authentication headers (JWT, OAuth2).

Logging request/response details.

Handling retries.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Feign clinet
*00:00 ‚Äì Introduction

In microservices, services must communicate with each other.
Options:

RestTemplate (older, synchronous)

WebClient (reactive, modern)

FeignClient (declarative REST client ‚Üí less boilerplate)

üëâ FeignClient lets you call other services like calling a local method.

00:36 ‚Äì What is FeignClient

Feign is a declarative HTTP client from Netflix, integrated in Spring Cloud.

You don‚Äôt write HTTP code (RestTemplate, headers, etc.).

You just declare an interface ‚Üí Spring auto-creates proxy implementation.

03:26 ‚Äì Adding Dependency (OpenFeign) in pom.xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>


üëâ Also enable Feign in Application class:

@SpringBootApplication
@EnableFeignClients
public class OrderServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }
}

06:32 ‚Äì FeignClient Simple Code Example

Example: Order Service (8081) calls Payment Service (8082).

Payment Service (8082)
@RestController
@RequestMapping("/payment")
public class PaymentController {

    @GetMapping("/{id}")
    public String getPayment(@PathVariable String id) {
        return "Payment done for order " + id;
    }
}

Feign Client in Order Service (8081)
@FeignClient(name = "payment-service", url = "http://localhost:8082/payment")
public interface PaymentClient {
    @GetMapping("/{id}")
    String getPayment(@PathVariable("id") String id);
}

Order Contr
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
So basically the service instance are created and destroyed dynamically
*now calling one service we hardcode url its fine unti payment have one instance if many than tight coupling and n load alancing
*so now the service discovery called the eurek coes where we have the ureka serverthat stores the phonebook sof all registered clinet
*and eureka cliet whch stores the register itself with ureka serer

*so simple flow is the order service give list of instance of payment toeureka servre
*and sureka return list of instance of ayment servce active to the order servce
*ad then the order seriec decide which nstance to invoke 
Note:add dependencyand enableeurekaserver
*and in app.properties give pot anme as srer name or eureka
*and the clinet name too toresgister in the eureka server
*nNow the things that comes is now both the clinetget registerd
*so now want to call payment service from the order service
*we usedthe esttemplate .getforobject(hardoddd url 
*Now the  RestTemplate restTemplate = new RestTemplate();

    // 1. Fetching the list of instances of "product-service"
    List<ServiceInstance> instances = discoveryClient.getInstances("product-service");

    // 2. Picking one instance (in real world, load balancer decides which)
    URI uri = instances.get(0).getUri();

    // 3. Making REST call to that instance
    String response = restTemplate.getForObject(uri + "/products/" + id, String.class);

    System.out.println("Response from Product api call is: " + response);



*So eureka store data i memry
*Yes eureka server is single point of failure if shut down
*----------------------------------------------------------------------------------------------------------------------------------------------------------------------

