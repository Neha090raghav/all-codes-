typescript
css
tailwind css
js interview and the other
react js interview and the other
redux
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
dsa 2 question
system design 1 whole lecture
------------------------------------------------------------------------------------------------------------------------------------------------------------------
java 50
MySQL 5 video
springboot 5 video
microservices
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
*Typescript is the superset of the js with additional features
*here we define data types also called the static typing and helps in increasing code reusability
*here first in folder install npi i typescript latest versio is 5
*then make app.ts there write var name:string="neha"
*then in the terminal write npx tsc app.ts then the app.js js fule will be generated
*as the browser understand only the js o the typescript is finally conveted to js only
*Note:in the browser window there is already a variable of name
*so we cant write var name='neha'
*
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Number data type
*var num1:number=10                                  .js->var num1=10;
*let num2:number=10;//error as when we are creating its js js sees as we are redckaring the num2 in .js file so use the var fpor that or else we will make the changes in the configuration file
*then when we  var total=num1+num2;
*when we hover on the total it automatically determine the data type as number thta is called the type interference
*anther example of interference is var num=12;
num='13' it will say no you cant
*so interference is it itself assume the type explicty 
*No w to solve the above problem we have to say var num:nuber|string=12;
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Sstring and Boolean data types
*var age:string="neha"
*var age1:string='neha'
*var age2:string=`neha`
*var num=21;
*now to var description=`my age is {age}` so here string will automatically changes to string


*now to conbert any data type to string we uses the toString() method
*var num:number=1;
*var str:string=num.toString();
*var bool:boolean=true //it tkaes 2 value either true or false
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

*null means variable dont have nay value nor the empty value too
*var nullvar=null;interfere as null
*if we assign another value as string no not allowedd
*mostly used when any variable initialy as null byt can be assigned diffrenet type
*
var data:null|string=null
if(login)
{
data="user"
}
*type of null is object but as here data is string so type is string now
*sismilray var num=undefined
*type of data si undefined
*so we assisgn any string then the not allowed so var data:undefined|string=undefined
*-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Now to generate the config file then the 
tsc -- init
*then tscconfig.json generated
*in this file we have many configuartions like target which measn when we are converting the typescript converted to which javascript version we have ecmsasript 24 now
*now we have config file i want to get js of all ts file so run tsc only
*Note:we can declare var variable in many ts file but data type of both declaration must be same otherwise erro
*Note:when we run tsconfig it run as project and give errors

*so tsco fig file run all files as project,tsc all ts file ,errorrs and then in the tsconfig.json output: we can give any folder so all files of js comes in this folder
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------working with the html and typescript
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=<device-width>, initial-scale=1.0" />
    <title>Document</title>
    <script src="./null.js"> </script>
  </head>
  <body>
    <input type="text" id="username" />
    <input type="text" id="password" />
    <button onclick="getInfo()">Login</button>
  </body>
</html>
and i null .ts
function getInfo()
{
var name=docume.getElemntById("username").value
}



*----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Array data type
*var arr:number[]=[1,2,3,4,5]
* var arr:Array<string>=["neha,"Raghav"]


Tuple data type
*in tuple the data types are diffrenet and they are of fixed length
*and they are in the order
*var user:[number,string,boolean]=[1,"2",true]
*Note:erro ininitialzed if we give value but not type
*but when we push it will not give error
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
var studentdata{
name:string,
age:number,
adres:string}={name:'neha',age:25,address:'ada colony'}
*if i change  studentdata.name='golu'
*it will work
*Note:while initialize we need to give same data type as being used in static typing of object
*Now to add more keys to object we will fac error while the assigning
*studentdata.company //error 
var studentdata{
[key:string]:string\number}
This is first solution
*second is while initilizaing add
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Any data type and unknown data type
*when the variable have no idea what will be the data type of data being initlized to variable so we use the nay data type
*Any data type use:
1.when migrating code from js to ts
*when dealing with dynaic value from api
*use of third part library whic converts data
suppose we ave var value='neha'
i want value=2;
so soluton is var value:string|number
*if more than add above but we can have
var value:any
*means any data type
*but it reduce  purpose of static typing
*so use it when needed only
*

Now unknow same purpose but one thing it does it befor sing it or applying any metod it will always say to chevk the data type 
var val:unknown
val="neha";
val.to_uppercase()
it will say check the data type first then perform
so if(type of val=='string')
{
val.to_uppercase()
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Function return type
*function getapple{
reurn "apple"
}
by type infrenec its return ty ep is string or we can mention explicity
*and if we dont return anything than by inference its data type is void
*and if we are not confirm which data tyeof retu value so
function getapple:any{
reurn 
}




-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Never in typescript
*when any function isn't executed due to the error due t which its not able to return the last line
*so here the return type is never
*function neverexample:never{
while(true)
{
console.log()
}
}

*function neverexample:never{
while(true)
{
throw new Error()}
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
Function param type
suppose we have the function calculatePrice(int num1:nmber,int nus2:number,int num3?:string){if(num3
{
}
}
calculatePrice(12,12)
?:tells that it can be undefine dor string
*--------------------------------------------------------------------------------------------------------------------------------------------------------------
Interface
*It is usedto define the structure of object or function
*and can be used as data typ for many variable an hence can be reused
*Intercae infp{
name:
roll no:

}
interace teacher info exteds info
{
techerid
}
var teachr:teacherifo={
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------
Intersection data type
*It is used basically when we want to combine many data types
*so we have interface a{
}
interface b
{
}
type c=a&b
*When we combine the interface that result interface needs to be converted to the type
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Type:
Define Custom data type for the object or function
*interface a
*interace b
interface c=a|b//not allowed,similarly intersection not allowed

similary
but with the type a
type b
type c=a|b and alos a&b

Note:type can be extended whereas interface can be
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Enum data type
A data type that helps you dfined set of named constant
*Enum whotype
{
student="neha"
teacher="Madhu"
son="lucky"
}
var student:whotype=whotype.student
means in variable student it can take only 4 values from the above set
*suppose Enum whotype
{
student
teacher
son
}
var student:whotype=whotype.student->0
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
Dom handling and typecasting
*suppose we have <h1>hi</h1>
*Now suppose var ele= document.querySelector('h1')
ele?.text//we want to check if its not null,'',undefine,false
*now var ele= document.querySelector('h1')! will say that this element exist in dom and will predict the type of ele as htmlheadding elemnst
*var ele= document.querySelector('h1') then htmlheadingelement|null so place !


Supose <a href="google.com" class="anchor">
var ele= document.querySelector('.anchor') here the type will be elemnst
*so here if we consoleele.hre then error so here we need to do typecasting as var ele= document.querySelector('.anchor') as htmlanchorelement
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Module:
A self contained unit of code that encapsulated the related functionalities
*-------------------------------------------------------------------------------------------------------------------------------------------------------------------
class student
{
name:string,
age:number;
constructor(name,age)
{
this.name=ame,
tis.age=age;
}
}
*Now whati wantis thetthe hen every i et ame ten add the mr 
*if tjusand studentthen every time s.name+Mr
*so insted of doing this 
*declaree properies as getter
*solass student
{
name:string,
age:number;
set name(name)
{
this.-nmae=name;
}
get name()
{
return this.name
}
}
Student s=new Stdent();
s1.name="neha"
----------------------------------------------------------------------------------------------------------------------------------------------------------------
Typeguard
A typeguard is a property i typescrit with which we can narrow down the type of variabl al with a conditional block
*suppose with helpf | we declared the data type of variable as strig|numer
*nw i want if string then do this else numberdo this so this is typegurad
*There are 3 type of typeguards  ypescript
1.type of-primitiv
2.instane of->class
3.Custom Type->interface
------------------------------------------------------------------------------------------------------------------------------------------------------------------
Generics in typescrits allows you to create the reusable copnents that works with various data type ensuring typesfet
*suppose function fruits(nam:strig):sring
{
retrun nam;
}
frite"apple")
fruite(1) so here error s using | cange the nuber
*again something else
*so we an here makin this uction generic a function fruites <T>(name:T):T
{
}
varname=fruits("ppe")->ten retur is alsostring
So here it easn that itsinputtype output type and return type all must be same
*Counter question will be us an so if write an and return any than for sure itwill return any
*---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Key of operator
*suppose type Perso
{
ame:strin,
address:string
}
var person2:Person={
name:"neha
}
*const personx=keyof Person
*personx="neha"//wrog
here in person x we can gie "name",addess so ke of retrive union of ll keys from the type
*----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Indx signature
*Indx signature helps you to define dynamic keys on objects specifying type of values
*suppose type info{
name:sting
id:string}
*var student:info={
name:"neha"
id:"1"
semester:""
roolno:""

}
so keys are the dynamc any numer of eys an be added so
* type info{
[key:strig]:string}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

suppose info{
name:sting
id:string}

*now what happens is that the var student:info={
name:"neha"}
*so here branch mayhappens or nt
*so  var student:Parial<info>={
name:"neha"}

Hence we make 2 poperteis as optional
*Utility are builtin data ype tathelps to convert one type ito oher
*if you want optional should be the required than 	Require<info>
*ReadOnly
*Omit
*Exclude
*Extarct
*NoNullable
---------------------------------------------------------------------------------------------------------------------------------------------------------------------Typescriptnamespace
*What is a Namespace?

A namespace in TypeScript is a way to group related code (variables, classes, interfaces, functions) under a single name to avoid naming conflicts.

Think of it as a container for your code.
(It’s similar to Java’s package.)

🔹 Basic Example
namespace Utils {
  export function toUpperCase(str: string): string {
    return str.toUpperCase();
  }

  export function toLowerCase(str: string): string {
    return str.toLowerCase();
  }
}

// Usage
console.log(Utils.toUpperCase("neha")); // Output: NEHA
console.log(Utils.toLowerCase("NEHA")); // Output: neha


✅ Notice the export keyword — without it, members stay private to the namespace.

🔹 Namespace with Class
namespace Shapes {
  export class Circle {
    constructor(public radius: number) {}

    area(): number {
      return Math.PI * this.radius * this.radius;
    }
  }

  export class Rectangle {
    constructor(public width: number, public height: number) {}

    area(): number {
      return this.width * this.height;
    }
  }
}

// Usage
const circle = new Shapes.Circle(5);
console.log("Circle Area:", circle.area()); // 78.54

const rect = new Shapes.Rectangle(4, 6);
console.log("Rectangle Area:", rect.area()); // 24
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Loggers are special kinds of declaration added t class to modify their behavior
*That’s possible because TypeScript supports decorators (when "experimentalDecorators": true is enabled in tsconfig.json).
We can create a class decorator @Logger that automatically logs whenever a class is created or its methods are called.

🔹 Example 1: Class Decorator @Logger
function Logger(constructor: Function) {
  console.log(`📌 Class ${constructor.name} has been created.`);
}

@Logger
class UserService {
  constructor(public name: string) {}
}

const user = new UserService("Neha");
// Console Output:
// 📌 Class UserService has been created.


Here, @Logger logs when the class is defined/instantiated.

🔹 Example 2: Method Decorator @LogMethod
function LogMethod(
  target: Object,
  propertyKey: string,
  descriptor: PropertyDescriptor
) {
  const originalMethod = descriptor.value;

  descriptor.value = function (...args: any[]) {
    console.log(`🔹 Calling ${propertyKey} with args:`, args);
    const result = originalMethod.apply(this, args);
    console.log(`✅ ${propertyKey} returned:`, result);
    return result;
  };

  return descriptor;
}

class Calculator {
  @LogMethod
  add(a: number, b: number): number {
    return a + b;
  }

  @LogMethod
  multiply(a: number, b: number): number {
    return a * b;
  }
}

const calc = new Calculator();
calc.add(5, 3);
// 🔹 Calling add with args: [5, 3]
// ✅ add returned: 8

🔹 Example 3: Parameter Decorator @LogParam
function LogParam(target: Object, propertyKey: string, parameterIndex: number) {
  console.log(`📝 Parameter in method ${propertyKey} at index ${parameterIndex}`);
}

class Greeting {
  greet(@LogParam name: string) {
    console.log(`Hello, ${name}!`);
  }
}

const g = new Greeting();
g.greet("Neha");
// 📝 Parameter in method greet at index 0
// Hello, Neha!


✅ This way, you can use @Logger (or more specific decorators like @LogMethod) instead of manually calling logger functions.
They are super useful in large apps for aud
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Type promise
function complelogic:Promise<string>
{
nw Promise(
ettieout(()=>
{
reolsve("hii")
},2000)
}
*

-----------------------------------------------------------------------------------------------------------------------------------------------------------------


Typescript interview questiosn

Null and undefined
*null represent the absence of the vlue
*var name:null=null
*var item="" here item has mpty value but null represent no value
*---------------------------------------------------------------------------------------------------------------------------------------------------------------------
1. What is TypeScript? How is it different from JavaScript?
*peScript = statically typed (compile-time type checking).
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
2. What are the benefits of using TypeScript?

Answer:

Type safety.

Better tooling (IntelliSense, auto-completion).

Detect errors at compile-time.

Supports modern JS features + OOP (interfaces, inheritance, etc.).

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
3.3. What are the different data types in TypeScript?
*Answer:

1.Primitive types: string, number, boolean, null, undefined, symbol, bigint.
2.Special types: any, unknown, never, void.
3.Complex types: array, tuple, enum, object.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Diffrenec between any,never ,unknown

1.1. any
*Disables type checking → can hold any type.
*Useful when migrating JS → TS, but not safe.

let value: any = 42;
value = "hello";   // ✅ allowed
value = true;      // ✅ allowed
console.log(value.toUpperCase()); // ✅ no error, but might fail at runtime
✅ no error, but might fail at runtime



2.2unknown
*Similar to any, but safer.
*Must perform a type check before using.
let input: unknown = "TypeScript";

if (typeof input === "string") {
  console.log(input.toUpperCase()); // ✅ safe
}

let unsafe: string = input; // ❌ Error: unknown not assignable to string


3.33. never

Represents values that never occur.

Used for functions that throw errors or never finish.

function fail(msg: string): never {
  throw new Error(msg);  // never returns
}

function infiniteLoop(): never {
  while (true) {}
}



4.4
. void

Represents no return value.

Used in functions that don’t return anything.

function logMessage(msg: string): void {
  console.log(msg); // no return
}

let result: void = logMessage("Hello TS"); 
console.log(result); // undefined

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
5. What are TypeScript interfaces?
*Definition

An interface in TypeScript defines the shape (structure) of an object.

It describes properties & methods that an object must have.

It does not contain implementation — just the contract.

1.Basic interface
interface User {
  id: number;
  name: string;
  isAdmin?: boolean; // optional property
}

const u1: User = { id: 1, name: "Neha" };       // ✅ ok
const u2: User = { id: 2, name: "Raj", isAdmin: true }; // ✅ ok


2.Methods inside interface
interface Person {
  name: string;
  greet(): string;
}

const p: Person = {
  name: "Alice",
  greet: () => `Hello, ${p.name}`
};

console.log(p.greet()); // Hello, Alice
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Some important java questions
Pojo class
*A POJO class stands for Plain Old Java Object.
*It’s a simple Java class that:

Doesn’t extend any special classes (like HttpServlet, EJB, etc.)

Doesn’t implement any special interfaces (like Serializable, Remote, unless required)

Doesn’t use any special annotations from Java frameworks

Key Points

POJOs are not bound to any framework → just pure Java.

They help in decoupling application logic from frameworks.
Often used to represent data (like rows from a database, JSON objects, etc.).


In interviews, if they ask:

POJO vs JavaBean → A JavaBean is a special type of POJO that must have a no-arg constructor, be serializable, and use getters/setters to access properties.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Diamond Problem and Solution
*If a class inherits from two classes that have the same method, the compiler won’t know which one to use.
Java doesn’t allow multiple inheritance with classes because of this.
*olution: Interfaces (with default methods, we can resolve conflicts explicitly).--importnat
*interface A {
    default void show() {
        System.out.println("A");
    }
}
interface B {
    default void show() {
        System.out.println("B");
    }
}
class C implements A, B {
    // Must override to solve ambiguity
    public void show() {
        A.super.show(); // or B.super.show();
    }
}


Methods in Interface
*All fields in an interface are by default:
public, static, final (constants).
*Methods in Interface

Before Java 8 → Only abstract methods allowed.

Java 8 onwards → default, static methods.

Java 9 onwards → private methods also.

interface Vehicle {
    void start();              // abstract method
    default void honk() {      // default method
        System.out.println("Beep!");
    }
    static void stop() {       // static method
        System.out.println("Stopped.");
    }
    private void checkEngine() {   // private helper (Java 9+)
        System.out.println("Engine checked.");
    }
}





*🔹 Abstract Class Vs Interface
Feature	Abstract Class	Interface
Methods	Can have abstract + concrete methods	Before Java 8 → only abstract; Java 8+ → default, static, private
Fields	Can have instance + static variables	Only public static final constants
Constructors	Can have constructors	Cannot have constructors
Inheritance	Single inheritance	Multiple inheritance
Use Case	"is-a" relationship (base class)	"contract" relationship


1Default methods
.interface Music {
    default void play() {
        System.out.println("Playing music...");
    }
}
class Song implements Music {}
public class Test {
    public static void main(String[] args) {
        new Song().play();  // uses default implementation
    }
}


2.Static method 
interface Calculator {
    static int add(int a, int b) {
        return a + b;
    }
}
public class Test {
    public static void main(String[] args) {
        System.out.println(Calculator.add(5, 3));
    }
}


3.Functional Interface

An interface with exactly one abstract method.

Can have many default or static methods.

Annotated with @FunctionalInterface.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Anonymous Class in Java
*An anonymous class is a class without a name.
*It’s declared and instantiated at the same time, usually inside a method.
*Mostly used when you need a one-time use class (like implementing an interface or extending a class).

interface Greeting {
    void sayHello();
}

public class Test {
    public static void main(String[] args) {
        Greeting g = new Greeting() {   // anonymous class
            public void sayHello() {
                System.out.println("Hello from Anonymous Class!");
            }
        };
        g.sayHello();
    }
}



class Animal {
    void sound() {
        System.out.println("Some sound...");
    }
}

public class Test {
    public static void main(String[] args) {
        Animal dog = new Animal() {   // anonymous subclass
            void sound() {
                System.out.println("Bark");
            }
        };
        dog.sound();
    }
}



public class Test {
    public static void main(String[] args) {
        Thread t = new Thread(new Runnable() {
            public void run() {
                System.out.println("Thread running...");
            }
        });
        t.start();
    }
}


Anonymous classes cannot have constructors (since they don’t have a name).

They are created at runtime and compiled into a class file like Test$1.class.

Useful for short-term use instead of writing long separate classes.

































---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Funcional interfaces
*An interface with only one abstract method is called functional interface
*@functiona interface we can have one abstract method but can have many non abstract method too
*Now the non sbatract method here can be default or sttaic 
*Now there are 3ways to implemenst the functionl interface Bird and fly method 
@FunctionalInterface
interface Greeting {
    void sayHello(String name);
}

1.way is the implemnets 



class GreetingImpl implements Greeting {
    public void sayHello(String name) {
        System.out.println("Hello, " + name + " from Normal Class!");
    }
}

public class Test {
    public static void main(String[] args) {
        Greeting g1 = new GreetingImpl();
        g1.sayHello("Neha");
    }
}

2.anonymonous
public class Test {
    public static void main(String[] args) {
        Greeting g2 = new Greeting() {
            public void sayHello(String name) {
                System.out.println("Hello, " + name + " from Anonymous Class!");
            }
        };
        g2.sayHello("Neha");
    }
}



3.lambda expression
public class Test {
    public static void main(String[] args) {
        Greeting g3 = (name) -> System.out.println("Hello, " + name + " from Lambda!");
        g3.sayHello("Neha");
    }
}


In lambda we know one method override wht the importance of declaring class and initlizing object jst the override method ()->{
}
arg in () what overloaded metod accepts


Types of consumer
*Consumer

here apply accepts but did not return anything
1. Consumer<T>

Represents an operation that accepts a single input but does not return anything (void).

Method: accept(T t).

import java.util.function.Consumer;

public class ConsumerExample {
    public static void main(String[] args) {
        Consumer<String> consumer = (s) -> System.out.println("Hello, " + s);
        consumer.accept("Neha"); // Output: Hello, Neha
    }
}


📌 Use case → Logging, printing, updating data without returning anything.

*Supplier
get does not accpt anything but rerurns 
import java.util.function.Supplier;

public class SupplierExample {
    public static void main(String[] args) {
        Supplier<Double> supplier = () -> Math.random();
        System.out.println("Random number: " + supplier.get());
    }
}



*Predicate
acceots one and returns the Booleans 
🔹 3. Predicate<T>

Represents a boolean-valued function of one argument.

Method: test(T t) → returns true or false.

import java.util.function.Predicate;

public class PredicateExample {
    public static void main(String[] args) {
        Predicate<Integer> isEven = (n) -> n % 2 == 0;
        System.out.println(isEven.test(10)); // true
        System.out.println(isEven.test(7));  // false
    }
}


📌 Use case → Filtering collections, validation, conditions

*Function
Represents a function that takes one argument and returns a result.

Method: apply(T t) → returns R.

import java.util.function.Function;

public class FunctionExample {
    public static void main(String[] args) {
        Function<String, Integer> lengthFunc = (str) -> str.length();
        System.out.println(lengthFunc.apply("Neha")); // 4
    }
}


📌 Use case → Transforming data (String → Integer, Object → DTO, etc.).
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
java reflection
*Every Java object’s metadata (name, methods, fields, constructors, etc.) is stored in a special class called java.lang.Class.
*for each type a class object is created

class Student {}
public class Test {
    public static void main(String[] args) throws Exception {
        Class<?> cls1 = Class.forName("Student"); // by name
        Class<?> cls2 = Student.class;           // using .class
        Class<?> cls3 = new Student().getClass();// using object

        System.out.println("Class Name: " + cls1.getName());
    }
}
Thsese are the 3 methods
*2. What is the "Class" class which JVM creates at runtime?

Every Java object’s metadata (name, methods, fields, constructors, etc.) is stored in a special class called java.lang.Class.

JVM automatically creates a Class object for each type when loaded.

class Student {}
public class Test {
    public static void main(String[] args) {
        Class<?> cls = Student.class;  // way 1
        System.out.println(cls.getName()); // output: Student
    }
}

🔹 3. How to Reflect Classes and access its metadata
class Student {}
public class Test {
    public static void main(String[] args) throws Exception {
        Class<?> cls1 = Class.forName("Student"); // by name
        Class<?> cls2 = Student.class;           // using .class
        Class<?> cls3 = new Student().getClass();// using object

        System.out.println("Class Name: " + cls1.getName());
    }
}

🔹 4. How to Reflect Methods and access its metadata
import java.lang.reflect.*;

class Student {
    public void study() {}
    private void sleep() {}
}

public class Test {
    public static void main(String[] args) throws Exception {
        Class<?> cls = Student.class;

        Method[] methods = cls.getDeclaredMethods();
        for (Method m : methods) {
            System.out.println("Method: " + m.getName() + 
                               ", Return Type: " + m.getReturnType());
        }
    }
}

🔹 5. How to Invoke Methods using Reflection
import java.lang.reflect.*;

class Student {
    public void study(String subject) {
        System.out.println("Studying " + subject);
    }
}

public class Test {
    public static void main(String[] args) throws Exception {
        Student s = new Student();
        Method m = Student.class.getMethod("study", String.class);
        m.invoke(s, "Math"); // Output: Studying Math
    }
}

🔹 6. How to Reflect Fields and access its metadata
import java.lang.reflect.*;

class Student {
    public String name;
    private int age;
}

public class Test {
    public static void main(String[] args) {
        Field[] fields = Student.class.getDeclaredFields();
        for (Field f : fields) {
            System.out.println("Field: " + f.getName() + ", Type: " + f.getType());
        }
    }
}



✅ Throw exception inside constructor if an instance already exists.

class Singleton {
    private static Singleton instance;
    private Singleton() {
        if (instance != null) {
            throw new RuntimeException("Use getInstance() method");
        }
    }
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}


Now Reflection will throw RuntimeException instead of creating a new object.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
✅ Recap

Annotations = metadata.

Pre-defined: @Deprecated, @Override, @SuppressWarnings, @FunctionalInterface, @SafeVarargs.

Meta-annotations: @Target, @Retention, @Documented, @Inherited, @Repeatable.

Custom annotations let us add our own metadata and process it with Reflection.s
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
Exception handling in java 
*It is an event that occur during the execution of programme
*So if exception happens then the exception onject is created
*this exceptioncontains the message exception and stack trace
*Runtimesystem takes this exception object and find which class can handle this
*if not found program will stop immediately printing the stack trace
*thowable i sparnet class
*It has Errr class which we cant hanel or not in our hands to handle
*So we have in error outofmemoryerror and stack verfloe error
*Eeror we have certain control
*Exception we have check and unchecked
*check exception comipier ask us to handle it/compiler time->io exception,sql exception,class not found exception
*unchecked->null pointer exception,arrayindexoutof bound,arithmetic exception



1.Unchecked exception
*comiler does not force to handle them
*Null poinre exception
*Tring val=null
null.cahartat(0)//null pointre exception
*no red line means runtime

2.Chcek exception
*Note:catch can handle exception which is thrown by the try block
*suppose try throws the classnotfound,sql excpetion
*then one catch of sql
*other of the classnot found
if try had method which throw throws these 2 than alos catch only catch what thrown by trt
*public class MultipleExceptionDemo {

    // method1 declares it can throw two exceptions
    public static void method1() throws ClassNotFoundException, InterruptedException {
        // Simulate some condition
        if (Math.random() > 0.5) {
            throw new ClassNotFoundException("Class not found!");
        } else {
            throw new InterruptedException("Thread was interrupted!");
        }
    }

    public static void main(String[] args) {
        try {
            method1();
        } 
        catch (ClassNotFoundException e) {   // specific handling for ClassNotFoundException
            System.out.println("Handled ClassNotFoundException: " + e.getMessage());
        } 
        catch (InterruptedException e) {     // specific handling for InterruptedException
            System.out.println("Handled InterruptedException: " + e.getMessage());
        }
        catch (Exception e) {   // (optional) fallback for any other exception
            System.out.println("Handled General Exception: " + e.getMessage());
        }

        System.out.println("Program continues after handling exception...");
    }
}

Note:so put first very specific than the generic
*Reverse than error at compile time
*we can hnald emultiple exception in one catch usinh pipe |
*


Finally block
*It runs after the try or catch block
*It runs even when we return something from try or catch
*At most we have one finally block
*if out of memory erro than finally will not run
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Collections in java
*what is java collection framework
1.Collections are nothing but the group of objects
*Prseenet in java.util pacakage
*Presenet in 1.2 version
*Frameowrk is something that provide architecture to manage these objects and to the top of it we can build or our customization
*need for it array befoe these we have araray and vector for accessing elements in arary we access by index and put by index and in vector add method,so remembering them became much more difficult
*Iteable we have one interface
*map is one interface
*collection extends the itearble interface
*List,queue ,set then extends the collection interface
*

1.iterable
*Its is used to traverse the collections
various methods in it are the :
*itearator()->return the iterator oject which provide the methods
hasnect if have more elements
*next
*return the next elemenst in iteration
*reove->removes the last elemenst returned by iterator
*second is for each loop and for each method 
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class IterableExample {
    public static void main(String[] args) {
        // Create a collection
        List<String> names = new ArrayList<>();
        names.add("Alice");
        names.add("Bob");
        names.add("Charlie");
        names.add("David");

        // 1️⃣ Using Iterator
        System.out.println("Using Iterator:");
        Iterator<String> iterator = names.iterator();
        while (iterator.hasNext()) {
            String name = iterator.next();
            System.out.println(name);

            // Example: remove "Bob"
            if (name.equals("Bob")) {
                iterator.remove(); // removes safely
            }
        }
        System.out.println("List after remove: " + names);

        // 2️⃣ Using Enhanced For-Each Loop
        System.out.println("\nUsing For-Each Loop:");
        for (String name : names) {
            System.out.println(name);
        }

        // 3️⃣ Using forEach() Method (Java 8+)
        System.out.println("\nUsing forEach() Method with Lambda:");
        names.forEach(n -> System.out.println(n));

        // Can also use Method Reference (shorter)
        System.out.println("\nUsing forEach() with Method Reference:");
        names.forEach(System.out::println);
    }
}

Note:for each uses the lambda expression





2.Collections :
size() (Java 1.2)
✔️ It returns the total number of elements present in the collection.

isEmpty() (Java 1.2)
✔️ Used to check if collection is empty or has some value. It returns true/false.

contains() (Java 1.2)
✔️ Used to search an element in the collection, returns true/false.

toArray() (Java 1.2)
✔️ It converts collection into an Array.

add() (Java 1.2)
✔️ Used to insert an element in the collection.

remove() (Java 1.2)
✔️ Used to remove an element from the collection. by using index or element

addAll() (Java 1.2)
✔️ Used to insert one collection in another collection.

removeAll() (Java 1.2)
✔️ Remove all the elements from the collections, which are present in the collection passed in the parameter.

clear() (Java 1.2)
✔️✔️ Remove all the elements from the collection.

equals() (Java 1.2)
✔️ Used to check if 2 collections are equal or not.

stream() and parallelStream() (Java 1.8)
✔️ Provide effective way to work with collection like filtering, processing data etc.

iterator() (Java 1.2)
✔️ As Iterable interface added in Java 1.5, so before this, this method was used to iterate the collection and still can be used.

*--------------------------------------------------------------------------------------------------------------------------------------------------------------------
list extens collectional interface
*Array list is an class which implements the lisy interface
*so it is ued when we want to store elements and we dont want to store in order they are inserted and duplicates allowed
*ArrayLis=new Arraylist()//so by default number of locatiosn created are 10
*and if we dd more it become growable
*as when we create like upper it will store heterogenous kind of data
*to store homogenous we have the ArrayLis<String>=new Arraylist()
*various methods are as follows
1.add(element)
2.add(index,element)
3size
4.remove(index)
5.remove(elements)
5.get(index)
6.set(index,ele)
7.contains()
8.Collectons.sort(el)
9.Collectons.sort(el,Colections.reverserder())
*for(String s:el)
{
}
*----------------------------------------------------------------------------------------------------------------------------------------------------------------------
LinkedList
*so linkedlist implements methods from the list interface and queue interface
*Note:please gof orl array list when we have the more retrieveing operations
*But when we have the mer insertin or ddleeteion than in teh arrayblist e need to reshift which takes time so for thst move to the linkedlist
*LinkedList is based on the doubly linked list
*elemensta re nt storedin continuous order
*so it has all method from teh array list and addition to that we have other methods too
*addFirst()
*addLast()
*removeFirst90
*removeLast()
*getFirst()
*getLast()
*
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Set interface
*Now hashset is class that implemenst the set interface
*So in hashset the insertion order is not preserved along with dupliactes notallowed and they uses the concept of hashcode
*So here the index will not be there and there will be the hashcode concept
*Note:use it when we have the many serach operations
*Hasset h=new Hashset()
*by default the number of location is 16
*and the fill ratio is 0.75 or load factor is 0.75
*so in array list after 10 location a new array is crated and elemenst were copied wher as i hasset as the 75 of 16 completed new colllecion is mad and elemnst copied
*But we can control the load factor byHasset h=new Hashset(100,0.95)
*Hre varius methods provide are the 
add
addall
remove(el)
removeall
contains
*Note:here we cant sort the elmenst we need to convert it into arra and then sort
*--------------------------------------------------------------------------------------------------------------------------------------------------------------------
Lnkedhasset we hav ethe insertion order maintains
*here dupliactes not allowed
*here base structure ishastable and linkeldist
*--------------------------------------------------------------------------------------------------------------------------------------------------------------------Q
Hahmap internal working
*S in hashmap we have the key value pairs and here the key must be unique and values can be duplicates
*map is a interface 
*lets start with class hashmap that implemenst the map interface and has the methods as the get(key) and put(key,value)
*hashmap interface has the sub interface entry <k,v> which is implement by node<k,v>
*in node k,v we have the hash,key,value,next
*so in hashmap we have an array of node<k,v>
* and the default size is 16
*now the thing is that the when we put any key value then the first step is it get hash by any hashing alogithm and then mod of then table size which will give index wthin size where we can put
*now suppose hash(1) give 123456%3=0 and hash(2 give )  1 so here collision happens o what we first check the 10 does it exeist if not then taht node next will point to the new node
*and if node present than update
*next we have get(1) so here hash of this we will find in tbale and once find iterate over the linked list created out of it
*There is a contact between the hastcode and equals
*if(obj1===obj2) then tehir hashcode must also be same that menas suppose i put(5,"1") so get hash so on putting same object everytime you get same hash
*second says that we have the same hash does not show equal object
*here time complexity will be o(1)
*worst time complexity will be o(n)
*so here we can can increase the isze by load factor

*and in liked list we have default size as 8 after 8 if collision still happen than convert it to tree and time complexity will be o(logn)
*o worts case will be o(n) or o(logn)
*for itearing over hashmap write
*hashmap<string,integer>h=new hashmap<>();
for(Mp.entry<String,Integer>:h.entrySet())
{
Integer value=h.getkeyvalue()
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
LinkedHashmap
*In hashmap values were not inserted in the order so lin linkedhshmap values re inserted in the order that are in array
Treemap
Here jeys are in the order means sored order
*




*----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Streams
*Strea is a pipeleine through which collection data nase
*adinside stream there are many operatoions

Variosu steps are
*From collections create stream
*tehn ad operation such that operation take stream and returns another new stream(means new collection) ,please note that operations are lazy in nature means they get executed only when *terminal operation is invoked
*Terminal operation once invoke we will get the reults terminal operators are reduce,collect,and close the tream
*


public class SalaryCountDemo {
    public static void main(String[] args) {
        int[] salaries = {2500, 4000, 3200, 2800, 5000, 1500};
        
        int count = 0;
        for (int salary : salaries) {
            if (salary > 3000) {
                count++;
            }
        }
        
        System.out.println("Salaries > 3000 (using loop): " + count);
    }
}

import java.util.Arrays;

public class SalaryCountStreamDemo {
    public static void main(String[] args) {
        int[] salaries = {2500, 4000, 3200, 2800, 5000, 1500};
        
        long count = Arrays.stream(salaries)  // open stream from array
                           .filter(sal -> sal > 3000) // intermediate operation
                           .count(); // terminal operation
        
        System.out.println("Salaries > 3000 (using stream): " + count);
    }
}


How to open stream for collection 
names.stream()     
Array.steam(arr)//for array

Some intermediate operation
filter
map
sorted

Note:why intermediate operation are lazy
*Sorted()INTERMEDIATE operatio want whole collection data than ony work rest work with one and send at bottom


Termianl operatorions are
reduce
count
collect
foreach

Note:one teh teminal operation is close we can resume stream
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Thread
Ways of creating the thread
1.extending the thread clas and ovvreiding the run method 
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread is running: " + Thread.currentThread().getName());
    }
}

public class ThreadDemo1 {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start(); // start thread
    }
}
2.makig class tht impelemns runnable
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Runnable thread running: " + Thread.currentThread().getName());
    }
}

public class ThreadDemo2 {
    public static void main(String[] args) {
        Thread t2 = new Thread(new MyRunnable());
        t2.start();
    }
}

3.Creating anonymous class

4using lambda expression


Thread lifycle
*New:means thread object is created but not yet started
*Runnbale:when start method iscalled thread become runnable waiting for cpu
*Running:when its exceuting
*Waiting:wait for another thread to get executed or just sleeping
*Terminated:Thread finished executing

*Note:t.join()means on which tread is running will wait for it to execute and main method (caller will continue)
*


Thread methods
*start()
*thread sleep for 1000 s
class MyThread extends Thread {
    @Override
    public void run() {
        for (int i = 1; i <= 5; i++) {
            System.out.println(Thread.currentThread().getName() + " → Iteration: " + i);
            try {
                Thread.sleep(1000); // sleep for 1000 ms = 1 sec
            } catch (InterruptedException e) {
                System.out.println("Thread interrupted!");
            }
        }
        System.out.println(Thread.currentThread().getName() + " finished.");
    }
}

public class ThreadSleepDemo {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        MyThread t2 = new MyThread();

        t1.setName("Worker-1");
        t2.setName("Worker-2");

        t1.start();
        t2.start();
    }
}

*t1.join()

it outer thread wait for it to execute than take controles and run
class MyThread extends Thread {
    @Override
    public void run() {
        for (int i = 1; i <= 5; i++) {
            System.out.println(Thread.currentThread().getName() + " → Iteration: " + i);
            try {
                Thread.sleep(1000); // sleep for 1000 ms = 1 sec
            } catch (InterruptedException e) {
                System.out.println("Thread interrupted!");
            }
        }
        System.out.println(Thread.currentThread().getName() + " finished.");
    }
}

public class ThreadSleepDemo {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        
        
        

        t1.start();
t1.join()//

System.ot.println()//prints after the 5s
        
    }
}

*we can add the name to thread by passing the name in contsryctor an super(nae)
*t1.interrupted()means what its doing interrupt it there if sleep stop there wait than stop
*t.yield() its aying this thread is saying you can give change to other thread
*user thread are one throught which we rea doing work so the jvm wait till it execeute but dfor daemond thread jvm doesn not wait 
*class Counter {
    private int count = 0;

    public void increment() {
        count++; // not synchronized → race condition possible
    }

    public int getCount() {
        return count;
    }
}

class WorkerThread extends Thread {
    private Counter counter;

    public WorkerThread(Counter counter) {
        this.counter = counter;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            counter.increment();
            try {
                Thread.sleep(1); // just to magnify the race condition
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class RaceConditionDemo {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();

        WorkerThread t1 = new WorkerThread(counter);
        WorkerThread t2 = new WorkerThread(counter);

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println("Final Count (expected 200): " + counter.getCount());
    }
}
so its gives less than 2000 values he value may vary, but usually it’s less than 200 because both threads update count simultaneously.
*🔹 Fixing with synchronized
class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++; // synchronized → only one thread can enter at a time
    }

    public int getCount() {
        return count;
    }
}

public class RaceConditionFixed {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();

        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 100; i++) {
                counter.increment();
                try { Thread.sleep(1); } catch (InterruptedException e) {}
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 100; i++) {
                counter.increment();
                try { Thread.sleep(1); } catch (InterruptedException e) {}
            }
        });

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println("Final Count (expected 200): " + counter.getCount());
    }
}

🔹 Sample Output (With Synchronization)
Final Count (expected 200): 200


✅ Key Takeaway:

*

Without synchronized, two threads may read & write the same variable simultaneously → lost updates (race condition).

With synchronized, only one thread at a time executes the increment → no race condition.


There are 2 types of locks :
1.Intrinsic :These are automatic and used in every object when we use synchronisd we are usig them
Extrinsic:Here we tell when to lock and when to unlock

*Needs of exeplicit lock comes
suppsie in class w add synchroise and sleep used another thread is waiting but its sleeping
*import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.TimeUnit;

class SharedResource {
    private final ReentrantLock lock = new ReentrantLock();

    public void accessResource(String threadName) {
        try {
            // Try to acquire the lock for up to 2 seconds
            if (lock.tryLock(2, TimeUnit.SECONDS)) {
                try {
                    System.out.println(threadName + " acquired the lock.");
                    
                    // Simulating some work
                    for (int i = 0; i < 5; i++) {
                        System.out.println(threadName + " is working... step " + (i+1));
                        Thread.sleep(500);
                    }
                    
                    System.out.println(threadName + " completed the task.");
                } finally {
                    // Must release the lock
                    lock.unlock();
                    System.out.println(threadName + " released the lock.");
                }
            } else {
                System.out.println(threadName + " could NOT acquire the lock.");
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            System.out.println(threadName + " was interrupted.");
        }
    }
}

public class TryLockExample {
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();

        Runnable task1 = () -> resource.accessResource("Thread-1");
        Runnable task2 = () -> resource.accessResource("Thread-2");

        Thread t1 = new Thread(task1);
        Thread t2 = new Thread(task2);

        t1.start();
        t2.start();
    }
}


executor framework
*executor
*exector service
*scheduled executor service
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Lock free mechanism
*so optimistic is lock free
*so in lovk free compare and swap its low level measn maintainer by cpu
*It atomic
*It has 3 main parameters
*main meoert eman load data
*expected value measn compare and if its equal
*tahn update the newvalue

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Thread pool
Advantages of thread pool
*here the thread need not be created agina ngain meas memeory savae of heap
*Overhead of thread lifeceycle removed
*we hva ethe executor interface which is extended by executorservice
*
and there are child classs of executor service
*Lifecycel of thread pool executor
*running->measn we can call submit method here means ready to take more task
*shutdown not eady to take the more tasks and let task in queue to process
*stop is forced shutdown sayin not take new task along with it not process the task in queue
*
*
*----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Collcetions
*


