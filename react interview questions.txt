https://www.geeksforgeeks.org/react-interview-questions/.
Server-side rendering (SSR) is a method where React pages are generated on the server before reaching the user's browser.
*Eearlier on broser the html conent of wbpage is createdbut in ssr on the server the te html content is created
**The browser doesn‚Äôt have to wait for all the JavaScript to load before showing something ‚Äî it shows the page right away.
*So when a user visits the site, they immediately get a complete HTML page from the server.
*This means the user will see content faster, which improves the user experience. It also helps search engines (like Google) read and index the content more easily, which boosts your website's SEO (Search Engine Optimization).‚Äù
*‚úÖ Example:
Imagine you go to a blog:

With client-side rendering, you first get a blank page, then the browser loads JavaScript, fetches data, and finally shows the article.

With server-side rendering, you immediately get a fully loaded article from the server ‚Äî no delay.
*Leveraging React Hooks for Server-side Rendering(SSR):
*import React, {
    useState,
    useEffect
} from 'react';

const MyComponent = () => {
    const [data, setData] = useState(null);

    useEffect(() => {
        // Simulate data fetching on the server side
        fetchData().then((result) => {
            setData(result);
        });
    }, []);

    return (
        <div>
            {data ? (
                <p>Data: {data}</p>
            ) : (
                <p>Loading...</p>
            )}
        </div>
    );
};

// Simulated server-side data fetching function
const fetchData = () => {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve('Server-side data');
        }, 1000);
    });
};

export default MyComponent;




Lazy loading in react
*Lazy Loading in React
In React, Lazy loading is a technique that allows you to load components, modules, or assets asynchronously, improving the loading time of your application.
*It can be achieved by using the built-in React.lazy() method and Suspense component


Syntax
*This means you should identify components that:

Are heavy or complex, such as charts, modals, maps, or admin panels.

Are not needed immediately when the page first loads ‚Äî for example, components behind tabs, modals, or routes that users might not visit right away.
*Import the lazy() and Suspense components from the React package
*Use the lazy() function to dynamically import the component you want to lazy load:
Note that the argument to the lazy() function should be a function that returns the result of the import() function. 
const Component1 = lazy(() => 
	import("../src/LazyContent/myComponent1"));
*Wrap the lazy-loaded component in a Suspense component, which will display a fallback UI while the component is being loaded:
*import React from "react";
import { Suspense, lazy } from "react";
const Component1 = lazy(() => 
	import("../src/LazyContent/myComponent1"));
const Component2 = lazy(() => 
	import("../src/LazyContent/myComponent2"));
function App() {
	return (
		<>
			<h1> Lazy Load</h1>
			<Suspense
				fallback={<div>Component1 are loading please wait...</div>}
			>
				<Component1 />
			</Suspense>
			<Suspense
				fallback={<div>Component2 are loading please wait...</div>}
			>
				<Component2 />
			</Suspense>
		</>
	);
}

export default App;
*Normally in React, when your app loads, all components get bundled and loaded immediately, even if some components are not visible yet (like popups, tabs, or other pages).
*Don‚Äôt include the component in the initial bundle.

Wait until React is ready to actually show the component on screen ‚Äî only then fetch (download) its code.
*üßæ Example:
Let‚Äôs say you have a <Modal> component that only shows when a user clicks a button:

Without lazy loading: The modal component is loaded at the very beginning ‚Äî even if the user never opens it.

With lazy loading: The modal component is only loaded at the moment the user clicks the button.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*starting with the react basic concepts




*To begin, you will need Node.js and npm(Node Package Manager). Node.js is a JavaScript runtime that allows you to run JavaScript outside the browser, while npm is used to manage your project‚Äôs dependencies.
*Create a New React.JS Project
*1. Install Vite and Create a Project
npm create vite@latest my-react-app -- template react
*cd my-react-app
*npm install
*npm run dev
*Your new React project comes with a predefined structure. Here are the key files and folders you‚Äôll work with:

public/index.html: The single HTML file where your React app will be rendered.
src/index.js: The JavaScript entry point for your React application.
src/App.js: A basic React component that serves as the starting point for your app.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
React jsx
*JSX stands for JavaScript XML
*JSX combines HTML and JavaScript in a single syntax
*It simplifies rendering dynamic content by embedding JavaScript expressions inside HTML-like tags.

*it simplifies the dynamic content rendering such in any javascript expression we can write value as the htm taghs
*const element = <h1>Hello, world!</h1>;
*, allowing you to create UI components in React
*<h1>Hello, world!</h1> is the jsx
*When React processes this JSX code, it converts it into JavaScript using Babel.
*This JavaScript code then creates real HTML elements in the browser‚Äôs DOM . which is how your web page gets displayed.

*jsx transformation process
*Writing JSX: const element = <h1>Hello, World!</h1>;
*JSX Gets Transformed:as browsr only inderstood the js,JSX is not directly understood by browsers. So, it gets converted into JavaScript by a tool called Babel. After conversion, the JSX becomes equivalent to React.createElement() calls. After transformation JSX becomes.
*React Creates Elements:as we know browser will render real dom elements so react takes thi js code and
 create virtual dom for h1 tag and then updates the real dom elements which is rendersed on browser
*uses of jsx
1.we can directly insert the js expression inside the jsx using the {}
*const name = 'Jonny';
const greeting = <h1>Hello, {name}!</h1>;
2.here as attributes are being used in html same here attributes are used in jsx but some are written in camelCase such as class in html is written as className in jsx as class are reserved word in the js
3.In JSX, components or elements can accept children just like HTML elements.Children are nested elements or content that are passed into a component.
const Welcome = (props) => {
  return <div>{props.children}</div>;
};

const App = () => {
  return (
    <Welcome>
      <h1>Hello, World!</h1>
      <p>Welcome to React.</p>
    </Welcome>
  );
};
here welcome component uses props.childer to render the child element that was passed to welcome component .
4.first jsx is converted into js object using babel the react talks and convert into virtual dom element so that update can be made in real dom
{
  type: 'button',                 
  props: {                        
    className: 'btn',             
    onClick: () => alert('Clicked!'), 
    children: ['Click Me']        
  }
}//js object
const element = React.createElement(
  "button",
  {
    className: "btn",
    onClick: () => alert("Clicked!"),
  },
  "Click Me"
);
*uses of jsx
1.declarative ui:as html is being used in js file hence we can know hoe the component will render
2.cleaner syntax:as we need to write the React.createElement() for each element. 
3.Dynamic content:JSX makes it easy to embed dynamic content within your UI. JavaScript expressions can be placed inside {} within JSX tags, allowing for dynamic rendering of data and content.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
ReactJS Rendering Elements
*React elements are different from DOM elements 
*React elements are simple JavaScript objects and are efficient to create.
*in order to render the react element to be render in browser we first need to have the root dom elements
*iv element with the id=‚Äùroot‚Äù or id=‚Äùapp‚Äù to be used as the root DOM element.
*this is rrot dom elements
*so to render any element on the browser we need to render it first in the root dom element
*to render a React element, first pass the DOM element to ReactDOM.createRoot(), then pass the React element to root.render():
*const root = ReactDOM.createRoot(
  document.getElementById('root')
);
const element = <h1>Hello, world</h1>;
root.render(element);
*React elements are immutable. Once you create an element, you can‚Äôt change its children or attributes.
*means we cangen react element in code it wont be updated in ui
*so to get the updated ui is to call the render metjod again and agin
*const root = ReactDOM.createRoot(
  document.getElementById('root')
);

function tick() {
  const element = (
    <div>
      <h1>Hello, world!</h1>
      <h2>It is {new Date().toLocaleTimeString()}.</h2>
    </div>
  );
  root.render(element);
}

setInterval(tick, 1000);
*----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Componnet are building blick or piece of ui
*There are 2 types of component:


1.Functional Componnets
*ReactJS functional components are JavaScript functions that return a JSX element,
*originally before the introduction of hooks they were statelelss and was used to render the ui based on the props
* functional components do not have a this context.
*With hooks, functional components can manage state and side effects, making them just as powerful as class components.
*import React from 'react';

const MyComp = (props) => {
    return <div>Hello, {props.name}!</div>;
};

export default MyComp;
*is a JavaScript/ES6 function
must return a React element (JSX)
always starts with a capital letter (naming convention)
takes props as a parameter if necessary
*ere‚Äôs a breakdown of how this process works:

Props: Functional components receive input data through props, which are objects containing key-value pairs.
Processing Props: After receiving props, the component processes them and returns a JSX element that defines the component‚Äôs structure and content.
Virtual DOM: When the component is rendered, React creates a virtual DOM tree that represents the current state of the application.
Re-rendering: If the component‚Äôs props , React updates the virtual DOM tree accordingly and triggers the component to re-render.
*Uses of functional component
1.They are simple to read
2.They are faster than the class as there is no this keyword


Functional components should be used whenever possible because they are simpler, easier to test, and more performant than class componentsbut:
*(Before hoooks)Therefore, if you need to maintain state within your component, you may need to use a class component.
*(Before hooks)f you need to use lifecycle methods such as componentDidMount, componentDidUpdate, or componentWillUnmount, you will need to use a class component.

But for sttaemanagement now the functional component uses the usestate hook and the lifecycle methods the useeffect hooks


How to Pass Props to a ReactJS Functional Component:
*Props are used to pass data from a parent component to a child component
*Props are read-only 

*component dynamic by passing different values into it.





2.Class Componnet
*Class components are ES6 classes that extend React.Component.
class App extends React.Component

*if you want the state to be maintained inside the compnnet than the class component ,as they give the stateful component
*Support lifecycle methods for mounting, updating, and unmounting.
*The render() method in React class components returns JSX elements describing the UI of the Application.
*// Filename App.js
import React from "react";

class App extends React.Component {
    render() {
        return <h1>GeeksForGeeks</h1>;
    }
}

export default App;

Structure of React Class Components
1.Class Declaration: The component is declared as a class that extends React.Component. 
2.Constructor: The constructor() method is used to initialize the component‚Äôs state, but if used, it must call super(props) to initialize the parent Component class.
constructor(props) {
    super(props);
    this.state = { count: 0 }; // Initialize state
}
3.Render Method: The render() method is the only required method in a class component. It returns JSX, which represents the structure of the UI. 
4.State: Class components can manage their own internal state using the this.state property. 
*The state is mutable 
this.state = {

};
event handler functions often uses the  this.setState() to update the component‚Äôs state
increment = () => {
    this.setState({ count: this.state.count + 1 });
};
6.Props in Class Components:
*Props allow data to flow from parent components to child components. 
*props are ready only
*They are accessible via this.props

class MyComponent extends React.Component {
    render() {
        return <div>{this.props.name}</div>; // Access props
    }
}


Lifecycle Methods

*Lifecycle methods allow components to execute code at specific stages of their existence.
*Class components have access to the React lifecycle methods
1.Mounting
Mounting refers to the process of creating and inserting a component into the DOM for the first time in a React application
*constructor()
Method to initialize state
Executed before the component is mounted.*(first time render function is executed)
constructor(props) {
    super(props); // Always call super(props) before using this.props
    this.state = {
        count: 0, // Initial state
    };
    console.log("Constructor called");
}
*getDerivedStateFromProps(props, state)
Used for updating the state based on props
Executed before every render.
static getDerivedStateFromProps(props, state) {
    if (props.value !== state.value) {
        return { value: props.value }; // Update state based on new props
    }
    return null; // No changes to state
}
*render() method
Responsible for rendering JSX and updating the DOM.
render() {
    return (
        <div>
            <h1>Hello, React Lifecycle!</h1>
        </div>
    );
}
*componentDidMount() Function
his function is invoked right after the component is mounted on the DOM, i.e. this function gets invoked once after the render() function is executed for the first time.
omponentDidMount() {
    console.log("Component has been mounted");

    // Example: Fetch data from an API
    fetch("https://api.example.com/data")
        .then(response => response.json())
        .then(data => this.setState({ data }));
}


2.Updation
This phase occurs whenever a component‚Äôs internal state is modified or its parent component passes new props.
*getDerivedStateFromProps:getDerivedStateFromProps(props, state) is a static method that is called just before the render() method
*setState():This is not particularly a Lifecycle function and can be invoked explicitly at any instant.
this.setState((prevState, props) => ({
      counter: prevState.count + props.diff
}));
*shouldComponentUpdate() Is a lifecycle method in React class components that determines whether a component should re-render.
It compares the current and next props/states and returns true if the component should update or false if it should not.
shouldComponentUpdate(nextProps, nextState)
*getSnapshotBeforeUpdate() Method
* componentDidUpdate():this function gets invoked once after the render() function is executed after the updation of State or Props.



3.Unmounting
This is the final phase of the lifecycle of the component, which is the phase of unmounting the component from the DOM. 
*componentWillUnmount():This function is invoked before the component is finally unmounted from the DOM, i.e., this function gets invoked once before the component is removed from the page, and this denotes the end of the lifecycle.


// Filename - src/index.js:
import React from "react";
import ReactDOM from 'react-dom';
class Test extends React.Component {
    constructor(props) {
        super(props);
        this.state = { hello: "World!" };
    }
    componentDidMount() {
        console.log("componentDidMount()");
    }
    changeState() {
        this.setState({ hello: "Geek!" });
    }
    render() {
        return (
            <div>
                <h1>
                    GeeksForGeeks.org, Hello
                    {this.state.hello}
                </h1>
                <h2>
                    <a
                        onClick={this.changeState.bind(
                            this
                        )}
                    >
                        Press Here!
                    </a>
                </h2>
            </div>
        );
    }
    shouldComponentUpdate(nextProps, nextState) {
        console.log("shouldComponentUpdate()");
        return true;
    }
    componentDidUpdate() {
        console.log("componentDidUpdate()");
    }
}
const root = ReactDOM.createRoot(
    document.getElementById("root")
);
root.render(<Test />);
here initialy after first time render componentdidmount bt when clicked the shouldcompoennet update if true then compinnetdidupdate


What is the need for the react lifecycle?
*Data Fetching:
Lifecycle methods like componentDidMount() and componentDidUpdate() allow you to fetch data
*Performance Optimization:
.g., using shouldComponentUpdate() to prevent unnecessary re-renders
*Resource Management:using methods like componentWillUnmount()) to prevent memory leaks.
*
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Pros in component

*Props follow a top-down (unidirectional) data flow
Key Characteristics of Props:
*Immutable: Props cannot be modified by the receiving component.
*Read-Only: They are strictly for reading data and should not be altered.
*Dynamic: Props can be updated when the parent component‚Äôs state changes.


1.Using Props with Multiple Values
You can pass multiple props to a component by adding multiple attributes.
import React from "react";

function Profile(props) {
    return (
        <div>
            <h1>Name: {props.name}</h1>
            <p>Age: {props.age}</p>
        </div>
    );
}

function App() {
    return <Profile name="Raj" age={25} />;
}

export default App;
2.Default Props in React
You can set default values for default props using the defaultProps property

function Greet(props) {
    return <h1>Hello, {props.name}!</h1>;
}

Greet.defaultProps = {
    name: "Guest",
};

function App() {
    return <Greet />;
}

export default App;

3.Props in Class Components

n class components, props are accessed using this.props.



import React, { Component } from "react";

class Welcome extends Component {
    render() {
        return <h1>Welcome, {this.props.name}!</h1>;
    }
}

function App() {
    return <Welcome name="Anjali" />;
}

exp

ort default App;

4.Passing Functions as Props
You can pass functions as props to handle events or perform actions in child components.
function Button(props) {
    return <button onClick={props.handleClick}>Click Me</button>;
}

function App() {
    const handleClick = () => {
        alert("Button clicked!");
    };

    return <Button handleClick={handleClick} />;
}

export default App;

5.Children Prop
The children prop allows you to pass elements or components as children of another component that is also in render()
*function Wrap(props) {
    return <div className="Wrap">{props.children}</div>;
}

function App() {
    return (
        <Wrap>
            <h1>Hello, World!</h1>
        </Wrap>
    );
}

export default App;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
State in React Components:

n React, the state refers to an object that holds information about a component‚Äôs current situation. This information can change over time, typically as a result of user actions or data fetching, and when state changes, React re-renders the component to reflect the updated UI.
*const [state, setState] = useState(initialState);
*In this syntax

state: The current state value.
setState: A function that is used to update the state.
initialState: The initial value that the state will hold when the component is first rendered.


Creating State Object in class component

*We can create a state object within the constructor of the class component.
*import React from 'react';

class MyComponent extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            brand: 'Ford', // Example property in the state
        };
    }

    render() {
        return (
            <div>
                <h1>My Car</h1>
                {/* Other component content */}
            </div>
        );
    }
}

export default MyComponent;
*Updating State in React

We are using the ES6 thick arrow function format to take the previous state and props of the component as parameters 


Kry features of the State:
1.Encapsulation of Data: Each React component has its own state, and the state data is encapsulated within the component. This means that state is not shared across components unless explicitly passed via props.
2.Reactivity and Re-rendering:When state changes, React automatically triggers a re-render of the component to reflect the updated state in the UI. React ensures that only the parts of the UI that depend on the state are re-rendered, improving performance.
3.Mutable Within the Component: State is mutable, meaning you can change it using the setState() method (in class components) or the state-updating function returned by useState() (in functional components). 

State and props

state are within component and any state update will render stae relatd ui and are mutable and is used to render the dynamic content
props are shared between component and are immutable


when to use state
when you want dynamic cotent or user input
when you want to render the component based on the changes he had done.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Rendering a Component

*Composing Components:we can merge all of these individual components to make a parent component.import React from 'react';
import ReactDOM from 'react-dom';

// Navbar Component
const Navbar=()=>
{
	return <h1>This is Navbar.< /h1>
}

// Sidebar Component
const Sidebar=()=> {
	return <h1>This is Sidebar.</h1>
}

// Article list Component
const ArticleList=()=>
{
	return <h1>This is Articles List.</h1>
}

// App Component
const App=()=>
{
	return(
			<div>
				<Navbar />
				<Sidebar />
				<ArticleList />
			</div>
		);
}

ReactDOM.render(
	<App />, 
	document.getElementById("root")
);
2.Decomposing Components:Decomposing a Component means breaking down the component into smaller components

Let us see why there is a need to do so. Suppose we want to make a component for an HTML form. Let‚Äôs say our form will have two input fields and a submit button. We can create a form component as shown below: 
import React from 'react';
import ReactDOM from 'react-dom';

const Form=()=>
{
	return (
		<div>
			<input type = "text" placeholder = "Enter Text.." />
			<br />
			<br />
			<input type = "text" placeholder = "Enter Text.." />
			<br />
			<br />
			<button type = "submit">Submit</button>
		</div>
	);
}

ReactDOM.render(
	<Form />,
	document.getElementById("root")
);

suppose we wat frm with 2 input so need to write code agin instead brak form into 2 component one for imput and one for button
import React from 'react';
import ReactDOM from 'react-dom';

// Input field component
const Input=()=>
{
	return(
		<div>
			<input type="text" placeholder="Enter Text.." />
			<br />
			<br /> 
		</div>
	);
}

// Button Component
const Button=()=>
{
	return <button type = "submit">Submit</button>; 
}

// Form component
const Form=()=>
{
	return (
		<div>
			<Input />
			<Input />
			<Button />		 
		</div>
	);
}

ReactDOM.render(
	<Form />, 
	document.getElementById("root")
);
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
ReactJS Fragments:
*It allows you to return multiple child elements from a component without wrapping them in a parent container like a <div>.
Why Use React Fragments?
1.It reduces the counts of redundant wrapper elements.
2.It reduces the counts of redundant wrapper elements and hence speed increase
3.Key Support: Allows key usage in lists, improving React‚Äôs rendering efficiency.

How to Use React Fragments
1.Using Shorthand:The shorthand uses empty tags <> and </> to wrap multiple elements.
2.Using React.Fragment:Use the React.Fragment component directly
<React.Fragment>
    <h1>Title</h1>
    <p>Content</p>
</React.Fragment>;

Limitations of React Fragments:
1.No Attributes: React Fragments cannot accept attributes like className, id, or style. If you need to apply styles or identify elements, you still need a wrapper element like a <div>.
2.Cannot Manipulate Directly: Since React Fragments don‚Äôt create a DOM node, you can‚Äôt select them using functions like querySelector().
3.Limited to wrapping: Fragments can only support wrapping elements and not additional functionalities like handling events, styling, or layouts offered by a div.


----------------------------------------------------------------------------------------------------------------------------------------------------------------------
React js props set1
1.props are used to send information from one to others
2.they are immutable 
3.render the dynamic content

we can pass the props to c acomponnet same  as we pass the attribute in the html tags
/ Passing Props
<DemoComponent sampleProp = "HelloProp" />

// Accessing props in class components
this.props.propName;

// Accessing props in functional components 
props.propName;



here props are passed as the parameter in functional componnets
*// index.js

import React from "react";
import ReactDOM from "react-dom/client";

// functional component to illustrate props
function DemoComponent(props) {
	return (
		<div>
			{/*accessing information from props */}
			<h2>Hello {props.user}</h2>
			<h3>Welcome to GeeksforGeeks</h3>
		</div>
	);
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
	<React.StrictMode>
		<DemoComponent user="Geeks" />
	</React.StrictMode>
);


*when we want to store the default information for nay class we can use the defaultprops in which whatever will enetr will be aded to this.props oject
*import React from 'react';
import ReactDOM from 'react-dom';

// Component
class ExampleClass extends React.Component {
	render() {
		return (
			<div>
				{/* using default prop - title */}
				<h1>This is {this.props.title}'s Website!</h1>
			</div>
		);
	}
}

// Creating default props for 
// ExampleClass Component
ExampleClass.defaultProps = {
	title: "GeeksforGeeks"
}

ReactDOM.render(
	<ExampleClass />,
	document.getElementById("root")
);
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is ReactJS PropTypes?
PropTypes is a tool in React that helps us check if the data (props) being passed to a component is of the correct type.
*Since in the latest version of the React 19, Prototype has been removed.

How to Use PropTypes in React?
*
npm install prop-types
*
//src/components/Button.js

import React from 'react';
import PropTypes from 'prop-types';

const Button = ({ label, type }) => {
    return <button className={`btn btn-${type}`}>{label}</button>;
};

Button.propTypes = {
    label: PropTypes.string.isRequired,
    type: PropTypes.oneOf(['primary', 'secondary', 'danger']).isRequired,
};

export default Button;



*Common PropTypes Validators
1.PropTypes.string	Confirms the prop is a string.
2.PropTypes.number	Confirms the prop is a number.

Advanced PropTypes Usage
1.Default Props
By using the defaultProps we can also specify the default values for props. This is used when certain props are optional and we want to set a default value in case they are not passed.

2.proptype do runtime checking and the typescript does the compile tie checking
3.proptype validates the proptype whwre the typescript validate the props,function any many more
3.uses defaultprops to provide default value whwre typescript give default values directly in the types


----------------------------------------------------------------------------------------------------------------------------------------------------------------------
React Conditional Rendering:
*
*Conditional rendering allows dynamic control over which UI elements or content are displayed based on specific conditions
*conditions can be user input or teh state status or system sttaus


Ways to Implement Conditional Rendering in React
1.1. Using If/Else Statements
function Item({ name, isPacked }) {
    if (isPacked) {
        return <li className="item">{name} ‚úÖ</li>;
    }
    return <li className="item">{name}</li>;
}
note:This approach is useful for complex conditions.

2. Using Ternary Operator

*The ternary operator (condition ? expr1: expr2)
*two options to render.
*it is used if logic is simple
*function Greeting({ isLoggedIn }) {
    return <h1>{isLoggedIn ? "Welcome Back!" : "Please Sign In"}</h1>;
}


3.using logical &&
*if condition is true than return the second
*if false then return nothing

function Notification({ hasNotifications }) {
    return <div>{hasNotifications && <p>You have new notifications!</p>}</div>;
}
If hasNotifications is true: You have new notifications!
If hasNotifications is false: Nothing is rendered.

4.switch case
switch case ae used when we have multiple conditions means the propxy of multiple if else if
*function StatusMessage({ status }) {
    switch (status) {
        case 'loading':
            return <p>Loading...</p>;
        case 'success':
            return <p>Data loaded successfully!</p>;
        case 'error':
            return <p>Error loading data.</p>;
        default:
            return <p>Unknown status</p>;
    }
}

Practical use case of conditiona rendering:
1. Displaying User Profile Based on Authentication:
displaying user profile if its authenticated

import React, { useState } from 'react';

function App() {
    const [isAuthenticated, setIsAuthenticated] = useState(false);

    return (
        <div>
            {isAuthenticated ? (
                <h1>User Profile</h1>
            ) : (
                <button onClick={() => 
                    setIsAuthenticated(true)}>Log In</button>
            )}
        </div>
    );
}

export default App;
*here state tells that if its authenticated or mot


2.showing loading state 
import React, { useState, useEffect } from 'react';

function App() {
    const [isLoading, setIsLoading] = useState(true);
    const [data, setData] = useState(null);

    useEffect(() => {
        setTimeout(() => {
            setData('Fetched Data');
            setIsLoading(false);
        }, 2000);
    }, []);

    return (
        <div>
            {isLoading ? (
                <h1>Loading...</h1>
            ) : (
                <h1>{data}</h1>
            )}
        </div>
    );
}

export default App;





Performance Considerations in Conditional Rendering
1.Avoid unnecessary re-renders: Use React.memo() or shouldComponentUpdate() to prevent unnecessary rendering.
2.Lazy Load Components: Use React.lazy() to load components dynamically only when needed.
3.Short-circuit Evaluation (&&) is Useful but Risky: Ensure that the first condition is always a boolean, otherwise unexpected values may be rendered.



Best Practices for Conditional Rendering:
1.try to use ternary operator wherever possible
2.Early returns: Consider using early returns to handle conditions upfront, especially when there‚Äôs more than one condition.


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
React Lists

*React Lists are used to display a collection of similar data items like an array of objects and menu items. It allows us to dynamically render the array elements and display repetitive data.
*function App() {
    const items = ['Apple', 'Banana', 'Cherry'];

    return (
        <div>
            <h1>My Fruit List</h1>
            <ul>
                {items.map((item, index) => (
                    <li key={index}>{item}</li>
                ))}
            </ul>
        </div>
    );
}

export default App;
*In this example

The .map() function loops over the items array.
Each item is rendered inside an <li> tag.
The key prop should be added to uniquely identify each list item.

*Note
Use a unique identifier like id when available.

Why ‚Äòkey‚Äô Prop is Important in React Lists:
*key props is imp as it uniquely identify each list item and identify which items have changed,addd
*This allows React to efficiently update and re-render only the changed items in the DOM, rather than re-rendering the entire list.



Common Mistakes to Avoid in React Lists:
*Duplicate Keys: Avoid using the same key for multiple items. Use unique IDs.
*index as Key: Don‚Äôt use array index as key in dynamic lists. Use stable identifiers.
*Missing key Prop: Always include a key when mapping over items.

*Array Mutation: Don‚Äôt mutate original arrays (reverse, sort, etc.). Use copies ([‚Ä¶arr]).
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
React js keys
*keys rae unique identifier for eac item in list and identifier which identifies which item have been changed added and removed
*It is particulary useful when user modify list



Issue with index as keys
*1.suppose reordering happens and as index changes key change hence react dom will consider the new list and rendr whole lists,hence unncessar renders
*suppose we change the list like adding ,react dom will consider it as the new list and will render whole list hence unnecassart rr renders



Using Keys with Components
instead of using keys in indivisula list items use it in component that is rendering indivisula list items
import React from "react";
import ReactDOM from "react-dom";
// Component to be extracted
function MenuItems(props) {
    const item = props.item;
    return <li>{item}</li>;
}

// Component that will return an
// unordered list
function Navmenu(props) {
    const list = props.menuitems;
    const updatedList = list.map((listItems) => {
        return <MenuItems key={listItems.toString()} item={listItems} />;
    });

    return <ul>{updatedList}</ul>;
}

const menuItems = [1, 2, 3, 4, 5];

ReactDOM.render(
    <Navmenu menuitems={menuItems} />,
    document.getElementById("root")
);


Uniqueness of Keys:
keys must be unique within list not globally
This means that two different arrays can have the same set of keys without issues.

import React from "react";
import ReactDOM from "react-dom";
// Component to be extracted
function MenuItems(props) {
    const item = props.item;
    return <li>{item}</li>;
}

// Component that will return an
// unordered list
function Navmenu(props) {
    const list = props.menuitems;
    const updatedList = list.map((listItems) => {
        return <MenuItems key={listItems.toString()} item={listItems} />;
    });

    return <ul>{updatedList}</ul>;
}

const menuItems1 = [1, 2, 3, 4, 5];
const menuItems2 = [1, 2, 3, 4, 5, 6];

ReactDOM.render(
    <div>
        <Navmenu menuitems={menuItems1} />
        <Navmenu menuitems={menuItems2} />
    </div>,
    document.getElementById("root")
);
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
React js refs
*ReactJS Refs are function providd by react to access the dom element and the react element created from componnet
*they rae used where we want to change value of react component without making use of the state and props
*They allow us to interact with these elements outside the typical rendering workflow of React.
*They have wide functionality as we can use callbacks with them. 

Creating refs in React
Refs are generally used for the following purposes:
Managing focus, text selection, or media playback. as we will see how on text selection we are focussig 

Method 1: Using React.createRef().
It was introduced in React 16.3.
Create a ref variable using React.createRef()
Use the element‚Äôs ref attribute to attach the ref variable
// Importing everything as React
import * as React from "react";

const App = () => {
// Creating textInputRef variable
const textInputRef = React.createRef();

// This method will be used to focus textInput
const textInputFocusHandler = () => {
	// Focusing input element
	textInputRef.current.focus();
};

return (
	<div>
	
	{/** Attaching ref variable using element's ref attribute */}
	<input ref={textInputRef} type="text"
			placeholder="Enter something" />

	{/** Attaching textInputFocusHandler method to button click */}
	<button onClick={textInputFocusHandler}>
			Click me to focus input
	</button>
	</div>
);
};

export default App;

2.Using useRef() hook:
*Create a ref variable using React.useRef()
*Use the element‚Äôs ref attribute to attach the ref variable
*useRef() also takes an initial value.

// Importing everything as React
import * as React from "react";

const App = () => {
// Creating textInputRef variable with initialValue "null"
const textInputRef = React.useRef(null);

// This method will be used to focus textInput
const textInputFocusHandler = () => {
	// Focusing input element
	textInputRef.current.focus();
};

return (
	<div>
	
	{/** Attaching ref variable using element's ref attribute */}
	<input ref={textInputRef} type="text"
			placeholder="Enter something" />

	{/** Attaching textInputFocusHandler method to button click */}
	<button onClick={textInputFocusHandler}>
			Click me to focus input
	</button>
	</div>
);
};

export default App;


Benefits o ueRef over createRef is


*useRe willpersist same refobject even after rerenfder but createRef create ref object every time on re render
*useRef is muatate it does not allow re render




Accessing refs
*In React, when a ref is passed to an element in render using the ref attribute,React component becomes accessible at the current property of the ref.
*const node = this.myCallRef.current;
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
React Forms
*React forms are used toc ollect user inputs and manage data
*n React Forms, all the form data is stored in the React‚Äôs component state
*To do this we use controlled components.


Controlled Componnets
*in simple html as user type the dom element value changes
*but in react as type hat value get stored in ract state and that value is used to updated the dom so here we control dom elements value
**Uncontrolled Components are the components in which form data is handled by that do not rely on the React state 
*So in order to access any value that has been entered we take the help of state


Adding Forms in React
*we here store the when oncahnge is trigger the value in the state usong the setstte and display it using the state
*// Filename - index.js

import React from 'react';
import ReactDOM from 'react-dom';

class App extends React.Component {

    state = { inputValue: '' };

    render() {
        return (
            <div>
                <form>
                    <label> Enter text </label>
                    <input type="text"
                        value={this.state.inputValue}
                        onChange={(e) => this.setState(
                            { inputValue: e.target.value })} />
                </form>
                <br />
                <div>
                    Entered Value: {this.state.inputValue}
                </div>
            </div>
        );
    }
}

ReactDOM.render(<App />,
                document.querySelector('#root'));

*The submit action in React form is done by using the event handler onSubmit which accepts the submit function.



----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*Uncontrolled Components
*Uncontrolled Components are the components in which form data is handled by that do not rely on the React state and are handled by the DOM (Document Object Model).
*So in order to access any value that has been entered we take the help of refs.
*For instance, if we want to add a file as an input, this cannot be controlled as this depends on the browser so this is an example of an uncontrolled input.
*Example: We are creating a simple form that comprises an input field with a label name and a submit button with an onSubmit function that triggers when we submit the form. We are accessing the name we have filled using useRef.
*// FileName - App.js

import React, { useRef } from "react";
import "./App.css";

function App() {
    const inputRef = useRef(null);

    function handleSubmit() {
        alert(`Name: ${inputRef.current.value}`);
    }

    return (
        <div className="App">
            <h1 className="geeks">GeeksForGeeks</h1>
            <h3>Uncontrolled Component</h3>
            <form onSubmit={handleSubmit}>
                <label>Name :</label>
                <input
                    type="text"
                    name="name"
                    ref={inputRef}
                />
                <button type="submit">Submit</button>
            </form>
        </div>
    );
}

export default App;

*controlled components:
// FileName - App.js

import { useState } from "react";
import "./App.css";

function App() {
    const [name, setName] = useState("");

    function handleSubmit() {
        alert(`Name: ${name}`);
    }

    return (
        <div className="App">
            <h1 className="geeks">GeeksForGeeks</h1>
            <h3>Controlled Component</h3>
            <form onSubmit={handleSubmit}>
                <label>Name:</label>
                <input
                    name="name"
                    value={name}
                    onChange={(e) =>
                        setName(e.target.value)
                    }
                />
                <button type="submit">Submit</button>
            </form>
        </div>
    );
}

export default App;
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
React Hooks
*ReactJS Hooks are one of the most powerful features of React, introduced in version 16.8
*React Hooks are functions that allow functional components in React to manage state, handle side effects, and access other React features without needing class components. 
*Types of React Hooks:
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
1. State Hooks:

useState:
The useState hook is a function that allows you to add state to a functional component.
*It is used when we require the basic update
*Syntax

const [state, setState] = useState(initialState)
state: It is the value of the current state.
setState: It is the function that is used to update the state.
initialState: It is the initial value of the state.


How Does useState() Work?
1. Initialize State: When you call useState(initialValue), it creates a state variable and an updater function.
2. State is Preserved Across Renders: React remembers the state value between re-renders of the component
3.When you call setCount(newValue) React updates the state and it re-renders the component to reflect the new state value
4.React will re-render only the component where useState was used‚Äîensuring your UI updates automatically when the state changes.

Implementation of usestate 

1.Here is the implementation of the useState hook:
import { useState } from 'react';
export default function Counter() {
    const [count, setCount] = useState(0);

    function handleClick() {
        setCount(count + 1);
    }
    return (
        <button onClick={handleClick}>
            Click {count} me
        </button>
    );
}

Interesting Things About the useState Hook:
*useState is ideal for managing simple state updates, such as toggling values, counters, and form inputs.
*When updating state based on the previous state, always use a function to ensure the correct value:
setCount(prevCount => prevCount + 1);
3.State updates in React are asynchronous, meaning that setState does not immediately reflect changes
4.State Does Not Merge Automatically: Unlike this.setState in class components, useState does not merge objects automatically.

this.state = { name: 'Old Name', age: 25 };then this.setState({ name: 'Neha' }); this will automatically merge he resulting state will be:

js
{ name: 'Neha', age: 25 }

  in react functional You must spread the previous state manually
const [person, setPerson] = useState({ name: 'Old Name', age: 25 });

setPerson({ name: 'Neha' });  // ‚ùå age will be lost
setPerson(prev => ({ ...prev, name: 'Neha' }));




5.It‚Äôs particularly useful when the initial state requires a costly computation, like parsing large data, accessing localStorage, or running a complex calculation.
const [count, setCount] = useState(() => computeInitialValue());
Why use a function?
If you write useState(computeInitialValue()), the function runs on every render, even though React uses the return value only for the first render.
ou are not calling computeInitialValue() on the first render only ‚Äî you are calling it on every render by writing it as useState(computeInitialValue()).

The problem isn‚Äôt that React is calling it ‚Äî you are calling it before passing it to React, like this:

js
Copy
Edit
const value = computeInitialValue(); // <-- this runs every time
const [state, setState] = useState(value);

But with useState(() => computeInitialValue()), the function is called only once, during the initial render.

6.React skips re-renders if you update the state with the same value.
const [value, setValue] = useState(10);
setValue(10); // No re-render happens
------------------------------------------------------------------------------------------------------------------------------------------------------------------












useReducer Hook:
The useReducer hook is an alternative to the useState hook that is preferred when you have complex state logic.
*when you need to handle actions that can update the state differently.
*Syntax

const [state, dispatch] = useReducer(reducer, initialState);
reducer: A function that defines how the state should be updated based on the action. It takes two parameters: the current state and the action.
initialState: The initial value of the state.
Statestates: The current state returned from the useReducer hook.
dispatch: A function used to send an action to the reducer to update the state.

Implementing the useReducer hook

import React, { useReducer } from 'react';
const counterReducer = (state, action) => {
    switch (action.type) {
        case 'INCREMENT':
            return { count: state.count + 1 };
        case 'DECREMENT':
            return { count: state.count - 1 };
        default:
            return state;
    }
};
function Counter() {
    const [state, dispatch] = useReducer(counterReducer, { count: 0 });
    return (
        <div>
            <p>Count: {state.count}</p>
            <button onClick={() => dispatch({ type: 'INCREMENT' })}>Increment</button>
            <button onClick={() => dispatch({ type: 'DECREMENT' })}>Decrement</button>
        </div>
    );
}
export default Counter;
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

2.Context Hooks

What is the React Context API?


*At its core, the Context API is a mechanism that allows you to share specific information (like state or functions) with multiple components,eliminating the prop drll
*How Context API Works:
1. Creating a Context:
The process begins by creating a context using the createContext() method.

/ Creating a context
const MyContext = React.createContext();

2. Providing the Context
now thw context provider is applied around all those components who wants to access the data and value is provided as props 

3. Consuming the Context value
*function AnotherComponent() {
  const contextValue = React.useContext(MyContext);

  // Now, contextValue contains the shared value
}



useContext Hook
*The useContext hook in React allows components to consume values from the React context.
*useContext is a part of React‚Äôs hooks system, introduced in React 16.8


Syntax

const contextValue = useContext(MyContext);
MyContext: The context object is created using React.createContext().
contextValue: The current context value that we can use in our component.
*When the value of the Context updates, all components consuming that context automatically re-render with the new value.


Implementing the useContext Hook
*1. Managing Authentication with useContext
useContext can be used for managing the user authentication state globally.

import React, { createContext, useContext, useState } from 'react';
const AuthContext = createContext();
function AuthProvider({ children }) {
    const [isLoggedIn, setIsLoggedIn] = useState(false);
    return (
        <AuthContext.Provider value={{ isLoggedIn, setIsLoggedIn }}>
            {children}
        </AuthContext.Provider>
    );
}
function LoginButton() {
    const { isLoggedIn, setIsLoggedIn } = useContext(AuthContext);
    return (
        <button onClick={() => setIsLoggedIn(!isLoggedIn)}>
            {isLoggedIn ? 'Logout' : 'Login'}
        </button>
    );
}
function App() {
    return (
        <AuthProvider>
            <LoginButton />
        </AuthProvider>
    );
}
export default App;

2.Sharing a Theme Across Components
We will create a theme context and use useContext to access its values in child components.


When to Use useContext
*We want to avoid prop drilling.
*We need state sharing between multiple components without a third-party state management library.
*We need global state management for themes, authentication, or user preferences.



--------------------------------------------------------------------------------------------------------------------------------------------------------------------
3.Effect Hooks
*
Effect hooks, specifically useEffect, useLayoutEffect, and useInsertionEffect, enable functional components to handle side effects 
*



ReactJS useEffect Hook
*The useEffect hook is one of the most commonly used hooks in ReactJS used to handle side effects in functional components such as  fetching data and updating DOM
*these kinds of tasks were only possible in class components through lifecycle methods like componentDidMount, componentDidUpdate, and componentWillUnmount.
* This hook runs on every render but there is also a way of using a dependency array using which we can control the effect of rendering.

It can be used to perform actions such as:

1.Fetching data from an API.
2.Manipulating the DOM directly (although React generally handles DOM manipulation for you).
3.clean up when component unmounts

useEffect(() => {
    // Code to run on each render
    return () => {
        // Cleanup function (optional)
    };
}, [dependencies]);
*effect function wjere sideefefct code runs
*rturn function is optionsl and it cleasn the side effect
*ddpenedency aray 



How does it work?
*initial rnder happens
*useEffect Executes After Render: It runs after the paint, not during render.
*Dependencies Are Checked:if no dependency then on every render if empty ([]), it runs once on the mount,if dependency tahn after every if dependencies are provided, it runs only when those values change.
*Cleanup Function Runs: Before the effect re-runs or the component unmounts, the cleanup function (returned from useEffect) is executed.


Controlling side effects in useEffect:
1. To run useEffect on every render do not pass any dependency
2.To run useEffect only once on the first render pass any empty array in the dependency
3.To run useEffect on change of a particular value. Pass the state and props in the dependency array


Ways to mimic lifecycle methods using useEffect hook
*Mimicking componentDidMount: To run code once when the component mounts, pass an empty dependency array ([]) to useEffect
2.To run code every time a specific state or prop changes, include those variables in the dependency array. This simulates componentDidUpdate.
3.To run cleanup logic when the component unmounts, return a cleanup function from useEffect. This simulates componentWillUnmount.
useEffect(() => {
    return () => {
        console.log("Component unmounted (Functional)");
    };
}, []);



Cleaning Up Side Effects:
useEffect allows you to clean up after your effects by returning a cleanup function. This is particularly useful for:
*Canceling network requests.
*Clearing timers or intervals.






useLayoutEffect
useLayoutEffect: The useLawetEffect is used when we need to measure or manipulate the lawet before the browser paints, ensuring smooth transitions and no flickering













--------------------------------------------------------------------------------------------------------------------------------------------------------------------
4. Performance Hook

*React js useMemo hook
*The useMemo Hook is a built-in React Hook that helps optimize performance
*memorizing/storing the result of a computation and resuding it every time on re render until and unless dependency changes
*Let's now see some of the Practical Applications of useMemo
1. Optimizing Expensive Calculations
*import React, { useState, useMemo } from "react";

function App() {
    const [number, setNumber] = useState(0);
    const squaredNum = useMemo(() => squareNum(number), [number]);
    const [counter, setCounter] = useState(0);
    const onChangeHandler = (e) => {
        setNumber(e.target.value);
    };
    const counterHander = () => {
        setCounter(counter + 1);
    };
    return (
        <div className="App">
            <h1>Welcome to Geeksforgeeks</h1>
            <input
                type="number"
                placeholder="Enter a number"
                value={number}
                onChange={onChangeHandler}
            ></input>

            <div>OUTPUT: {squaredNum}</div>
            <button onClick={counterHander}>Counter ++</button>
            <div>Counter : {counter}</div>
        </div>
    );
}
function squareNum(number) {
    console.log("Squaring will be done!");
    return Math.pow(number, 2);
}
export default App;

2.2. Preventing Unnecessary Re-renders
*Sometimes, passing objects or arrays as props to child components can trigger unnecessary re-renders due to reference changes. 
*import React, { useState, useMemo } from "react";

function Child({ userInfo }) {
    console.log("Child component rendered");
    return <p>User: {userInfo.name}</p>;
}
function Parent() {
    const [count, setCount] = useState(0);
    const userInfo = useMemo(() => ({ name: "GeeksforGeeks" }), []);
    return (
        <div>
            <p>Count: {count}</p>
            <Child userInfo={userInfo} />
            <button onClick={() => setCount(count + 1)}>Increment Count</button>
        </div>
    );
}
export default Parent;


When to Use useMemo?
*You have expensive calculations that do not need to be re-executed unless certain dependencies change.
*You want to prevent unnecessary re-renders of child components by ensuring stable references.


----------------------------------------------------------------------------------------------------------------------------------------------------------------------
useCallBackHooks
*The useCallback Hook is a built-in React Hook that memoizes a callback function and use it on everyrender until and unless thre is no dependency changes
*but if dependency changes take places than the callback function is again create
Without the useCallback Hook

import React, { useState } from "react";

const funcSet = new Set();

const App = () => {
    const [cnt, setCnt] = useState(0);
    const [num, setNum] = useState(0);

    const incCnt = () => setCnt(cnt + 1);
    const decCnt = () => setCnt(cnt - 1);
    const incNum = () => setNum(num + 1);

    funcSet.add(incCnt);
    funcSet.add(decCnt);
    funcSet.add(incNum);
    alert(funcSet.size);

    return (
        <div>
            <h2>Without useCallback Hook</h2>
            <button onClick={incCnt}>Increase Counter</button>
            <button onClick={decCnt}>Decrease Counter</button>
            <button onClick={incNum}>Increase Number</button>
        </div>
    );
};

export default App;

The issue here is that every time the component re-renders, new function references are created,inefficient memory usage.and if they are passed as props than the unnecessary re renders in the chikd component


Using useCallback Hook
*To solve this problem, we can use the useCallback hook. The useCallback hook is essential for optimizing performance in React applications, especially when passing callbacks to child components.
*import React, { useState, useCallback } from "react";

const funcSet = new Set();

const App = () => {
    const [cnt, setCnt] = useState(0);
    const [num, setNum] = useState(0);

    const incCnt = useCallback(() => setCnt(cnt + 1), [cnt]);
    const decCnt = useCallback(() => setCnt(cnt - 1), [cnt]);
    const incNum = useCallback(() => setNum(num + 1), [num]);

    funcSet.add(incCnt);
    funcSet.add(decCnt);
    funcSet.add(incNum);
    alert(funcSet.size);

    return (
        <div>
            <h2>With useCallback Hook</h2>
            <button onClick={incCnt}>Increase Counter</button>
            <button onClick={decCnt}>Decrease Counter</button>
            <button onClick={incNum}>Increase Number</button>
        </div>
    );
};

export default App;
*When to Use useCallback?
You should use useCallback when

Passing functions as props to child components to prevent unnecessary re-renders.
Ensuring function references remain stable across renders.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
5. Custom Hooks:
What Are Custom Hooks?
*A custom hook is a JavaScript function that starts with use
*and internally calls other hooks like useState, useEffect, or useContext.
*It allows developers to extract reusable logic,
*function useCustomHook() {
    // Use built-in hooks here
    return someValue;
}


Steps to Create a Custom Hook
1.1. Define a Function That Starts with use
*Custom hooks must follow React's naming convention and start with use
*This ensures React recognizes it as a hook and enforces hook rules.
*function useCustomHook() {
    // Hook logic here
    return someValue;
}



2.Use React's Built-in Hooks Inside Your Custom Hook
*Custom hooks can use useState, useEffect, useContext, etc., to manage state, handle side effects, or access context.

3.4. Return Necessary Values
*Your custom hook should return state, functions, or values that components need, such as fetched data, loading state, or error messages.


Implementing A Custom Hook
*returning state and function to reate the toggle functionality
function useToggle(initialValue = false) {
    const [state, setState] = useState(initialValue);
    const toggle = () => setState(prev => !prev);
    return [state, toggle];
}

2.craeting custom hooks to ftch the data and return data and the loading
*import { useState, useEffect } from 'react';

function useFetch(url) {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        fetch(url)
            .then((response) => response.json())
            .then((data) => {
                setData(data);
                setLoading(false);
            });
    }, [url]);

    return { data, loading };
}
function DataComponent() {
    const { data, loading } = useFetch("https://jsonplaceholder.typicode.com/todos/1");

    return (
        <div>
            {loading ? <p>Loading...</p> : <p>Data: {JSON.stringify(data)}</p>}
        </div>
    );
}

export default DataComponent;


3.Creating a Custom Hook for the Save Button with Online/Offline Status
//src/useOnlineStatus.js
import { useState, useEffect } from 'react';

function useOnlineStatus() {
    const [isOnline, setIsOnline] = useState(navigator.onLine);

    useEffect(() => {
        function handleOnline() {
            setIsOnline(true);
        }
        function handleOffline() {
            setIsOnline(false);
        }

        window.addEventListener('online', handleOnline);
        window.addEventListener('offline', handleOffline);

        return () => {
            window.removeEventListener('online', handleOnline);
            window.removeEventListener('offline', handleOffline);
        };
    }, []);

    return isOnline;
}

export default useOnlineStatus;

When to Use Custom Hooks
1.We need to reuse logic across multiple components.
2.our components cleaner and more focused on UI rendering

Rules for using Hooks
Only functional components can use hooks
Hooks must be imported from React
Calling of hooks should always be done at top level of components
Hooks should not be inside conditional statements


----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*React Routing
1.React Routing is a technique used to handle navigation within a React application
*It enables users to move between different views, pages, or components without refreshing the entire page, which is a key feature of Single Page Applications (SPAs).
What is Navigation in React?
*Navigation refers to the process of moving between different views or sections within a React application. 
*n React, most applications are developed as Single Page Applications (SPA)



*A Single Page Application (SPA) is a type of web application that loads and updates content dynamically without refreshing the entire page
*This is achieved by ensuring that the browser obtains all essential HTML, JavaScript, and CSS codes in one request or updates the necessary content based on user actions.
*When you click on something in a SPA, it only sends the necessary information to your browser and the browser renders it.
*This is different from a traditional page load, where the server sends a full page to your browser with every click you make.


When to use SPA?
*user interaction and dont want full reload
*Real-Time Updates: Opt for SPAs when real-time responsiveness is crucial for a seamless user experience.
*Use SPAs for mobile-friendly apps, providing an app-like feel with smooth transitions.


SPA Architecture and How Does it Work?
It contains 3 rendering



Client-side rendering
First browser requests HTML from the server.
Then server swiftly responds with a basic HTML file and linked styles/scripts.
Now user sees a blank page or loader while JavaScript executes.
App fetches data, creates views, and injects them into the DOM.

Client-Side Rendering (CSR) can be slower for basic websites because it uses a lot of device resources.
*Just remember, if you want different social sharing options, you might need Server-Side Rendering (SSR) or Static Site Generation (SSG) instead.



Server side rendering
*The browser first asks the server for an HTML file.
*Now server gathers necessary data, builds the SPA, and creates an HTML file instantly.
*Now user sees the content ready to go.
*Single-page app structure adds events, makes a virtual DOM, and gets things ready.
*Now, the application is set for use.





To implement routing in React we do not have in-built modules but instead, we use the react-router-dom module after installing and importing it.

// Installing
npm i react-router-dom
// Importing
import { BrowserRouter } from 'react-router-dom';

BrowserRouter to enable routing in your app.
*Programmatic navigation allows you to navigate between different routes based on actions, such as button clicks or form submissions. 
*his method provides more control over routing, enabling navigation in response to events triggered by the user.
*Create 2 basic pages between which you want to redirect
Create buttons on each page to redirect the user
Import the useNavigate hook provided with react-router-dom
Use this hook on the onClick event button to redirect



// App.js

import { BrowserRouter, Routes, Route } from "react-router-dom";
import "./App.css";
import AboutUs from "./components/AboutUs";
import ContactUs from "./components/CotactUs";

function App() {
    return (
        <div className="App">
            <BrowserRouter>
                <Routes>
                    <Route exact path="/" element={<AboutUs />} />
                    <Route exact path="/contactus" element={<ContactUs />} />
                </Routes>
            </BrowserRouter>
        </div>
    );
}

export default App;//uyse of browserrputer routes and route
*// AboutUs.js

import React from "react";
import { useNavigate } from "react-router-dom";

function AboutUs() {
    const nav = useNavigate();
    return (
        <div>
            <h2>GeeksforGeeks is a computer science portal for geeks!</h2>
            Read more about us at :
            <a href="https://www.geeksforgeeks.org/about/">
                https://www.geeksforgeeks.org/about/
            </a>
            <br></br>
            <br></br>
            <button
                onClick={() => {
                    nav("contactus");
                }}
            >
                Click Here to check contact details
            </button>
        </div>
    );
}
export default AboutUs;//use of useNavigation() hook
*// ContactUs.js

import React from "react";
import { useNavigate } from "react-router-dom";

function ContactUs() {
    const nav = useNavigate();
    return (
        <div>
            <address>
                You can find us here:
                <br />
                GeeksforGeeks
                <br />
                5th & 6th Floor, Royal Kapsons, A- 118, <br />
                Sector- 136, Noida, Uttar Pradesh (201305)
            </address>
            <br></br>
            <br></br>
            <button
                onClick={() => {
                    nav(-1);
                }}
            >
                Click Here to Go Back
            </button>
        </div>
    );
}

export default ContactUs;
*



Dynamic Routing with React router
*Dynamic routing allows you to define routes dynamically based on certain conditions
Approach
Create a page which will create Link components using map
Create a page which will display data dynamically using useParams
Create a dynamic Route component which passes the id as a parameter
// App.js

import { BrowserRouter, Routes, Route, Link } from "react-router-dom";
import CourseDetails from "./components/CourseDetails";

function App() {
    const courses = ["JavaScript", "React", "HTML", "DSA"];
    return (
        <BrowserRouter>
            <h1>Dynamic Routing with React</h1>
            <ul>
                {courses.map((course) => {
                    return (
                        <li key={course}>
                            <Link to={`courses/${course}`}>{course}</Link>
                        </li>
                    );
                })}
            </ul>
            <Routes>
                <Route path="courses/:courseId" element={<CourseDetails />} />
            </Routes>
        </BrowserRouter>
    );
}

export default App;
// components/CourseDetails.js

import { useParams } from "react-router-dom";

function CourseDetails() {
    const { courseId } = useParams();
    return (
        <div>
            <h1>This is {courseId} course</h1>
        </div>
    );
}

export default CourseDetails;



Handling 404 Errors (Page Not Found)
*Sometimes user types a URL which does not exist in the website and the router fails and shows an error
*To solve this problem we create a universal Route component,suchthat if no exact route match it will redirect tothis universal route omponnent
*// App.js

import logo from "./logo.svg";
import { BrowserRouter, Routes, Route } from "react-router-dom";
import "./App.css";
import NavBar from "./components/Navbar";
import Home from "./components/Home";
import AboutUs from "./components/AboutUs";
import ContactUs from "./components/CotactUs";
import NoPageFound from "./components/NoPageFound";

function App() {
    return (
        <div className="App">
            <BrowserRouter>
                <NavBar />
                <Routes>
                    <Route exact path="/" element={<Home />} />
                    <Route exact path="/about" element={<AboutUs />} />
                    <Route exact path="/contact" element={<ContactUs />} />
                    <Route path="*" element={<NoPageFound />} />
                </Routes>
            </BrowserRouter>
        </div>
    );
}

export default App;
// NoPageFound.js

export default function NoPageFound() {
    return <h1>Error 404: Page Not Found</h1>;
}
*here if ny ther route than the no opage fiund error
*----------------------------------------------------------------------------------------------------------------------------------------------------------------------
React js react dom


What is ReactDOM ?
*The ReactDOM in React is responsible for rendering the elements or Components in the actual DOM of the web page
*t is a package in React that provides DOM-specific methods that can be used at the top level of a web app to enable an efficient way of managing DOM elements of the web page



How to use ReactDOM ?
*npm i react-dom 
*import ReactDOM from 'react-dom'


Why ReactDOM is used ?
*earlier any user wil update the real do element directly ,an update then browser will load whole ui again and hence processing and time increased
*The Virtual DOM can be referred to as a copy of the actual DOM representation that is used to hold the updates made by the user and finally reflect it over to the original Browser DOM at once consuming much lesser time. 


Important Methods of ReactDOM
1.render():It is used to display the component on the UI returned as HTML or JSX components.The ReactDOM.render() function takes two arguments, HTML code and an HTML element.
*The purpose of the function is to display the specified HTML code inside the specified HTML element.
*In the render() method, we can read props and state 
*In the render() method, we cannot change the state, and we cannot cause side effects( such as making an HTTP request to the webserver).
*import React, { Component } from "react";
export default class App extends Component {
    state = {
        PawriDays: [
            { id: "123s", Day: "Monday" },
            { id: "234r", Day: "Saturday" },
            { id: "12d5", Day: "Sunday" },
        ],
    };

    render() {
        const PartyDays = this.state.PawriDays.length;
        const style = {
            textAlign: "center",
            color: "green",
        };

        // Return JSX code
        return (
            <div style={style}>
                <h1>I am User</h1>
                <p> We party: {PartyDays} days a week </p>
            </div>
        );
    }
}












2.findDOMNode() Method:
*findDOMNode in React is used to directly access a component's underlying DOM node.
*It is mainly used in class components for DOM manipulation, animations, or integration with third-party libraries.
* It's considered unsafe in modern React development.
*ReactDOM.findDOMNode(component)
*The component can be either a React component instance or a DOM element. When passed, it retrieves the corresponding DOM node associated with the component.
*Return Value:The findDOMNode() method returns the DOM node associated with the specified React component or null if the component is not mounted.
*// Filename - App.js

import React from "react";
import ReactDOM from "react-dom";

// Defining our App Component
const App = () => {
    // Function to get element from findDOMNode()
    function find() {
        const node = document.getElementById("node");
        const a = ReactDOM.findDOMNode(node);
        console.log(a);
        if (a) {
            a.style.color = "green";
            a.style.fontSize = "x-large";
        }
    }

    // Returning our JSX code
    return (
        <>
            <div>
                <h1>GeeksforGeeks</h1>
                <div id="node">DOM Node</div>
                <button onClick={find}>Click to find</button>
            </div>
        </>
    );
};

// Exporting your Default App Component
export default App;

here node is the dom element and the a is the resut of finddomemethod
*note:this is wrong as find findDOMNode works only on the react component not dom elements
*for this we have used in function component we uses the useref import React, { useRef } from "react";

const App = () => {
    const divRef = useRef(null);

    function find() {
        if (divRef.current) {
            divRef.current.style.color = "green";
            divRef.current.style.fontSize = "x-large";
        }
    }

    return (
        <div>
            <h1>GeeksforGeeks</h1>
            <div ref={divRef}>DOM Node</div>
            <button onClick={find}>Click to find</button>
        </div>
    );
};

export default App;








3.unmountComponentAtNode():
*Each Component has its own lifecycle
*React provides us with some in-built methods that we can override at particular stages in the life-cycle of the component.
*In class-based components, the unmountComponentAtNode() method Remove a mounted React component from the DOM.
*import React from 'react'
import ReactDOM from 'react-dom';

// Exporting your App Component
export default function App() {

  // Function to unmount root component
  function unm() {
    ReactDOM.unmountComponentAtNode(document.getElementById("root"));
  }

  return (
    <div>
      <h1>GeeksforGeeks</h1>
      <div>Hi Geek, this is the rendered content</div>
      <button onClick={unm}>Unmount</button>
    </div>
  );
}





4.hydrate(): This method is equivalent to the render() method but is implemented while using server-side rendering
5.portal
*So far we were having one DOM element in the HTML
*the root element of our index.html in the public folder. Basically, we mount our App component onto our root element
*It is almost a convention to have a div element with the id of root to be used as the root DOM element.
*DOM tree every single React component in our application falls under the root element, i.e., inside this statement.
*But React Portals provide us the ability to break out of this dom tree and render a component onto a dom node that is not under this root element.
*They are commonly used in modal dialog boxes, hovercards, loaders, and popup messages.
ReactDOM.createPortal(child, container)
*Parameters: Here the first parameter is a child which can be a React element, string, or a fragment and the second parameter is a container which is the DOM node (or location) lying outside the DOM hierarchy of the parent component at which our portal is to be inserted.
*



*<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <title>React App</title>
  </head>
  <body>
    <noscript>
      You need to enable JavaScript to run this app.
    </noscript>
    <div id="root"></div>
    
    <!-- new div added to access the child component -->
    <div id="portal"></div>
  </body>
</html>
*import ReactDOM from 'react-dom'
function App() {

  // Creating a portal
  return ReactDOM.createPortal(
    <h1>Portal demo</h1>,
    document.getElementById('portal')
 )
}

export default App;
*import ReactDOM from 'react-dom'
function App() {

  // Creating a portal
  return ReactDOM.createPortal(
    <h1>Portal demo</h1>,
    document.getElementById('portal')
 )
}

export default App;


----------------------------------------------------------------------------------------------------------------------------------------------------
How to use events in ReactJS ?
*Handling events with React elements is very similar to handling events on DOM elements.
They only have some syntax differences:
1.React events are named using camelCase, rather than lowercase.
2.in the dom we use to pass addeventlistenr as string but here we pass as the function
*In DOM:

<button onclick="printValues()">  Print</button>
*In React: 

<button onClick={printValues}>  Print</button>
*note:The preventDefault() method is used to prevent the browser from executing the default action of the selected element.
*It can prevent the user from processing the request by clicking the link.
*event.preventDefault()
*It does not accept any parameter. The event is used to denote the event
*<!DOCTYPE html>
<html lang="en">

<head>
    <title> preventDefault() Event Method </title>
    <!-- INCLUDE THE JQUERY CDN -->
    <script src=
"https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script type="text/javascript">
        $(document).ready(function () {
            $("a").click(function (event) {
                event.preventDefault();
                alert("prevented");
            });
        });
    </script>
</head>

<body>
    <p>Click the link:</p>
    <a href="https://www.google.com">GOOGLE</a>
</body>

</html>


note:import "./App.css";
function App() {
    const handleOnSubmit = (e) => {
        e.preventDefault();
        console.warn("You clicked on submit function")
    };
    return (
        <>
            <h1>This is React WebApp </h1>
            <form action="">
                <button type="submit" onClick={handleOnSubmit}>
                    submit
                </button>
            </form>

        </>
    );
}

export default App;
by defaukt when no action provided then page will reload and action provide then navigate to that url,we dont want this daefault behavior so  const handleOnSubmit = (e) => {
        e.preventDefault();
        console.warn("You clicked on submit function")
    };

----------------------------------------------------------------------------------------------------------------------------------------------------
What are synthetic events in ReactJS ?

*Different browsers historically had slightly different ways of handling events ‚Äî like: Different method names
*React wanted to:Avoid writing separate logic for each browser
*Synthetic events in React are cross-browser wrappers around the browser's original event
*e.preventDefault()       // prevents all the default behavior by the browser.
e.stopPropagation()   // prevents the call to the parent component whenever a child component gets called.
*e is cross browser obect craeseted from the synthetic event which is wrapper around the native browser



----------------------------------------------------------------------------------------------------------------------------------------------------
Benefits of Context API over React Redux
*n Redux we have to manipulate or update multiple files to add even a single feature but in Context it can be done in much lesser lines of code
--------------------------------------------------------------------------------------------------------------------------------------------------
ReactJS Pure Components
*ReactJS Pure Components are similar to regular class components but with a key optimization
*They skip re-renders when the props and state remain the same

How Does a Pure Component Work?
*A PureComponent works by implementing the shouldComponentUpdate() lifecycle method
*If the props or state of the component have changed (using a shallow comparison), the component re-renders.
*If they haven‚Äôt changed, React skips the re-render, thus improving performance by preventing unnecessary updates. 


When Should You Use Pure Components?
whwre performance is a concern
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
React Component Based Architecture
*React is a popular JavaScript library for building user interfaces (UI)
*primarily for single-page applications (SPAs)
*One of React‚Äôs important feature is component-based architecture
*
What is Component-Based Architecture?
* Components allows you to break down an application into smaller, independent pieces that can be managed
*thye are resusable 
*they interact to form complete ui
*This modular structure makes the application easier to develop, maintain, and scale, as components can be reused across different parts of the app or even in different projects.
*Each React application consists of a tree of components whwre each component has its state and logic 

Key Features of React‚Äôs Component-Based Architecture
*Reusability: Components can be used multiple times in different parts of an application.
*Modularity: Each component handles a specific piece of functionality, making the application more structured.
*Scalability: Large applications can be developed by assembling smaller, reusable components.
*Maintainability: Updates and bug fixes are easier because changes are localized to specific components.


Core Principles of React Component-Based Architecture
*Composition over Inheritance: React encourages composition, where components are combined to build complex UIs rather than relying on inheritance.
*One-Way Data Flow: React follows a unidirectional data flow, meaning data moves from parent components to child components via props.
*components are reusable


Advantages of Component-Based Architecture
* Components can be reused across multiple applications or within the same app.
*Isolated components make it easier to debug and maintain code.
*Enhanced Collaboration: Different developers can work on different components simultaneously.
*Improved Performance: With optimizations like React.memo(), components can be rendered efficiently.

Challenges in Component Based Architecture

1.Managing state across multiple components can become complex in large applications.
2.Passing data between components via requests and responses can add overhead.
3.Separating components can be difficult, leading to maintenance issues.
4.Testing Complexity: Testing components in isolation and mocking dependencies can be challenging.
5.Routing Management: Handling complex or nested routes can become cumbersome.


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Controlled vs Uncontrolled Components in ReactJS

What are Controlled Components?


*This means that the component's state is stored in a React component's state using the usesttae ook or the this.sttae and update using teh setstsate method
*Features of Controlled:
1.Form data is handled by the component's state using React's useState hook or this.state in class components.
2.data flow is like the input vlue set to state and any updates on elements reflected throught setsttae method
3.Enables immediate validation and formatting of user input.
4.Since the state is managed by React, the component's behavior is predictable and consistent.
5.The state serves as the single source of truth for the form data.

Uncobtrolled componnets
*An uncontrolled component in React refers to a component where the form element's state is not directly controlled by React.
*the form element itself maintains its own state, and React only interacts with the element indirectly through references

Features of Uncontrolled Components
*DOM-Managed State: Form data is handled by the DOM itself, not by React state.
*Use of Refs: Access to form values is achieved using React's useRef() or createRef() to reference DOM elements directly.
* Eliminates the need for state variables and event handlers for each input field.
*Validation and formatting need to be handled manually, often during form submission.
*component behavior is not predictable


Key Differences Between Controlled and Uncontrolled Components
1.state management:
Controlled: Uses React state as the source of truth.
Uncontrolled: Uses the DOM to maintain internal state

2.Data Flow:
Controlled: Data flows from React state to input.
Uncontrolled: Data flows from the input to React only when accessed via refs.

3.Validation and Formatting:
Controlled: Can validate or format input in real-time.
Uncontrolled: Validation usually occurs on form submission.

4.Complexity:
Controlled: Requires more boilerplate (state and handlers).
Uncontrolled: Simpler and quicker to implement for basic cases.

5.Performance:
Controlled: May cause more re-renders, as each keystroke updates state.
Uncontrolled: Potentially better for large forms or infrequent value access.

6.Use Cases:
Controlled: Complex forms, instant feedback, dynamic UI.
Uncontrolled: Simple forms, legacy code, quick prototypes.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ReactJS Component Composition
*With the help of Component Compositions, we can solve this problem by combining the components into a single component.
*What is Component Composition?
*Component composition in React includes one or more components in a single component
*It provides the following advantages:
*Reusability: In the different parts of the application, the components can be reused.
Maintainability: In the application, it is easier to update and manage the code.
*import React from "react";

const Header = () => <header><h1>Welcome to My Website</h1></header>;
const Content = () => <main><p>This is the main content section.</p></main>;
const Footer = () => <footer><p>¬© 2024 My Website</p></footer>;

const App = () => {
    return (
        <div>
            <Header />
            <Content />
            <Footer />
        </div>
    );
};

export default App;
*
Higher-Order Components (HOCs)
*Higher-order components (HOC) are an advanced technique in React that is used for reusing component logic without duplicationg
*It is the function that takes the original component and returns the new enhanced component.
*It doesn‚Äôt modify the input component directly. Instead, they return a new component with enhanced behavior.
*They are pure functions that accept a component and return a new component.

const EnhancedComponent = higherOrderComponent(OriginalComponent);
*higherOrderComponent is a function that takes an existing component (OriginalComponent) as an argument.
*It returns a new component (EnhancedComponent) with additional functionality or behavior.

Implementation of the Higher-Order Components
*import React from "react";
import "./App.css";
import withName from './Components/Name'; // Import the HOC
// Functional component
const App = (props) => {
  return <h1>{props.name}</h1>;
};
// Wrap the App component with the HOC to create the enhanced version
const EnhancedComponent = withName(App);
// Export the enhanced component
export default EnhancedComponent;
*suppose i want the this app component logic to be used without duplicating
*import React from 'react';
// Higher-Order Component (HOC) as a functional component
const withName = (OriginalComponent) => {
  const NewComponent = (props) => {
    return <OriginalComponent {...props} name="GeeksforGeeks" />;
  };
  return NewComponent;
};
export default withName;
*HOC Definition: withName is a Higher-Order Component (HOC) that adds a name prop with the value "GeeksforGeeks" to any component passed into it.


Reason to Use Higher-Order Components
1.Code Reusability
magine you have 10 components, and you want to pass the same name="GeeksforGeeks" to each one.

You‚Äôd have to write the same code again and again:
const Comp1 = (props) => <h1>{props.name}</h1>;
const Comp2 = (props) => <h1>{props.name}</h1>;
...
const Comp10 = (props) => <h1>{props.name}</h1>;

// When using them:
<Comp1 name="GeeksforGeeks" />
<Comp2 name="GeeksforGeeks" />
...
<Comp10 name="GeeksforGeeks" />

‚úÖ Solution With HOC:
const withName = (Component) => {
  return (props) => <Component {...props} name="GeeksforGeeks" />;
};
hen you wrap all 10 components:

js
Copy
Edit
const Comp1WithName = withName(Comp1);
const Comp2WithName = withName(Comp2);
...
const Comp10WithName = withName(Comp10);
ow, you don‚Äôt need to pass the name prop manually:


2.Separation of Concerns: They help separate the logic and UI, making components easier to manage and maintain..App just focuses on rendering the name. Logic for where the name comes from is abstracted to the H

3.‚úÖ Enhanced Readability
Each component has one job: either rendering UI (like App) or adding logic (like withName).

4.‚úÖ Maintainability
If tomorrow you want to change the name to come from an API or config, you only update the HOC ‚Äî not all components.


Best Practices for Using (HOC)
*Don‚Äôt Overuse HOCs: Use HOCs only when necessary. Too many HOCs can make your code complex and harder to manage.
*Use for Reusable Logic: HOCs are good for adding common features (like authentication or loading states) across multiple components.
*Pass All Props: Make sure the HOC passes all the props from the original component to the new one, unless you specifically want to modify or add something.
*Name Components Clearly: Always give meaningful names to wrapped components, which helps in debugging and readability.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------ReactJS Container and Presentational Pattern in Components
*The type of components is decided by components pattern
*If the component decides how the data will be presented on the screen it is called as presentational component.
*If the component focuses on what data is to be shown to the user then it is called as container component


Presentational components:
*Mainly concerned with how things look.
*No connection with the specification of the data that is outside the component.
*Mainly receives data and callbacks exclusively via props.
*// presentational component
const Users = props =>
(<ul>
    {props.users.map(user =>
        (<li>{itr}</li>))
    }
</ul>)



Container
Mainly concerned with how things work

They focus on the logic, state management, and data fetching, not on how things look.

May contain both presentational and container components but do not have DOM and markup of their own

Their role is not to render HTML or style elements. Instead, they pass data and actions to presentational components that handle UI.

Provide the data and behavior to presentational or other container components

They fetch data (e.g., from APIs or Redux store), manage state, and pass necessary props to child components.



*// Container Component
import React, { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import UserList from './UserList'; // Presentational Component
import { fetchUsers } from '../actions/userActions';

const UserListContainer = () => {
  const dispatch = useDispatch();
  const users = useSelector(state => state.users);

  useEffect(() => {
    dispatch(fetchUsers());
  }, [dispatch]);

  return <UserList users={users} />;
};

export default UserListContainer;
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------


What is Props?
*props are read-only data passed from one component to another
*They are immutable, meaning the child component cannot modify the props it receives
*Only the parent component can alter the data passed through props
*React enforces a unidirectional data flow, meaning that data typically flows from the parent component down to the child
* However, props can also be used to pass callback functions, allowing child components to communicate with the parent and trigger changes in state or behaviour.
*Props can be updated when the parent component‚Äôs state changes.
*With the help of Props, we can make components reusable and dynamic by allowing different data to be passed into a component at runtime. This flexibility helps you to create components that can display dynamic content depending on the props they receive.

*Note =>  Props can be used in both functional and class components. With functional components, props are passed as arguments to the function.
*give example of the class and functional


How Do Props Work in React?
*Define an attribute and its value (data).
*pass this data using the props 
*render the data using props

Passing Functions as Props:
*We can pass not only data (like strings, numbers, etc.) but also functions from a parent component to a child component using props.
* This is useful when we want the child component to trigger an action in the parent component
*import React from 'react';
import Child from './Child';

function Parent() {
    const handleClick = () => {
        alert('Button clicked in Child!');
    };

    return <Child onClick={handleClick} />;
}

export default Parent;
*import React from 'react';

function Child(props) {
    return <button onClick={props.onClick}>Click Me!</button>;
}

export default Child;



How to Set a Default Value for Props
*In React, defaultProps is a special property that allows us to set default values for props
*This is useful when no value is passed for a prop
*import React from 'react';

function Greeting(props) {
    return <h1>Hello, {props.name}!</h1>;
}

Greeting.defaultProps = {
    name: 'Guest',
};

export default Greeting;



Destructuring Props in React
*In React, props are often passed as an object to the component.


How To Pass Props From Parent to Child Component in ReactJS?
*in functional
*in class
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
How to Pass Data From Child Component To Its Parent In ReactJS ?

*In ReactJS, the flow of data is typically one-way, meaning data is passed from parent to child components using props. However, there are situations where you may need to pass data from a child component back up to its parent component.




Why Do We Need to Pass Data From Child to Parent?
*Passing data from a child to a parent is necessary in situations where the parent needs to update its state or trigger certain actions based on data from a child. Common scenarios include

Key Points for Passing Data from Child to Parent in ReactJS
*Props are Unidirectional: In ReactJS, data flows from parent to child through props. However, props can‚Äôt be used to pass data from child to parent directly.
*To pass data from a child component to its parent, a callback function can be passed from the parent to the child as a prop.
*State Management: The callback function updates the state in the parent component, allowing it to react to changes in the child component.

How to Pass Data From Child to Parent in ReactJS
*// Filename - App.js

import React from "react";
import Child from "./Child";
class App extends React.Component {
    state = {
        name: "",
    };

    // Callback function to handle data received from the
    //child component
    handleCallback = (childData) => {
        // Update the name in the component's state
        this.setState({ name: childData });
    };

    render() {
        const { name } = this.state;
        return (
            <div>
                <Child
                    parentCallback={this.handleCallback}
                />
                {name}
            </div>
        );
    }
}
export default App;

// Filename - component/Child.js

import React from "react";
class Child extends React.Component {
    // Function triggered when the form is submitted
    onTrigger = (event) => {
        // Call the parent callback function
        this.props.parentCallback(
            event.target.myname.value
        );
        event.preventDefault();
    };

    render() {
        return (
            <div>
                <form onSubmit={this.onTrigger}>
                    <input
                        type="text"
                        name="myname"
                        placeholder="Enter Name"
                    />
                    <br></br>
                    <br></br>
                    <input type="submit" value="Submit" />
                    <br></br>
                    <br></br>
                </form>
            </div>
        );
    }
}
export default Child;

Advantages of Passing Data from Child to Parent
*State Management: This approach allows the parent to maintain the state and share it with other components.
*Event Handling: It allows the child component to trigger events in the parent, which is useful for handling actions or logic that needs to happen in the parent.
*Reusable Child Components: By passing data back to the parent, child components can be made more reusable and independent of the parent‚Äôs state.

Common use cases
*Form Handling: Sending form data from child to parent for submission or validation.
*User Interaction: Updating the parent‚Äôs UI based on user actions in the child (e.g., when a button is clicked or a selection is made).


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------What is Prop Drilling and How to Avoid it?
*Prop drilling refers to the practice of passing data through several layers of nested components in React, even though intermediate components don't directly utilize this data
*This means that a middle component doesn't necessarily need the data, but it must still pass it down to the next component, creating an unnecessary and sometimes lengthy chain of props.
*import React from "react";

// Parent component that holds the message and passes it down
function Parent() {
    const message = "Hello from Parent";
    return (
        <div>
            <Child message={message} />
        </div>
    );
}

function Child({ message }) {
    return (
        <div>
            <Grandchild message={message} />
        </div>
    );
}

function Grandchild({ message }) {
    return (
        <div>
            <p>Message: {message}</p>
        </div>
    );
}

export default function App() {
    return (
        <div>
            <Parent />
        </div>
    );
}
*
problems with the props drilling
*Code Complexity: It makes the component tree overly complicated, as intermediate components receive and forward props without using them, cluttering your code and causing confusion.
*Tight Component Coupling: Components become less reusable and more tightly coupled, leading to reduced flexibility and difficulties in refactoring.
*Maintenance Overhead: Any change to the props requires updating multiple components, which can be time-consuming and error-prone.
*Scalability Issues: As your application grows, prop drilling worsens, leading to further complexity and making the app harder to scale effectively.

How to Avoid Prop Drilling Problem?
*1. Using Context API
2. Using Custom Hooks
3.3. Global State Management (Redux, Zustand, MobX)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Aspect

 *Modification

Can be changed by the component itself.

Cannot be changed by the receiving component; props are read-only.

*Communication

Facilitates communication within a component.

Facilitates communication between components (from parent to child).State                                                                                                                                     Props
*Re-rendering

Changes in state trigger a re-render of the component where the state is modified.

Changes in props cause a re-render of the child component that receives them, but the parent manages them.

*Component Type

State is used in class components (via this.state and this.setState) or functional components (via useState).

Props are used in both class and functional components.


When to Use State and Props?
Use State when you need to manage data that can change over time within a component (e.g., form inputs, counters, UI toggles) to show dynamic content
Use Props when you need to pass data from a parent component to a child component to make components reusable.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Reacts js hooks
*React hooks are functions that allow you to use state and other React features(side effects) in functional components.
*Hooks were introduced in React 16.8
*enabling developers to manage state and lifecycle features without needing class components
*import React, { useState } from 'react';
import './App.css'

const App = () => {
    const [num, setNum] = useState(0);
    const handleClick = () => {
        setNum(num + 1);
    };

    return (
        <div className="App">
            <h2> {num}</h2>
            <button onClick={handleClick}>
                Add one
            </button>
        </div>
    );
};

export default App;

*Why Use React Hooks?
1.Simplifies Code: Hooks provide a simpler and cleaner way to write components by using functions instead of classes.
2.State and Side Effects: Hooks allow you to use state (useState) and side effects (useEffect) in functional components.
3.Reusability: Hooks make it easier to share logic across components by creating custom hooks.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

React useState Hook
1.The useState hook is a function that allows you to add state to a functional component
2.It is used to make th basic update

How Does useState() Work?
The useState() hook allows you to add state to functional components in React. It works by:
*1. Initialize State: When you call useState(initialValue), it creates a state variable and an updater function.
*State is Preserved Across Renders
*When you call setCount(newValue) React updates the state and it re-renders the component to reflect the new state value.
* React will re-render only the component where useState was used


Interesting Things About the useState Hook
*useState is ideal for managing simple state updates, such as toggling values, counters, and form inputs.
* When updating state based on the previous state, always use a function 
*State updates in React are asynchronous, meaning that setState does not immediately reflect changes.
*Unlike this.setState in class components, useState does not merge objects automatically. You must spread the previous state manually
*If initializing state is expensive, you can use a function to compute it only once.
*React skips re-renders if you update the state with the same value.

When to Use useState
We should use the useState Hook when:

We need a simple state management solution.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------Performance Considerations
While useReducer provides structure and clarity, it can be more complex and may add some overhead if used unnecessarily. Here are some performance considerations:

Avoid overuse: If your state management is simple, useState might be more efficient. Use useReducer for complex or shared state logic.
Optimal re-renders: Since useReducer uses a single state object and dispatches actions, it can help avoid unnecessary re-renders, making it more efficient in larger applications with complex interactions.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
useRef hooks
*The useRef Hook is a built-in React Hook that returns a mutable reference object (ref) that persists across renders
*Unlike state variables, updating a ref does not trigger a component re-render.
*const refContainer = useRef(initialValue);
*useRef returns an object { current: initialValue }.
*The .current property can be updated without re-rendering the component.

Implementing the useRef hook
1. Accessing the DOM using useRef hook.

*In this example, we have a button called ACTION, whenever we click on the button the onClickHandler gets triggered and it focuses the textarea with the help of useRef hook.
*import React, { Fragment, useRef } from 'react';

function App() {
    const focusPoint = useRef(null);
    const onClickHandler = () => {
        focusPoint.current.value =
            "The quick brown fox jumps over the lazy dog";
        focusPoint.current.focus();
    };
    return (
        <Fragment>
            <div>
                <button onClick={onClickHandler}>
                    ACTION
                </button>
            </div>
            <label>
                Click on the action button to
                focus and populate the text.
            </label><br />
            <textarea ref={focusPoint} />
        </Fragment>
    );
};
export default App;

2. Persisting Values Across Renders
*useRef is useful for storing values that persist across renders
*A common use case is storing a previous value, such as the previous state or props.
*import React, { useState, useRef, useEffect } from "react";
function PreviousValue() {
    const [count, setCount] = useState(0);
    const prevCountRef = useRef();

    useEffect(() => {
        prevCountRef.current = count;
    }, [count]);

    return (
        <div>
            <p>Current count: {count}</p>
            <p>Previous count: {prevCountRef.current}</p>
            <button onClick={() => setCount(count + 1)}>Increment</button>
        </div>
    );
}
export default PreviousValue;

Interesting Things About useRef Hook
*aces do elements
*to store value that persisit on rerender.So it is used to store the value such as previous state or value


When to Use useRef?
You should use useRef when

Accessing and manipulating DOM elements without triggering re-renders.
Persisting values across renders without causing re-renders.
Storing previous state values to compare changes between renders.


----------------------------------------------------------------------------------------------------------------------------------------------------------------------
React-Router Hooks
*React-Router is a popular React library that is heavily used for client-side routing 
*offers single-page routing
*t provides various Component APIs( like Route, Link, Switch, etc.) that you can use in your React application to render different components based on the URL pathnames on a single page.
*You need to have React >= 16.8 installed on your device, otherwise the hooks won't work.

What are React Router Hooks?
*React Router hooks are the predefined functions used to interact with the router 
*manage navigation, and url parameters in functional components
*These hooks are provided by the React Router


Hooks Of React Router 5:
These are 4 React Router Hooks in v 5





useHistory Hook:
* It lets you access the history instance used by React Router
*Using the history instance you can redirect users to another page
*The history instance created by React Router uses a Stack( called "History Stack" ), that stores all the entries the user has visited.
*import { useHistory } from "react-router-dom";
// Inside a functional component
export default function SomeComponent(props){
    // The useHistory() hook returns the history
    // object used by React Router
    const history = useHistory();
}
*The history object returned by useHistory() has various properties and methods.
properties:
*length: Returns a Number. The number of entries in the history stack
*location: Returns an object that represents the current location. It may have the following properties
 *pathname: A string containing the path of the URL
 *search: A string containing the URL query string
 *state: when this location was pushed onto the stack,An object containing location-specific state  e.g. push(path, state)



methods:
*push(path, [state]): Pushes a new entry onto the history stack. Useful to redirect users to page
*replace(path, [state]): Replaces the current entry on the history stack
*go(n): Moves the pointer in the history stack by n entries
*goBack(): Equivalent to go(-1).
*goForward(): Equivalent to go(1).
*Blocks navigation. It takes a callback as a parameter and invokes it after the navigation is blocked.
Most useful when you want to first confirm if the user actually wants to leave the page.

// Filename - LogIn.js

import { useHistory } from "react-router-dom";
import { useState } from "react";

// A function that authenticates the users
function authenticateUser(userName, password) {
    // Some code to authenticate the user
}

// Hooks must be used inside a functional component
export default function Login(props) {
    //Creating a state variable
    const [userName, setUserName] = useState("");
    const [password, setPassword] = useState("");

    // Accessing the history instance created by React
    const history = useHistory();

    // Handle the user clicks the login button
    const handleClick = () => {
        // Authenticate the user
        authenticateUser(userName, password);

        // When the authentication is done
        // Redirect the user to the `/profile/${userName}` page
        // the below code adds the `/profile/${userName}` page
        // to the history stack.
        history.push(`/profile/${userName}`);
    };

    return (
        <div>
            <input
                type="text"
                value={userName}
                onChange={(e) => {
                    setUserName(e.target.value);
                }}
                required
            />
            <input
                type="text"
                value={password}
                onChange={(e) => {
                    setPassword(e.target.value);
                }}
                required
            />
            <button type="submit" onClick={handleClick}>
                {" "}
                Log In{" "}
            </button>
        </div>
    );
}
*That's what the last line of handleClick function does. "useHistory()" hook returns the history instance created by React Router, and history.push("/profile/John") adds the given URL to the history stack which results in redirecting the user to the given URL path.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
useParams Hook:
*This hook returns an object that consists of all the parameters in URL
*import { useParams } from "react-router-dom";
// Inside a functional component
export default function SomeComponent(props){
    const params = useParams();
}
*These URL parameters are defined in the Route
*<Route path="/profile/:userName" component={Profile} />
*The colon(":") after "/profile/" specifies that "userName" is actually a variable or parameter that is dynamic. 
*For example, in the url "/profile/johndoe", "johndoe" is the value of the parameter "userName". So, in this case, the object returned by useParams()
*{
   userName: "johndoe"
}
*// Filename - App.js

import { Route, Switch } from "react-router-dom";
import Home from "./components/Home";
import ContactUs from "./components/ContactUs";
import LogIn from "./components/LogIn";
import AboutUs from "./components/AboutUs";
import Profile from "./components/Profile";

export default function App() {
    return (
        <div className="App">
            <Switch>
                <Route path="/" exact>
                    <Home someProps={{ id: 54545454 }} />
                </Route>
                <Route path="/about">
                    <AboutUs />
                </Route>
                <Route path="/contact-us">
                    <ContactUs />
                </Route>
                <Route path="/log-in">
                    <LogIn />
                </Route>
                {/* userName is now a variable */}
                <Route path="/profile/:userName">
                    <Profile />
                </Route>
            </Switch>
        </div>
    );
}
*// Filename - Profile.js

import { useParams } from "react-router-dom";

export default function Profile(props) {
    // useParams() returns an object of the parameters
    // defined in the url of the page
    // For example, the path given in the Route component
    // consists of an "userName" parameter
    // in this form ---> "/profile/:userName"
    const { userName } = useParams();

    return (
        <div>
            <h1> Profile of {userName}</h1>

            <p> This is the profile page of {userName}</p>
        </div>
    );
}






useLocation Hook
*This hook returns the location object used by the react-router.
*This object represents the current URL
*and is immutable 
*Whenever the URL changes, the useLocation() hook returns a newly updated location object
*Some of its use includes extracting the query parameters from the URL
*doing something depending on the query parameters.
*The "search" property of the location object returns a string containing the query part of the URL.measn after ?
*import { useLocation } from "react-router-dom";
// Inside functional component
export default function SomeComponent(props){
    const location = useLocation();
}
*Note: history.location also represents the current location, but it is mutable, on the other hand, the location returned by useLocation() is immutable. So, if you want to use the location instance, it is recommended to use the useLocation() hook.
*// Filename - Profile.js

import { useLocation } from "react-router-dom";

export default function Profile(props) {
    const location = useLocation();

    // location.search returns a string containing all
    // the query parameters.
    // Suppose the URL is "some-website.com/profile?id=12454812"
    // then location.search contains "?id=12454812"
    // Now you can use the URLSearchParams API so that you can
    // extract the query params and their values
    const searchParams = new URLSearchParams(
        location.search
    );

    return (
        <div>
            {
                // Do something depending on the id value
                searchParams.get("id") // returns "12454812"
            }
        </div>
    );
}









useRouteMatch Hook
*Returns a match object that contains all the information like how the current URL matched with the given path pattern.
*Properties:

params: This is an object that contains the variable part of the URL after :
isExact: This is a boolean value, indicating whether the entire URL matched with the given Router path.
path: A string that contains the path pattern.we supplied
url:A string that contains the matched portion of the URL. It can be used for nested <Link />s and <Route />s.


import { useRouteMatch } from 'react-router-dom';

const Product = () => {
  const match = useRouteMatch('/products/:id');

  console.log(match);
  return <div>Product Details Page</div>;
};
{
  path: "/products/:id",      // the route pattern you provided
  url: "/products/123",       // the matched portion of the URL
  isExact: true,              // true if entire URL matched
  params: { id: "123" }       // dynamic parameters in the URL
}

----------------------------------------------------------------------------------------------------------------------------------------------------
Reason to use React Router Hooks
Before React Router 5:
*By default, while using the component prop (<Route component={} />), React router passes three props(match, location, history) to the component that the Route renders.
*That means, if you, for some reason, want to access the history or location instance used by React router, you can access it through the default props.
*But if you pass your custom props to your components then the default props get overridden by your custom props.
*As a result, you will not have any further access to the history object created by React Router
*And before React Router 5, there was no way other than using the render prop (<Router render={} />) to explicitly pass the location, match, and history instance as props.







With React Router 5 Hooks:
*Now with React Router 5, you can easily pass your custom props to the rendering component.
*Though in this case also those three props (match, location, history) don't get past the rendered components automatically, we can now use the hooks provided by React Router 5, and we don't need to think about the props anymore. You can directly access the history object by using the useHistory hook, location object with useLocation hook, and match the object with useRouteMatch hook, and you don't have to explicitly pass the props to the components.  
---------------------------------------------------------------------------------------------------------------------------------------------------

UseNavigat() hook
*React Router v6 introduces the useNavigate() hook, making it easier and more flexible to navigate between different pages in your app
*It replaces the older useHistory() hook
With the useNavigate() hook, you can:
*Go to a different page in your app.
*Navigate based on actions like button clicks.
*Send data or parameters when moving to another page.




How to Use useNavigate() for Navigation?
*npm install react-router-dom@6
*const navigate = useNavigate();
*navigate('/path');  // Navigates to '/path'
suppose we are o login page we click login then we add code navigate('/dashboard')
*This will:

Add a new entry to the browser history.

If the user clicks the back button, they'll go back to the previous page (e.g., login).
*Redirect with { replace: true }
js
Copy
Edit
navigate('/dashboard', { replace: true });
This will:

Replace the current history entry (e.g., login) with /dashboard.

The back button will not take the user back to login ‚Äî it's been replaced.
Note:This is useful for cases like login redirects,


*Step 6: Navigating Back and Forward
To navigate back in the browser‚Äôs history, use a negative number (e.g., -1), and to move forward, use a positive number (e.g., 1):




Best Practices for Using useNavigate() in ReactJS
*Avoid Navigation in Render Phase: Don‚Äôt trigger navigation during the component's render. Use effects (like useEffect) or conditional checks for more efficient navigation.
*Use { replace: true } for One-Time Redirects: For actions like login or logout, use { replace: true } to prevent users from going back to the previous page after the redirect.
*Pass State for Sharing Data: When navigating, pass state to share data across routes, making it easier to transfer information between components.


When to Use useNavigate() vs. <Link>
*üß≠ useNavigate() ‚Äî Programmatic Navigation

*A React Router hook that lets you navigate in response to logic in your JavaScript code, not direct user clicks.
Situation	Why use useNavigate()?
‚úÖ After login or logout	Redirect user to dashboard or login screen
‚úÖ After form submission	Navigate to a confirmation page
‚úÖ Conditional logic	Navigate only if a condition is met
‚úÖ Button click with logic	Run some code, then navigate


What it is:
Components provided by React Router to let users navigate by interacting with the UI (like clicking a menu item or navigation link).
‚úÖ Use Cases:
Situation	Why use <Link> or <NavLink>?
‚úÖ Menu items or sidebars	Users should click to go to other pages
‚úÖ Tab or button navigation	Static routes tied to visual UI
‚úÖ Breadcrumbs	Users navigate backward manually
--------------------------------------------------------------------------------------------------------------------------------------------------
ReactJS useLayoutEffect Hook
*useLayoutEffect runs synchronously after all DOM mutations but before the browser paints.
*It's ideal when you read or change layout or style (like measuring elements or setting scroll position) before paints

üîÅ Comparison: useLayoutEffect vs useEffect
Feature	useEffect	useLayoutEffect
Runs after paint?	‚úÖ Yes	‚ùå No
Runs before paint?	‚ùå No	‚úÖ Yes
Blocking paint?	‚ùå No	‚úÖ Yes (blocks browser paint until finished)
Use case	API calls, subscriptions	Measuring DOM, fixing layout before paint
Risk of flicker?	‚ö†Ô∏è Possible	‚ùå Prevents it


*Real-World Example: Measuring and Setting Height
*Goal:
Measure the height of a div and display it inside the component.
*import React, { useRef, useState, useEffect } from 'react';

function BoxEffect() {
  const boxRef = useRef(null);
  const [height, setHeight] = useState(0);

  useEffect(() => {
    const boxHeight = boxRef.current.getBoundingClientRect().height;
    setHeight(boxHeight);
  }, []);

  return (
    <div>
      <div ref={boxRef} style={{ height: '150px', background: 'salmon' }}>
        Measured Height (useEffect): {height}px
      </div>
    </div>
  );
}

*import React, { useRef, useState, useEffect } from 'react';

function BoxEffect() {
  const boxRef = useRef(null);
  const [height, setHeight] = useState(0);

  useEffect(() => {
    const boxHeight = boxRef.current.getBoundingClientRect().height;
    setHeight(boxHeight);
  }, []);

  return (
    <div>
      <div ref={boxRef} style={{ height: '150px', background: 'salmon' }}>
        Measured Height (useEffect): {height}px
      </div>
    </div>
  );
}
----------------------------------------------------------------------------------------------------------------------------------------------------
forwsrd ref hook
*React.forwardRef is a function that lets your parent component access a DOM element inside a child functional component using a ref.
*Sometimes the parent component wants to do something like focus an input field inside a child component. To do that, the parent needs a reference (ref) to the child‚Äôs DOM element ‚Äî but React blocks that by default unless you explicitly forward it.
*function InputBox() {
  return <input type="text" />;
}

function ParentComponent() {
  const inputRef = React.useRef();

  return (
    <>
      <InputBox ref={inputRef} /> {/* ‚ùå This doesn't work */}
      <button onClick={() => inputRef.current.focus()}>Focus</button>
    </>
  );
}

*const InputBox = React.forwardRef((props, ref) => {
  return <input type="text" ref={ref} />;
});

function ParentComponent() {
  const inputRef = React.useRef();

  return (
    <>
      <InputBox ref={inputRef} />
      <button onClick={() => inputRef.current.focus()}>Focus</button>
    </>
  );
}


*ref	Lets parent interact with a DOM element
Problem	Functional components don‚Äôt accept ref by default
forwardRef	Enables functional components to accept and forward ref
Use case	Focusing inputs, calling methods on child components

----------------------------------------------------------------------------------------------------------------------------------------------------
React.js useImperativeHandle Additional Hook
*The useImperativeHandle hook in react is used to modify the dom lements  of child component while using refs
*useImperativeHandle(ref, createHandle, [deps])
*ref: The ref passed from the parent component.
*createHandle: A function returning an object that exposes specific methods or properties of child dom elements
*deps: Optional dependency array to create custom handles.



Returns:

It gives access to customize the instances.


*// Filename - App.js

import React, { useRef } from "react";
import Input from "./Input";

const App = () => {
	const inputRef = useRef(null);
	return (
		<div>
			<Input onFocus={() => inputRef.current.focus()} ref={inputRef} />
		</div>
	);
};

export default App;
*// Filename - Input.js

import React, { useRef, useImperativeHandle, forwardRef } from "react";

function Input(props, ref) {
	const btn = useRef();
	useImperativeHandle(ref, () => ({
		focus: () => {
			console.log("Input is in focus");
		}
	}));
	return <input ref={btn} {...props} placeholder="type here" />;
}

export default forwardRef(Input);
---------------------------------------------------------------------------------------------------------------------------------------------------
ReactJs useDebugValue Hook
*React useDebugValue Hook is introduced for the ReactJs versions above 18. 
*React useDebugValue Hook helps developers debug custom hooks in React Developer Tools by adding additional information and labels to those hooks.

Approach:
*To better understand React JS useDebugValue Hook we will create a custom hook for number count that increases the count at a set interval.
*Inside that we will use the useDebugValue hook to update the value in Developers tool when the count is updated.
*// Filename  - App.js

import { useDebugValue, useState } from "react";

function useCount() {
    const [count, setCount] = useState(0);

    setInterval(() => {
        setCount(count + 1);
    }, 4000);

    useDebugValue(count);
    return count;
}

function App() {
    const count = useCount();

    return (
        <div className="App">
            <button>{count}</button>
        </div>
    );
}

export default App;
----------------------------------------------------------------------------------------------------------------------------------------------------
ReactJS useUndoState hook
*The useUndoState hook is a custom hook provided by the Rooks package for React
*It is similar to the useState hook in addition to undo functionality.
Arguments:
*initialValue: It is of the type boolean that describes the initial value of the state. Its default value is false.
*Options: It is of the type object which accepts a maxSize that governs the maximum number of previous states it keeps track of. Its default maxSize value is 100.

Return Value: It returns an array that has the following attributes:
*value: It describes the current value of the state.
setValue: It is of the type function that updates the value of the state.
undo: It is of the type function that undoes states value.


How to do it :
*npm i rooks

function App() {
  const [value, setValue, undo, redo, canUndo, canRedo] = useUndoState('');

  return (
    <div>
      <input
        value={value}
        onChange={(e) => setValue(e.target.value)}
      />
      <div>
        <button onClick={undo} disabled={!canUndo}>Undo</button>
        <button onClick={redo} disabled={!canRedo}>Redo</button>
      </div>
      <p>Current Value: {value}</p>
    </div>
  );
}

*‚ú® Output Example
Type "A" ‚Üí Value is A

Type "B" ‚Üí Value is B

Click Undo ‚Üí Value goes back to A

---------------------------------------------------------------------------------------------------------------------------------------------------
ReactJS useSelect hook
*The useSelect is a custom hook provided by the Rooks package for React
*It is a list selection hook that helps select values from a list.
*Arguments:

list: It is of the type array which describes the list of items for the selection. The default value is undefined.
initialIndex -It is of the type number which describes the initially selected index. The default value is 0.


Return Value- Object that contains the following attributes:
index: It is of the type int which describes the currently selected index.
item: It denotes the currently selected item.
setIndex:  It is of the type function which updates the index.
setItem: It is of the type function which updates the selected item.



import React from "react";
import { useSelect } from "rooks";

const list = [
    {
        heading: "Index 0",
        content: " GeeksForGeeks",
    },
    {
        heading: "Index 1",
        content: "GFG",
    },
];

function App() {
    const { index, setIndex, item } = useSelect(list, 0);

    return (
        <div style={{
            display: "flex",
            flexDirection: "column",
            margin: '20px'
        }}>
            <p style={{
                color: '#c311d6',
                fontSize: '20px',
                margin: '10px',
                fontWeight: 'bold'
            }}>List Example</p>

            {list.map((listItem, listItemIndex) => (
                <button
                    key={listItemIndex}
                    style={{
                        background: index === listItemIndex ? 
                            "#bdfca7" : "inherit",
                        width: '300px',
                        color: '#1c23a4',
                        fontSize: '20px',
                        margin: '10px'
                    }}
                    onClick={() => setIndex(listItemIndex)}
                >
                    {listItem.heading}
                </button>
            ))}
            <p style={{
                color: 'green',
                fontSize: '20px',
                margin: '10px',
                fontWeight: 'bold'
            }}>{item.content}</p>

        </div>
    );
}

export default App;
---------------------------------------------------------------------------------------------------------------------------------------------------
ReactJS useTransition Hook
*When building interactive user interfaces, performance is a crucial aspect to consider.
*One way to improve the performance of a React application is by using the useTransition hook.
*useTransition hook enables us to specify which state changes are critical or urgent and which are not.
*All state changes are viewed as necessary in React.
*There may be certain quick UI updates, like selecting a value from a dropdown menu, that should take precedence over other updates, like list filtering, which might slow down their execution
* A useTransition hook allows us to specify what state changes should run with a lower priority to increase the performance of our application.
*Syntax:

const [isPending, startTransition] = useTransition()
*The useTransition hook does not take any parameters, and it returns two values:

isPending: a boolean indicating whether the transition is currently in progress or not.
startTransition: a function that can be used to start the transition.

We will use the useTransition hook to change the visibility of a text and to change the text itself.

*import { useState, useTransition } from 'react';
import './App.css';

const App = () => {
    const [isVisible, setIsVisible] = useState(false);
    const [text, setText] = useState("Hello Geek");
    const [isPending, startTransition] = useTransition();

    const handleClick = () => {
        setIsVisible(!isVisible);
        startTransition();
    };

    return (
        <div className='container'>

            <div className="btn-container">
                <button className='btn' onClick={handleClick}>
                    Toggle Visibility</button>
                <button className='btn' onClick={() =>
                    setText("Welcome to geeksforgeeks")}>
                    Change Text</button>
            </div>

            <div style={isPending ? 
                       { opacity: 0 } : 
                       { opacity: isVisible ? 1 : 0 }}>
                <h1>{text}</h1>
            </div>

        </div>
    );
}

export default App;
*
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------ReactJS useId Hook
*React useId Hook is introduced for the ReactJS versions above 18.
*This hook generates unique IDs 
*i.e, returns a string that is stable across both the server and the client sides
*const id = useId()
----------------------------------------------------------------------------------------------------------------------------------------------------------------------React useInsertionEffect Hook
*useInsertionEffect is a special-purpose React hook designed for libraries and advanced use cases where inserting DOM elements (especially styles) must happen before any layout effects (useLayoutEffect) and before painting to the screen.
*In some cases, like CSS-in-JS libraries (e.g., Emotion, styled-components), styles need to be injected into the DOM before layout calculations happen (to avoid flickering or incorrect layout). React 18 introduced useInsertionEffect to support these situations more cleanly.


*Runs before layout	Runs before useLayoutEffect, hence suitable for DOM insertions like styles.
Client-only	Runs only in the browser, not on the server (SSR environments).
Synchronous	Runs synchronously like useLayoutEffect, ensuring timing-critical updates.


* When to use it:
Only when you're building a library or have a very specific need to insert elements/styles before layout.

Not for general-purpose effect handling ‚Äî for those, stick with useEffect or useLayoutEffect.


//App.js

import React, { useState } from 'react';
import { useInsertionEffect } from 'react';
function App() {
	const [dyna_color, set_Dyna_Color] = useState('green');
	const dStyle = `
	.dynamic-element {
	color: ${dyna_color};
	transition: color 0.5s ease;
	}
`;
	useInsertionEffect(() => {
		const styleEle = document.createElement('style');
		styleEle.innerHTML = dStyle;
		document.head.appendChild(styleEle);
		return () => {
			document.head.removeChild(styleEle);
		};
	}, [dyna_color]);
	const btnFn = () => {
		set_Dyna_Color('red');
	};
	return (
		<div className="dynamic-element">
			<h1>Hello, GeeksforGeeks!</h1>
			<h3>useInsertionEffect Hook - Example 1</h3>
			<button onClick={btnFn}>Change Color</button>
		</div>
	);
}
export default App;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
ReactJS useLocalStorage Custom Hook
*It creates a stateful value for localStorage and gives us a function to update that value like useState.
*Note:JSON.parse(value);
*It parses a JSON string (value) and returns the corresponding JavaScript object.
*const value = '{"name": "Neha", "age": 25}';
const obj = JSON.parse(value);
console.log(obj); // Output: { name: "Neha", age: 25 }
*In our projects, we frequently use localStorage and state but it's a bit tricky to work localStorage's value with the state.
*const [ count, setCount ] = useLocalStorage(key, defaulValue)in ou componenet
*import { useState } from "react";

const useLocalStorage = (key, defaultValue) => {
    // Create state variable to store 
    // localStorage value in state
    const [localStorageValue, setLocalStorageValue] = useState(() => {
        try {
            const value = localStorage.getItem(key)
            // If value is already present in 
            // localStorage then return it
            
            // Else set default value in 
            // localStorage and then return it
            if (value) {
                return JSON.parse(value)
            } else {
                localStorage.setItem(key, JSON.stringify(defaultValue));
                return defaultValue
            }
        } catch (error) {
            localStorage.setItem(key, JSON.stringify(defaultValue));
            return defaultValue
        }
    })

    // this method update our localStorage and our state
    const setLocalStorageStateValue = (valueOrFn) => {
        let newValue;
        if (typeof valueOrFn === 'function') {
            const fn = valueOrFn;
            newValue = fn(localStorageValue)
        }
        else {
            newValue = valueOrFn;
        }
        localStorage.setItem(key, JSON.stringify(newValue));
        setLocalStorageValue(newValue)
    }
    return [localStorageValue, setLocalStorageStateValue]
}

export default useLocalStorage;
*import useLocalStorage from "./hooks/useLocalStorage";

const App = () => {
    const [count, setCount] = useLocalStorage("count", 0);
    return (
        <div style={{ display: "grid", placeItems: "center" }}>
            <h1 style={{ color: "green" }}>GeekForGeeks</h1>
            <h2>useLocalStorage</h2>
            <h4>Count - {count}</h4>
            <button onClick={() => setCount((prevCount) => prevCount + 1)}>
                Increment
            </button>
        </div>
    );
};

export default App;
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Basic Registration and Login Form Using React Hook Form
*React-hook-form is a ReactJS library that simplifies the process of creating forms.
*React Hook Form is a popular third-party library that simplifies form management in React functional components by using hooks.
*It offers a complete set of tools to handle various aspects of forms, such as form state management, field handling, and form submission.
*Some of the features of the React Hook Form Libraries are:
1.Open-source
2.Support ypescrpt
3.Provides DevTool for inspecting form data
4.Provides Form Builder ‚Äì create forms by drag and drop
5.Supports for React-native


Steps to Build a Registration and Login Page in React
*npm install react-hook-form


lets analyze the code for login
*import React from "react";
import { useForm } from "react-hook-form";
import "./App.css";

function Login() {
    const {
        register,
        handleSubmit,
        formState: { errors },
    } = useForm();

    const onSubmit = (data) => {
        const userData = JSON.parse(localStorage.getItem(data.email));
        if (userData) {
            if (userData.password === data.password) {
                console.log(userData.name + " You Are Successfully Logged In");
            } else {
                console.log("Email or Password is not matching with our record");
            }
        } else {
            console.log("Email or Password is not matching with our record");
        }
    };

    return (
        <>
            <h2>Login Form</h2>

            <form className="App" onSubmit={handleSubmit(onSubmit)}>
                <input
                    type="email"
                    {...register("email", { required: true })}
                    placeholder="Email"
                />
                {errors.email && <span style={{ color: "red" }}>*Email* is mandatory</span>}

                <input
                    type="password"
                    {...register("password", { required: true })}
                    placeholder="Password"
                />
                {errors.password && <span style={{ color: "red" }}>*Password* is mandatory</span>}

                <input type="submit" style={{ backgroundColor: "#a1eafb" }} />
            </form>
        </>
    );
}

export default Login;
*here const {
  register,
  handleSubmit,
  formState: { errors },
} = useForm();
*| Variable       | Purpose                                                                             |
| -------------- | ----------------------------------------------------------------------------------- |
| `register`     | Used to **connect input fields** to the form state and here another argument is validation                               |
| `handleSubmit` | Handles form submission and **calls your `onSubmit` function** if inputs are valid. |
| `errors`       | Holds any **validation errors** that occur and is extracted from the formState                                     |



*const onSubmit = (data) => {
  const userData = JSON.parse(localStorage.getItem(data.email));

  if (userData) {
    if (userData.password === data.password) {
      console.log(userData.name + " You Are Successfully Logged In");
    } else {
      console.log("Email or Password is not matching with our record");
    }
  } else {
    console.log("Email or Password is not matching with our record");
  }
};
*here the data is form state 


*<form className="App" onSubmit={handleSubmit(onSubmit)}>
*here form is the element


*<input
  type="email"
  {...register("email", { required: true })}
  placeholder="Email"
/>
*here register connect the input field to form state and validation


*if validation fails then the {errors.email && <span style={{ color: "red" }}>*Email* is mandatory</span>}


<input type="submit" style={{ backgroundColor: "#a1eafb" }} />
Note:This will trigger form submission, as long as it's inside a <form> element and the form has an onSubmit handler.
*‚úÖ Why It Works:
The type="submit" attribute tells the browser:
üëâ ‚ÄúWhen this button is clicked, submit the form.‚Äù

No need for an onClick or additional JS ‚Äî HTML handles that automatically via the <form> tag


Note:<form onSubmit={handleSubmit(onSubmit)}>
  {/* form inputs */}
  <input type="submit" />
</form>
*here button submit tell browser submit form validation start if valid than the pass the data in the onSubmit function
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
setTimeout() in JavaScript
*The setTimeout() function is used to add delay or scheduling the execution of a specific function after a certain period.
*It's a key feature of both browser environments and Node.js
*enabling asynchronous behavior in code execution.

setTimeout(function() {
    console.log('Hello, world!');
}, 2000);


*Parameters

function: After the specified time period, this is the function that is executed.
milliseconds: The delay time is expressed in milliseconds.
arg1, arg2, ...: If needed, these are the optional parameters.

1. Cancellation the setTimeout() Function
*JavaScript provides a corresponding function called clearTimeout() 
* to cancel a scheduled timeout before it gets executed.
*function delayedFunction() {
    console.log("This won't be executed due to clearTimeout");
}

let timeoutId = setTimeout(delayedFunction, 2000);

// Cancel the setTimeout before it executes
clearTimeout(timeoutId);

console.log("Timeout canceled");

2.Purpose of setTimeout() Function
*The setTimeout() function is utilized to introduce a delay or to execute a particular function after a specified amount of time has passed.
*It is part of the Web APIs provided by browsers and Node.js,
*allowing asynchronous execution of code
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*ReactJS useTimeout Custom Hook
*setTimeout() executes code after a specified period only once.
*Usually, we don't need to worry about clearing out our timeouts when using setTimeout. 
* However, it can be challenging to use the setTimeout method in React


**Even though the component using settimeout  might have been removed by then,pr re render due to state or props changes the timeout is still attempting to start
*This might even cause memory leaks
*To resolve this, we must keep track of the timeouts we create in our code and clean them
*import React, { useState, useEffect, useRef } from 'react';

// creating the custom useTimeout hook 
const useTimeout = (callback, delay) => {

    // Creating a ref 
    const savedCallback = useRef();

    // To remember the latest callback .
    useEffect(() => {
        savedCallback.current = callback;
    }, [callback]);

    // Setting and clearing up a timeout
    useEffect(() => {
        const func = () => {
            savedCallback.current();
        }
        if (delay !== null) {
            let id = setTimeout(func, delay);
            return () => clearTimeout(id);
        }
    }, [delay]);
};

export default useTimeout;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
import React, { useState, useEffect, useRef } from 'react';

// creating the custom useInterval hook 
export function useInterval(callback, delay) {
    // Creating a ref 
    const savedCallback = useRef();

    // To remember the latest callback .
    useEffect(() => {
        savedCallback.current = callback;
    }, [callback]);

    // combining the setInterval and 
    //clearInterval methods based on delay.
    useEffect(() => {
        function func() {
            savedCallback.current();
        }
        if (delay !== null) {
            let id = setInterval(func, delay);
            return () => clearInterval(id);
        }
    }, [delay]);
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

React Router
*React Router is a library for handling routing and navigation in React JS Applications
*It allows you to create dynamic routes, providing a seamless user experience by mapping various URLs to components. It enables navigation in a single-page application (SPA) without refreshing the entire page.
*Supports client-side routing in React applications.
*Provides nested routes for better organization.
*Allows for dynamic routing using parameters.
*Enables programmatic navigation via hooks like useNavigate().

Before diving into types of routers, let‚Äôs ensure that React Router DOM is installed in your React project
*npm install react-router-dom

Types of Routers in React
React provides several types of routers that serve different purposes. The main routers in React are
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
1. Browser Router
*BrowserRouter is the most commonly used router in React applications
*It uses the HTML5 history API to manage the navigation.
*This router makes use of pushState, replaceState, and the popState event to keep the UI in sync with the URL.
*It allows for clean and human-readable URLs without hash fragments.



When to Use BrowserRouter
*and it‚Äôs ideal for web applications that require clean, SEO-friendly URLs 
*and rely on server-side routing.


*React Router is the default router for React.
*It allows the switching from one view from one component to the next from multiple components in the React app, changes the browser address, and syncs the UI and the address.

What is BrowserRouter in React Router?
*BrowserRouter is a component provided by the React Router to provide the client-side routing with the support of the HTML5 history API.
*If you want to change between the next page while navigation then BrowserRouter modifies the web browser address accordingly to provide the functionality of preserving the state of the application while changing the views and hnce page does not reloads
*Syntax
<BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
</BrowserRouter>
*Enables Routing: BrowserRouter wraps the application, allowing URL-based navigation without page reloads.
*Defines Routes: Routes contain Route components,, mapping paths (/, /about) to specific React components.


Why Use BrowserRouter?
*Supports client-side routing.
*Seamless Navigation: Ensures smooth transitions without full-page reloads.
*Improves Performance: Reduces unnecessary HTTP requests for navigation.
*Deep Linking Support: Enables bookmarking and direct linking.
*Works Well with State Management: Easily integrates with Redux, Context API, etc.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------


How Does BrowserRouter Work?
*BrowserRouter uses the HTML5 history API
*which consists of pushState, replaceState, and popstate events,
*to update the browser‚Äôs history and allow for dynamic routing.

Initialization of Browser Router
*When the application is loaded, the BrowserRouter component is wrapped around the entire app (typically at the top level).
*<BrowserRouter>
  <App />
</BrowserRouter>

*The History API allows JavaScript to:

Change the browser‚Äôs URL without reloading the page.

Listen to navigation events, like forward/back buttons.

Push new entries into the browser‚Äôs history stack.


*Functions used:

history.pushState() ‚Äì add a new entry to the browser history.

history.replaceState() ‚Äì replace the current entry.

popstate event ‚Äì triggered when the user clicks forward/back.



 How BrowserRouter Uses This:
*Initial Load:
When the app loads, BrowserRouter checks the current URL and renders the correct component based on the defined <Route>s.



*URL Detection
BrowserRouter uses the HTML5 History API to detect changes in the URL. This allows React Router to manipulate the URL while keeping the page from reloading. When a user navigates to a different route (e.g., clicking a <Link> or typing a URL), BrowserRouter listens for this URL change thuspreformig push and change the url

*Matching the URL
Inside BrowserRouter the Route components define which URL path corresponds to which component. For instance, when the URL is /about, a <Route path="/about" component={About} /> is matched.


*Rendering Components
After matching the URL to the corresponding Route, the associated component is rendered. If the URL matches /about, the About component will be displayed.without reloading the page.



UseCases

1.Navigating Between Views

*When a user clicks a link, such as:

<Link to="/about">Go to About</Link>

2.Maintaining Application State:
*Since the page doesn't reload, the application's state (like form data or user input) remains intact. React will only re-render the relevant components, ensuring a seamless user experience.


3.The BrowserRouter uses the browser's built-in history stack, so users can navigate backward and forward between different routes using the browser's back and forward buttons.


4.Dynamic Updates
*As the URL changes (either by user interaction or programmatically using the history object), BrowserRouter continues to handle the URL and re-render the app's UI accordingly, providing smooth transitions between views.
*
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
2. Memory Router
*MemoryRouter is a type of router provided by React Router that's used when you don't have a real browser environment (i.e., no address bar or real URL).
*it help routing It maintains history in memory, not in the URL or browser history stack, 
*here url does nt changes
 


When and Why It's Used:
1.Testing:
In unit tests or integration tests (e.g., using Jest + React Testing Library), you're not running your app in a browser.
*MemoryRouter simulates routing in memory, so you can test navigation behavior without needing to render the full app in a browser.

2. Mobile apps:
*In environments like React Native, there's no concept of a browser URL.

When to Use Memory Router
*There are some use cases of Memory Router

1.Server-Side Rendering (SSR): When rendering React components on the server, where there is no URL to manage.
2.Testing:
3.React Native

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------


What is a hosting server?
*A hosting server is a computer or service that stores your website or web app 
* makes it accessible to users over the internet.
*When someone visits your app‚Äôs URL (like https://myapp.com), the hosting server is what sends your files (HTML, CSS, JS, etc.) to their browser.


 Examples of hosting servers:
*Platform	Type	Supports dynamic routing?
GitHub Pages	Static file hosting	‚ùå No
Netlify (default)	Static hosting	‚ùå No (without config)
aws                    Static hosting	‚ùå No (without config)
Vercel                 both


 Two types of hosting:
1. Static Hosting Server:
Only knows how to serve files like index.html, style.css, and main.js

Does not understand dynamic URLs like /products/23

Always loads the same file (usually index.html), no matter what the path is

‚úÖ Use HashRouter here


2. Dynamic Hosting Server
*Can process any route (like /users/123) and return the correct response
*This means that a dynamic hosting server is smart ‚Äî it can run backend programs to decide what to do when someone visits a URL, instead of just sending static files.
*‚úÖ Use BrowserRouter here
*






--------------------------------------------------------------------------------------------------------------------------------------------------------------------
3.3. Hash Router
*It works by using the hash portion of the URL (the part that comes after the # symbol) to manage navigation.
**t uses URL hash (#) to represent different routes (e.g., http://example.com/#/home)

*When to Use Hash Router
HashRouter is a useful and simple router for React applications that rely on URL hashes for navigation, especially in environments where server-side routing is not available.
*Hosting on Static File Servers: HashRouter works best when your app is hosted on static file servers, like GitHub Pages, that cannot handle dynamic routing or need the URL to stay static.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Advanced ReactJS Guide Complete Reference

Rendering and Re-rendering in React


Rendering
*Rendering is the process where React takes the component's data (state and props) and turns it into a UI that the user can interact with
*When a component is first loaded,
*When import React from "react";

function MyComp() {
    return <h1>Hello, World!</h1>;
}

export default MyComponent;a component is first loaded, React renders the component and displays it in the DOM.


Re-rendering in React
*Re-rendering happens when the state or props of a component change. 
*React will trigger a re-render to reflect the updated data in the UI. 
*However, React optimizes this process to avoid unnecessary re-renders.

When Does Re-rendering Happen
*Re-rendering occurs when: State changes: If the component‚Äôs internal state (useState, setState) changes, React will re-render the component to show the new state.
*Props change: If the props passed to the component change, React re-renders that component to reflect the new props.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Real and Virtual DOM

*Real DOM: The Real DOM is the actual representation of the UI/webpages in the browser. 
*represents the structure of a webpage as a tree of elements.
*Slower Updates: When the state or data changes in a web application, the entire DOM may need to be updated.
*The Real DOM is updated directly. When a change is made, the browser updates the actual page, often causing reflows and repaints, which can be resource-intensive.
Note: Modifying the Real DOM can trigger heavy operations like layout recalculations, which makes direct manipulation of the Real DOM inefficient, especially for large applications.





Virtual DOM:
*ReactJS Virtual DOM is an in-memory representation of the actual DOM (Document Object Model)
*React uses this lightweight JavaScript object to track changes in the application state
*and efficiently update the actual DOM only where necessary.

How Does the Virtual DOM Work?
Here's a breakdown of how the Virtual DOM works:
1.Rendering the Virtual DOM: This is represented as a tree of JavaScript objects, where each node corresponds to a React element (like <div>, <h1>, etc.).
2. üîÑ State or Props Update:When state or props change, React rebuilds a new Virtual DOM tree representing the updated UI.
3. üßÆ Diffing Algorithm:
*React compares the new Virtual DOM with the previous Virtual DOM using a process called "diffing".
It looks for:

Which elements stayed the same
Which were added, removed, or changed
React uses keys to optimize this process in lists.

4. üßº Updating the Real DOM (Reconciliation)
*React updates only the changed parts of the actual DOM (also known as the real DOM).
*This selective update process is called "reconciliation".
*It avoids full page re-renders, resulting in much faster performance than manipulating the DOM directly.

<div>
  <h1>Hello</h1>
  <p>Welcome!</p>
</div>
*And then you update state to change <p>Welcome!</p> to <p>Goodbye!</p>:
*React does:
Create a new Virtual DOM

Finds that only the <p> text changed
Updates only that <p> node in the real DOM




Key Features of React‚Äôs Virtual DOM
*Efficient Updates: By minimizing direct interactions with the real DOM, React significantly reduces rendering time.
*Reconciliation Process: React‚Äôs reconciliation efficiently updates the UI based on changes in the Virtual DOM.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
*Batching Updates: Multiple state updates are batched into a single re-render cycle, avoiding unnecessary computations.
React groups (batches) those updates together and does just one re-render, not multiple.
setCount(count + 1);
setName("Neha");
setTheme("dark");

If React re-rendered after every single setState, it would:

Re-render after setCount

Then again after setName

Then again after setTheme

üëâ This would cause 3 separate renders, which is wasteful.
How this happens is 
*on one state update it does not create new virtual dom tree,it waits for the function is completed than make the virtual dom tree than difff than reconcilations
ex:üßæ 1. You update multiple pieces of state
jsx
Copy
Edit
function handleClick() {
  setCount(count + 1);
  setName("Neha");
  setTheme("dark");
}
All 3 state updates happen one after another, in the same function.
*‚è±Ô∏è 2. React waits for the function to complete
React does not immediately update the Virtual DOM after each setState.

Instead, it waits until the whole function finishes running (i.e., a single "event loop tick" or microtask finishes).
3.3. React builds one new Virtual DOM tree
Now that all state changes are collected:

React creates a new version of the Virtual DOM based on the final state.

4.üß† 4. React compares old Virtual DOM vs new one (diffing)
Using its diffing algorithm, React checks:

What changed?

Which parts stayed the same?

What needs to be updated in the real DOM?

 5. React updates the Real DOM only once
Now that it knows what changed, React updates only those changed parts of the real DOM.

No unnecessary redraws.
No flickers.
No performance waste.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
*The Virtual DOM standardizes behaviour across different browsers, ensuring consistent rendering.
*Component-Based Architecture: Virtual DOM integrates seamlessly with React‚Äôs component-based architecture, promoting modular and reusable code.


How React‚Äôs Virtual DOM Improves Performance
*React calculates and applies only the changes needed instead of repainting the entire DOM.
*Reduces JavaScript Execution Time: Lightweight Virtual DOM trees are faster to manipulate than the actual DOM.


Disadvantages of the Virtual DOM
*Memory Overhead: Maintaining Virtual DOM trees consumes additional memory.
*Learning Curve: Developers need to understand concepts like reconciliation and diffing.


Frameworks and Libraries Using Virtual DOM
*ReactJS: The pioneer in using the Virtual DOM for efficient UI rendering.
Vue.js: Employs a Virtual DOM to provide reactive and declarative UI development.
Inferno: A fast and lightweight React alternative that uses the Virtual DOM.
Preact: A minimalistic version of React with a Virtual DOM for high performance.

When to Avoid the Virtual DOM
*Static Websites: For websites with minimal interactivity, the overhead of maintaining a Virtual DOM isn‚Äôt justified.
*Server-Side Rendering (SSR): While React‚Äôs Virtual DOM supports SSR, simpler templating engines like Handlebars may be more efficient.
*Small Applications: In cases where performance bottlenecks are negligible, the complexity of the Virtual DOM isn‚Äôt necessary.

        Virtual DOM	                                                                                Real DOM
*It is a lightweight copy of the original DOM                                                    It is a tree representation of HTML elements
*It is maintained by JavaScript libraries                                                        It is maintained by the browser after parsing HTML elements
*After manipulation it only re-renders changed elements                                          After manipulation, it re-render the entire DOM
*Updates are lightweight                                                                         Updates are heavyweight
*Highly efficient as it performs batch updates                                                   Less efficient due to re-rendering of DOM after each update
----------------------------------------------------------------------------------------------------------------------------------------------------
React Suspense and Lazy Loading
1.The React.lazy() function is used to dynamically import a component.means dynamically means when needed instead of bringing before
*This is used to define the LazyComponent.lazy mans when needed
*const LazyComponent = lazy(() => import('./LazyComponent'));
2.Suspense:This is a wrapper around the lazy-loaded component
*It displays a fallback (such as a loading spinner or a message)
*while the component is being loaded asynchronously.
*<Suspense fallback={<div>Loading...</div>}>
    <LazyComponent />
</Suspense>
*
----------------------------------------------------------------------------------------------------------------------------------------------------
Performance Optimization in React
1. Memoization of Components: React.memo():React.memo() is a higher-order component (HOC) that helps to prevent unnecessary re-renders of a component. It wraps a component and only re-renders it if its props change.
*const MyComponent = React.memo(function MyComponent({ count }) {
    console.log('Rendering MyComponent');
    return <p>Count: {count}</p>;
});




2.Memoization fo function:useCallbacks()
----------------------------------------------------------------------------------------------------------------------------------------------------
React.js Error Boundaries
*Error boundaries are React components that catch errors during rendering, in constructors, lifecycle methods, and within child components
*They prevent the entire React application from crashing due to errors in specific components.
Catches errors inside the component tree
Prevents entire app crashes
Displays a fallback UI
Logs error details for debugging


How Error Boundaries Work?
*Error boundaries work similarly to try/catch in JavaScript
*If an error occurs within a component‚Äôs rendering process or lifecycle methods, constructors  or within child componnets
*React looks for the nearest error boundary component in the component tree.
*The error boundary captures the error and renders a fallback UI,



Example without erroir boundary:
*function App() {
  return (
    <div>
      <Header />
      <Dashboard /> {/* Dashboard includes UserProfile which throws error */}
      <Footer />
    </div>
  );
}
*If a component like UserProfile throws an error during:

Rendering

Lifecycle methods

Constructor

...and there is no Error Boundary wrapping it 
*üëâ React will unmount the entire component tree, starting from the point where the error occurred all the way up to the root (<App />).
*Your app will crash, and users will see a blank screen or the default error screen (like in development mode, React shows the red error overlay).



With error boundary
<App>
  <Header />
  <ErrorBoundary>
    <Dashboard>
      <UserProfile />  ‚Üê Error happens here
    </Dashboard>
  </ErrorBoundary>
  <Footer />
</App>
*If UserProfile throws an error:

React goes up the tree: UserProfile ‚Üí Dashboard ‚Üí ErrorBoundary.
*t finds ErrorBoundary, so it stops rendering UserProfile and Dashboard, and instead shows the fallback UI (like "Something went wrong").
*he rest of the app (Header, Footer) continues working normally.







They do not catch errors in:
*Event handlers
*Asynchronous code (e.g., setTimeout, requestAnimationFrame)
*Server-side rendering (SSR)
*Errors thrown inside the error boundary component itself.

import React from "react";
import { ErrorBoundary } from "react-error-boundary";

function ErrorFallback({ error, resetErrorBoundary }) {
    return (
        <div>
            <h2>Something went wrong:</h2>
            <pre>{error.message}</pre>
            <button onClick={resetErrorBoundary}>Try again</button>
        </div>
    );
}

function BuggyComponent() {
    throw new Error("Oops! Something went wrong.");
}

function App() {
    return (
        <ErrorBoundary FallbackComponent={ErrorFallback}>
            <BuggyComponent />
        </ErrorBoundary>
    );
}

export default App;
*here This is the fallback UI that will be shown when an error occurs inside the child component of ErrorBoundary.
*error: The actual JavaScript Error object thrown.

resetErrorBoundary: A function that allows retrying the rendering by resetting the error state.
Note:npm i react-error-boundary


Advantages of react-error-boundary
*Works with functional components.
*Provides a reset mechanism to recover from errors.
*Allows easy integration with hooks.


When to Use Error Boundaries
Use error boundaries in the following scenarios:
*At the top level of the application to prevent complete crashes.
*Around UI components that may fail, such as third-party widgets.
*For isolated features to prevent a single failing feature from affecting the whole page.

Why Not Use try/catch Instead?
*One might wonder why we don‚Äôt use try/catch instead of error boundaries. The key reason is:
‚úÖ try/catch works with imperative code:
Imperative means "Do this step by step."

Example:

js
Copy
Edit
try {
    riskyFunction();
} catch (err) {
    console.error("Error caught!", err);
}
This works because you are in full control of when and where to call riskyFunction().

2.Declarative means you describe what the UI should look like, and React handles the how.

Example:

js
Copy
Edit
return <SomeComponent />;
You're not calling SomeComponent() yourself ‚Äî React is doing that under the hood during rendering.
That means you can't wrap this in a try/catch block to handle render-time errors, like:
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Server-Side Rendering (SSR) and Static Site Generation (SSG)
1. Server-Side Rendering (SSR):
*Server-Side Rendering is a technique where the HTML for a page is generated on the server at the time the request is made by the user, rather than in the browser.
How SSR Works
*When a user requests a page (for example, by visiting a URL), the server generates the HTML content for that page on the fly.
*The server sends the fully rendered HTML to the browser, which then displays the content to the user.
*Once the initial HTML is loaded, JavaScript runs on the client-side to make the page interactive 
Example Use Case: News websites, dashboards, or user-specific content where the data changes frequently.

2. Static Site Generation (SSG):
*here not on the user request ,but on built time the framework fetches all the data to generate the html page
*store them as as static file for every route
*These HTML files are saved and served as-is whenever a user requests a page.

*Once delivered, JavaScript runs on the browser to enable interactivity.


 Example Use Case: Blogs, documentation, marketing pages, or websites where content does not change often.



üîÑ SSR vs. SSG at a Glance:
Feature	SSR	SSG
Rendering Time	On every request (runtime)	At build time
Performance	Slower than SSG (depends on server)	Extremely fast (served from CDN)
Best For	Dynamic content	Static content
SEO Friendly	‚úÖ Yes	‚úÖ Yes
Build Time	N/A	Can be long for large sites
Fresh Data	‚úÖ Always fresh	‚ùå Only fresh at build time (unless ISR used)

---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Code Splitting in React
* The code (bundle) is not loaded upfront when the app starts, but only when it‚Äôs actually needed ‚Äî for example, when a user navigates to a specific route or interacts with a specific feature.

* Example: What "dynamically" means
Let‚Äôs say you have a website with the following pages:

/home

/about

/contact
Without code-splitting:

All code for all pages (home, about, contact) gets bundled into one big file and loaded when the user opens the app ‚Äî even if they never visit /contact.

With code-splitting:

The code for each page is split into separate bundles.

Only the code for /home is loaded when the user first visits the site.

If the user clicks "About", then and only then, the bundle for /about is loaded dynamically.




Bundling and its efficiency
*Bundling is the method of combining imported files with a single file. 
*t is done with the help of Webpack, Rollup, and Browserify 
*as they can create many bundles that can be loaded dynamically at runtime.
*With the help of code splitting, 'lazy load' can be implemented, which means just using the code which is currently needed.
The default way of importing is as follows: 
*import { add } from './math';

console.log(add(x, y));  // Here x, y are two numbers

*Using code-splitting this can be done as follows: 
import("./math").then(math => {
  console.log(math.add(x, y));
});
// Here x, y are two numbers
*
import("./math").then(math => {
  console.log(math.add(x, y));
});
// Here x, y are two numbers
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Code Splitting in webpack
*Code splitting is one of the most compelling features of webpack. This feature allows you to split your code into various bundles which can then be loaded on demand or in parallel. 
*There are three general approaches to code splitting available:



1.Entry Points:
*This is by far the easiest 
* However, it is more manual and has some pitfalls we will go over.
*Let's take a look at how we might split another module from the main bundle:
*webpack-demo
|- package.json
|- package-lock.json
|- webpack.config.js
|- /dist
|- /src
  |- index.js
 |- another-module.js
|- /node_modules

*You told Webpack to create two separate entry points:
*entry: {
  index: './src/index.js',
  another: './src/another-module.js',
}
*So Webpack builds two separate bundles:

index.bundle.js

another.bundle.js


*Since both files import lodash, and Webpack doesn‚Äôt know these two entry points will be used together on the same page
* It includes the entire lodash library in both index.bundle.js and another.bundle.js.
*So:

Each bundle is ~553 KB

Lodash itself is ~530 KB

That means the same code is duplicated in both bundles
*Consequences:
The user downloads lodash twice if both bundles are loaded.

Slower loading time.

Wasted bandwidth.

Inefficient caching ‚Äî lodash isn't reused across bundles.


*As mentioned there are some pitfalls to this approach:

If there are any duplicated modules between entry chunks they will be included in both bundles.
It isn't as flexible and can't be used to dynamically split code with the core application logic.
The first of these two points is definitely an issue for our example, as lodash is also imported within ./src/index.js and will thus be duplicated in both bundles. 



Let's remove this duplication in next section.


2.Prevent Duplication
Entry dependencies
*entry: {
  index: {
    import: './src/index.js',
    dependOn: 'shared',
  },
  another: {
    import: './src/another-module.js',
    dependOn: 'shared',
  },
  shared: 'lodash',
}
hey index and another uses the lodash so  move it to shared.bundle.js.‚Äù
*This reduces duplication across bundles.
*‚úÖ Output:
index.bundle.js: Only your app logic (tiny)

another.bundle.js: Same

shared.bundle.js: Lodash

3.SplitChunksPlugin (Automatic Deduplication)
*Instead of manually declaring dependencies, Webpack can auto-detect common modules.
* const path = require('path');

  module.exports = {
    mode: 'development',
   
   optimization: {
     splitChunks: {
       chunks: 'all',
     },
   },
  };
* Webpack scans all imports across your app:

Finds duplicates like lodash

Extracts them into a vendors chunk (e.g., vendors~lodash.bundle.js)

‚úÖ This method is easier to maintain as the app grows.



4.Dynamic Imports (import())
*You can also split code dynamically ‚Äî only load modules when needed:
*async function getComponent() {
  const { default: _ } = await import('lodash');
  ...
}
‚úÖ Webpack sees import() and:

Creates a separate async chunk

Loads it only when requested


4. Prefetch & Preload
These are hints to the browser for better performance.

webpackPrefetch
js
Copy
Edit
import(/* webpackPrefetch: true */ './LoginModal.js');
üß† Tells browser:

"User might need this soon ‚Äî download it in idle time."

webpackPreload
js
Copy
Edit
import(/* webpackPreload: true */ './ChartingLibrary');
üß† Tells browser:

"User will need this immediately ‚Äî download it in parallel with main page."

‚ö†Ô∏è Use carefully ‚Äî wrong usage can hurt performance.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Code splitting at component level


1.React.lazy and Suspense
*React.lazy() lets you dynamically import a component
*means import or load it when needed instead of the loading whole app component initial 




*Without React.lazy:
*import Component from './Component';
*this will bundle this component into main file whoch load at the very initial


* With React.lazy:
const Component = React.lazy(() => import('./Component'));
*The component‚Äôs code is not part of the main bundle.
*When you use React.lazy(() => import('./Component')), that component's code is split into a separate JavaScript chunk by tools like Webpack or Vite.
*The chunk is only downloaded when the component actually renders on screen for the first time.
*const Chart = React.lazy(() => import('./HeavyChartComponent'));
Until the user clicks ‚ÄúOpen Chart‚Äù, the browser won‚Äôt download HeavyChartComponent.js.

Only when you render <Chart />, React will:

pause rendering,

show the fallback inside <Suspense>,

and fetch the chunk behind the scenes.


*Suspense is a special React component that lets you show a fallback UI while the lazy component is loading.
*import React, { Suspense } from 'react';
const Component = React.lazy(() => import('./Component'));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <Component />
      </Suspense>
    </div>
  );
}

*You can wrap multiple lazy components in one <Suspense>:
*const ComponentOne = React.lazy(() => import('./ComponentOne'));
const ComponentTwo = React.lazy(() => import('./ComponentTwo'));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <ComponentOne />
        <ComponentTwo />
      </Suspense>
    </div>
  );
}

Note: fallback will show until both components are ready.
*eact.lazy and Suspense do NOT work for server-side rendering (SSR) yet
*That‚Äôs why tools like @loadable/component are used in SSR React apps.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
*Note:so instead of using the react.createelement to make whole application we use the jsx
*JSX is just another way of creating React elements
*The react team created JSX to make it more readable like HTML and XML
*in jsx suppose we wanted to create the button 
*<button className="btn btn-primary"> save </button>
*This is JSX syntax look like HTML, but with small differences, 
*JSX also works with components as well,
*<Component className="card">
    <div>Hello world</div>
</Component>
*Readability is also the main reason which comes along with simplicity for the implementation of JSX by the React team.
*Browser doesn't understand JSX syntax out of the box, you have to transpile/compile your JSX code to JavaScript code.
*or this, you can use Babel. You can add Babel in your HTML file using the CDN link in the script tag.
*We have to externally specify from where Babel should transpile. 
* For this we've to add type attribute(text/babel) in our script tag.
*<body>
    // Root element of React code
    <div id="root"></div>    
    
    <script crossorigin src=
"https://unpkg.com/react@17/umd/react.development.js">
    </script>
    <script crossorigin src=
"https://unpkg.com/react-dom@17/umd/react-dom.development.js">
    </script>
    
    // Babel
    <script src=
"https://unpkg.com/@babel/standalone/babel.min.js">
    </script>
    
    // Our JS code
    <script src="./main.js" type="text/babel"></script>
    
</body>



There are certain rules to consider while starting with JSX:
1.type:
*As you all know, we have to specify as the first argument to React.createElement method to tell react what kind of element we want to create.
*While creating an element with JSX we have to tell react by specifying the type of element as a tag(HTML like)or custom Componnet
*Opening and closing tag: If we have children that come under our component then we have to specify children between the opening and the closing tag.
Self-closing: If we do not have children to specify then we can use a self-closing tag also.
<ButtonComponent>    // Opening tag of ButtonComponent
     // Self closing tag because it 
     // doesn't have children
    <span> name </span>
    <ButtonImageComponent />   

// Closing tag of ButtonComponent
</ButtonComponent>


2.props
*When we create an element using React.createElement then we have to specify its properties as the second argument
*but with JSX we can specify its properties as attributes(like old-style HTML attributes)
*const id = Math.floor(Math.random() * 10e8);    // Random number

const ButtonComponent = ( <button className="btn btn-primary" id={ id }>
    click me
</button> );
    
ReactDOM.render(ButtonComponent, document.querySelector("#root"));


3.child:
children:  If we want to add children of a component then we've to specify between the opening and closing tag of the React element
*const listComponent = (
  <ul>
    <li>Alex</li>
    <li>Ragnar</li>
    <li>Akbar</li>
    <li>Mandy</li>
  </ul>
);
ReactDOM.render(
    listComponent,
    document.querySelector('#root')
)

/************** OR **************

const listCustomComponent = (
    <NameComponent>
        <ListComponetn name="Alex"></ListComponetn>
        <ListComponetn name="Ragnar"></ListComponetn>
        <ListComponetn name="Akbar"></ListComponetn>
        <ListComponetn name="Mandy"></ListComponetn>
    </NameComponent>
)
ReactDOM.render(
    listCustomComponent,
    document.querySelector('#root')
)

4.JavaScript Expression: JavaScript's expression should be wrapped in a single curly brace and should indicate where the variable will get evaluated in JSX
5.Mapping array with JSX: JSX is javascript, so you can loop over the array and create elements with JSX also.
*const names = ["React.js", "Angular", "Node.js", "jQuery", "underscore.js"]

const Command = (
    <h4>
        {
            names.map( function creatNameElement(name){
                        return <li key={ name }> { name } </li>
            })
        }
    </h4>
);

ReactDOM.render(
    Command,
    document.querySelector('#root')
)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Refs are generally used for the following purposes:
Managing focus, text selection, or media playback.
Triggering imperative animations.
Integrating with third-party DOM libraries.


*Note: You should avoid using refs for anything that can be done declaratively.
Method 1: Using React.createRef().
It was introduced in React 16.3.
Create a ref variable using React.createRef()
Use the element's ref attribute to attach the ref variables
// Importing everything as React
import * as React from "react";

const App = () => {
  // Creating textInputRef variable
  const textInputRef = React.createRef();

  // This method will be used to focus textInput
  const textInputFocusHandler = () => {
    // Focusing input element
    textInputRef.current.focus();
  };

  return (
    <div>
      
      {/** Attaching ref variable using element's ref attribute */}
      <input ref={textInputRef} type="text" 
             placeholder="Enter something" />

      {/** Attaching textInputFocusHandler method to button click */}
      <button onClick={textInputFocusHandler}>

             Click me to focus input
      </button>
    </div>
  );
};

export default App;



Method 2: Using useRef() hook.
*This method was used prior to React 16.3. So if you are using React < 16.3 use this method.
*Instead of passing a ref attribute created using createRef() or useRef() we pass a function.
*inside this function The function receives the React element or HTML DOM element as an argument, which can be used.so that we set the ref for this elements
*Note:here we dont use the .current propert
*// Importing everything as React
import * as React from "react";

const App = () => {
  // Creating and initializing textInputRef variable as null 
  let textInputRef = null;

  // Callback function that will set ref for input field
  // Note: It can be used to set ref for any element
  const setTextInputRef = (element) => {
      textInputRef = element;
  };

  // This method will be used to focus textInput
  const textInputFocusHandler = () => {

    // If textInputRef is not null
    // otherwise it will throw an error
    if (textInputRef) {
    
      // Focusing input element
      textInputRef.focus();
    }
  };

  return (
    <div style={{ padding: 16 }}>
      {/** Using setTextInputRef function so that
       *   textInputRef can be set as ref for this input field
       * */}
      <input
        style={{ display: "block" }}
        ref={setTextInputRef}
        type="text"
        placeholder="Enter something"
      />

      {/** Attaching textInputFocusHandler 
           method to button click */}
      <button onClick={textInputFocusHandler}>
          Click me to focus input
      </button>
    </div>
  );
};

export default App;
Note:when we access dom using ueref then actual value get stored in .current.value and .current is dm element
*Here, ref.current is just a normal JavaScript variable ‚Äî not tied to the DOM. You're using it to store any value (like a number, object, etc.)

js
Copy
Edit
const prevCountRef = useRef();

// inside useEffect
prevCountRef.current = count;
Here, ref.current itself holds the previous count ‚Äî there's no .value because you're not referencing a DOM element.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
ontrolled component 
import React, { useState } from 'react';

function ControlledForm() {
  const [name, setName] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    alert(`Submitted Name: ${name}`);
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Name (Controlled):
        <input
          type="text"
          value={name}
          onChange={(e) => setName(e.target.value)} // React controls the input
        />
      </label>
      <button type="submit">Submit</button>
    </form>
  );
}

 Uncontrolled Component Example (using useRef)
*import React, { useRef } from 'react';

function UncontrolledForm() {
  const nameRef = useRef();

  const handleSubmit = (e) => {
    e.preventDefault();
    alert(`Submitted Name: ${nameRef.current.value}`); // access input directly
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Name (Uncontrolled):
        <input
          type="text"
          ref={nameRef} // input is uncontrolled; React doesn't track it
        />
      </label>
      <button type="submit">Submit</button>
    </form>
  );
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
React js examples
How to Perform Debouncing in ReactJS ?
*Debouncing in React is a technique used to limit the execution rate
* It prevents excessive function calls for frequent events, like changing the input, and helps improve the performance.


Lodash _.debounce() Method
*The Lodash _.debounce() method is a utility function that delays the execution of a given function until a specified wait time has passed since the last invocation.
*This method is particularly useful in scenarios where events fire frequently, such as resizing, scrolling, or input events, helping prevent unnecessary or excessive function calls that can affect performance



How _.debounce() Works
*_.debounce() creates a debounced version of a function, ensuring it is only called once after a certain wait period has elapsed since the last event.
*This helps manage rapid-fire events more efficiently, reducing the number of times the function is executed.
*Syntax
_.debounce( func, wait, options{})
*func: It is the function that has to be debounced.
wait: It is the number of milliseconds for which the calls are to be delayed. It is an optional parameter. The default value is 0.
options: It is the options object that can be used for changing the behavior of the method. It is an optional parameter
leading (boolean): If it is true the function will get executed immediately rather than waiting for the 'wait' time. The default value is false means it waits until the 'wait' time is not completed.
maxWait (number): It is the maximum number of times, the function will be called after completion of this time.
trailing (boolean): It defines the calling of a function to the specified time(wait time). by default, it sets to true.
*Return Value: Returns a new debounced function

Understanding how to optimize performance with techniques like debouncing is essential for modern development.\


Examples of Lodash _.debounce() Method
*// Requiring lodash library
const lodash = require('lodash');

// Using lodash.debounce() method
// with its parameters
let debounce_fun = lodash.debounce(function () {
    console.log('Function debounced after 1000ms!');
}, 1000);

debounce_fun();



Steps to Implement Debouncing in React
*npm install lodash
*// Filename - App.js

import React, { Component } from "react";
import { debounce } from "lodash";

class WidgetText extends Component {

    state = { text: "" };
    handleChange = (e) => {
        this.setState({ text: e.target.value });
    };
    render() {
        return (
            <div>
                <input onChange={this.handleChange} />
                <textarea value={this.state.text} />
            </div>
        );
    }
}

class App extends Component {

    state = { show: true };
    handleToggle = debounce(() => {
        this.setState(prevState => ({ show: !prevState.show }));
    }, 500);

    render() {
        return (
            <div>
                <button onClick={this.handleToggle}>Toggle</button>
                {this.state.show ? <WidgetText /> : null}
            </div>
        );
    }
}

export default App;
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*How to concatenate unicode and variable in ReactJS ?
*To concatenate Unicode and variables in React JS we will pass the unicode value as a prop to the App component.
*// Filename - index.js

import React from "react";
import ReactDOM from "react-dom";
import App from "./App";

ReactDOM.render(
    <React.StrictMode>
        <App unicode="2192" />
    </React.StrictMode>,

    document.getElementById("root")
);

*then in app.js // Filename - App.js

import React from "react";
const App = ({ unicode }) => {
    return (
        <h1>
            This is a Right arrow
            {String.fromCodePoint(parseInt(unicode, 16))}
        </h1>
    );
};
export default App;
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
How to set input box to be a floating number in ReactJS ?
*If we want to set the input box to be a floating number then we can use the step attribute of the input tag.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
How to use useState in arrow function instead of hook ?
function vs const in functional components




function declaration
function MyComponent() {
  return <div>Hello</div>;
}
*Hoisted: You can use this function before it is defined in the file.

Used in classic React examples.



const MyComponent = () => {
  return <div>Hello</div>;
};
Not hoisted: You must define it before using it.

Common in modern React codebases.

You‚Äôre using an arrow function assigned to a constant.



‚úÖ Arrow functions and this context
*You mentioned:

"By using these functions, we can get rid of annoying method of binding every time"
*That's true, but it applies mainly when using arrow functions inside class components.
*In class components, methods don‚Äôt bind this automatically, so we had to do
*this.handleClick = this.handleClick.bind(this);
*handleClick = () => {
  // arrow function binds `this` lexically
}
*But in functional components, there is no this ‚Äî so the binding problem doesn't even exist.


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
How to add theme to your React App?
*Themes play a crucial role in web applications, ensuring a cohesive visual identity
Steps to create React Application And Installing Module:
*npx create-react-app gfg
*cd gfg
*npm install @material-ui/core
*Theming in Material-UI:
1.Material UI provides a ThemeProvider component for injecting a theme into the application.
2.Begin by defining a theme object using createMuiTheme().
3.Pass the created theme object to the ThemeProvider component. This component wraps the entire template that needs to be themed.
4.<ThemeProvider> utilizes React's context feature to propagate the theme to all components within the template.
5.Default Styling:
Components inherit default styling properties from the theme. For example, an app bar's background color defaults to the primary color specified in the theme.


Steps:import { createMuiTheme, responsiveFontSizes }
    from '@materialui/core/styles';
    
const theme = responsiveFontSizes(createMuiTheme({

}));
* createMuiTheme:This function creates a custom Material-UI theme, where you can override default settings like colors, typography, breakpoints, etc.
* This is a higher-order function that takes your theme and adjusts the font sizes to be responsive (i.e., scale based on screen size).


*inside the theme 
1.Spacing: It helps create consistent spacing between the elements of our UI.

spacing: 4

2.Typography
Typography is where we define different font variants that are then used in the component templates via the ‚ÄòTypography‚Äô component.
typography: {
    fontFamily: [ 'Roboto',
    'Raleway',
    'Open Sans',
    ].join(','),
    h1: {
        fontSize: '5rem',
        fontFamily: 'Raleway',
    }
    ,
    h2: {
        fontSize: '3.5rem',
        fontFamily: 'Open Sans',
        fontStyle: 'bold',
    }
    ,


3.Palette:
Palette is where we define the colors to be used in our React app. The theme exposes the following predefined palette colors ‚Äì primary, secondary, error, warning, info, success, and text for typography colors.
palette: {
    background: {
        default: '#009900',
    },
    primary: {
    main: '#2B37D4',
    },
    secondary: {
    main: '#E769A6',
    },
    error: {
    main: '#D72A2A',
    },

and in our app.js import React, { Component } from "react";
import "./App.css";
import CssBaseline from "@material-ui/core/CssBaseline";
import { ThemeProvider } from "@material-ui/styles";
import theme from "./theme";
import Container from "@material-ui/core/Container";
import Typography from "@material-ui/core/Typography";
import Button from "@material-ui/core/Button";

function App() {
    return (
        <React.Fragment>
            <ThemeProvider theme={theme}>
                <CssBaseline />
                <Container maxWidth="sm">
                    <Typography
                        component="h1"
                        variant="h1"
                        align="center"
                        color="textPrimary"
                        gutterBottom
                    >
                        Geeks for Geeks
                    </Typography>
                    <Typography
                        variant="h2"
                        align="center"
                        color="textSecondary"
                    >
                        h2 Typography with secondary text colour
                    </Typography>
                    <br />
                    <Typography
                        variant="h3"
                        align="center"
                        color="textPrimary"
                        paragraph
                    >
                        h3 Typography variant with primary text colour
                    </Typography>
                    <br />
                    <Button variant="contained" color="primary">
                        {" "}
                        Primary
                    </Button>
                    <Button variant="contained" color="secondary">
                        {" "}
                        Secondary
                    </Button>
                    {/* Since, color prop only takes primary and 
          secondary as values,we define other colors 
          in component's style */}
                    <Button
                        variant="contained"
                        style={{ background: theme.palette.error.main }}
                    >
                        Error{" "}
                    </Button>
                    <Button
                        variant="contained"
                        style={{ background: theme.palette.warning.main }}
                    >
                        Warning{" "}
                    </Button>
                    <Button
                        variant="contained"
                        style={{ background: theme.palette.info.main }}
                    >
                        Info{" "}
                    </Button>
                    <Button
                        variant="contained"
                        style={{ background: theme.palette.success.main }}
                    >
                        Success{" "}
                    </Button>
                    <br />
                    <br />
                </Container>
            </ThemeProvider>
        </React.Fragment>
    );
}

export default App;
so here variant=h1 apply typography h1 and color Text color: #000000 (from text.primary)
*Note:  {/* Since, color prop only takes primary and 
          secondary as values,we define other colors 
          in component's style */}


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Filename: App.js

import React, { useState, useEffect } from "react";
import axios from "axios";

function App() {
    const [loading, setLoading] = useState(false);
    const [posts, setPosts] = useState([]);

    useEffect(() => {
        const loadPost = async () => {
            // Till the data is fetch using API
            // the Loading page will show.
            setLoading(true);

            // Await make wait until that
            // promise settles and return its result
            const response = await axios.get(
                "https://jsonplaceholder.typicode.com/posts/"
            );

            // After fetching data stored it in posts state.
            setPosts(response.data);

            // Closed the loading page
            setLoading(false);
        };

        // Call the function
        loadPost();
    }, []);

    return (
        <>
            <div className="App">
                {loading ? (
                    <h4>Loading...</h4>
                ) : (
                    posts.map((item) => (
                        // Presently we only fetch
                        // title from the API
                        <h4>{item.title}</h4>
                    ))
                )}
            </div>
        </>
    );
}

export default App;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
How to fetch data from APIs using Asynchronous await in ReactJS ?

using async await and fetch
*import React, { useEffect, useState } from 'react';

const PostsComponent = () => {
  const [posts, setPosts] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const loadPost = async () => {
      setLoading(true);

      try {
        const response = await fetch("https://jsonplaceholder.typicode.com/posts/");
        const data = await response.json();

        setPosts(data);
      } catch (error) {
        console.error('Error fetching posts:', error);
      } finally {
        setLoading(false);
      }
    };

    loadPost();
  }, []);

  if (loading) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      <h1>Posts List</h1>
      <ul>
        {posts.map(post => (
          <li key={post.id}>
            <strong>{post.title}</strong><br />
            {post.body}
          </li>
        ))}
      </ul>
    </div>
  );
};

export default PostsComponent;


using the async await and the axios
// Filename: App.js

import React, { useState, useEffect } from "react";
import axios from "axios";

function App() {
    const [loading, setLoading] = useState(false);
    const [posts, setPosts] = useState([]);

    useEffect(() => {
        const loadPost = async () => {
            // Till the data is fetch using API
            // the Loading page will show.
            setLoading(true);

            // Await make wait until that
            // promise settles and return its result
            const response = await axios.get(
                "https://jsonplaceholder.typicode.com/posts/"
            );

            // After fetching data stored it in posts state.
            setPosts(response.data);

            // Closed the loading page
            setLoading(false);
        };

        // Call the function
        loadPost();
    }, []);

    return (
        <>
            <div className="App">
                {loading ? (
                    <h4>Loading...</h4>
                ) : (
                    posts.map((item) => (
                        // Presently we only fetch
                        // title from the API
                        <h4>{item.title}</h4>
                    ))
                )}
            </div>
        </>
    );
}

export default App;
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Diffrenet ways to create table in react are
*1. Using Native HTML Table (No Library)
const SimpleTable = () => {
  const data = [
    { col1: "Hello", col2: "World" },
    { col1: "React", col2: "Table" },
  ];

  return (
    <table border="1">
      <thead>
        <tr>
          <th>Col 1</th>
          <th>Col 2</th>
        </tr>
      </thead>
      <tbody>
        {data.map((row, idx) => (
          <tr key={idx}>
            <td>{row.col1}</td>
            <td>{row.col2}</td>
          </tr>
        ))}
      </tbody>
    </table>
  );
};





2.Using MUI (Material UI DataGrid / Table)
*import React from 'react';
import {
  Table, TableBody, TableCell, TableContainer,
  TableHead, TableRow, Paper
} from '@mui/material';

const MuiTable = () => {
  const rows = [
    { col1: 'Hello', col2: 'World' },
    { col1: 'React', col2: 'Table' },
  ];

  return (
    <TableContainer component={Paper}>
      <Table>
        <TableHead>
          <TableRow>
            <TableCell>Col 1</TableCell>
            <TableCell>Col 2</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {rows.map((row, i) => (
            <TableRow key={i}>
              <TableCell>{row.col1}</TableCell>
              <TableCell>{row.col2}</TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  );
};
*in our case we use the react table
*//App.js

import React, { useState } from 'react';
import { useTable } from 'react-table';

const App = () => {

    // Define state
    const [cellValue, setCellValue] = useState('');

    // Add data here to show in table
    const data = React.useMemo(
        () => [
            {
                reactCol1: 'Hey',
                reactCol2: 'World',
            },
            {
                reactCol1: 'Here',
                reactCol2: 'is the',
            },
            {
                reactCol1: 'Example',
                reactCol2: 'of react-table',
            },
        ],
        []
    )

    // Define column of the table
    const columns = React.useMemo(
        () => [
            {
                Header: 'React',

                // Accessor is the "key" in the data
                accessor: 'reactCol1',
            },
            {
                Header: 'Table',
                accessor: 'reactCol2',
            },
        ],
        []
    )

    // Function to get cell value
    const getCellValue = (cell) => {
        setCellValue(cell.value)
    }

    // Create the instance of table by 
    // using hooks of react-table
    const {
        getTableProps,
        getTableBodyProps,
        headerGroups,
        rows,
        prepareRow,
    } = useTable({ columns, data })

    return (
        <>
            {/* Showing cell value */}
            <h3>Selected Cell Value: {cellValue}</h3>
            <table {...getTableProps()}
                style={{ border: 'solid 1px blue' }}>

                <thead>
                    {headerGroups.map(headerGroup => (
                        <tr {...headerGroup.getHeaderGroupProps()}>
                            {headerGroup.headers.map(column => (
                                <th
                                    {...column.getHeaderProps()}
                                    style={{
                                        borderBottom: 'solid 3px red',
                                        background: 'aliceblue',
                                        color: 'black',
                                        fontWeight: 'bold',
                                    }}
                                >
                                    {column.render('Header')}
                                </th>
                            ))}
                        </tr>
                    ))}
                </thead>
                <tbody {...getTableBodyProps()}>
                    {rows.map(row => {
                        prepareRow(row)
                        return (
                            <tr {...row.getRowProps()}>
                                {row.cells.map(cell => {
                                    return (
                                        <>
                                            {/* Here added onClick function 
                                            to get cell value */}
                                            <td
                                                onClick={() => getCellValue(cell)}
                                                {...cell.getCellProps()}
                                                style={{
                                                    padding: '10px',
                                                    border: 'solid 1px gray',
                                                    background: 'papayawhip',
                                                }}
                                            >
                                                {cell.render('Cell')}
                                            </td>
                                        </>
                                    )
                                })}
                            </tr>
                        )
                    })}
                </tbody>
            </table>
        </>
    )
}

export default App;

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
How To Set Default Value In Select using ReactJS?

*When building forms in ReactJS, it is common to work with select dropdowns where users can choose an option from a list.
*Sometimes, you may want to set a default value in the select dropdown to pre-select an option when the form loads.


1.1. Using the HTML <select> Tag
*// Filename - App.js

import { Component } from "react";
import "./App.css";

class App extends Component {
    constructor(props) {
        super(props);
    }

    render() {
        return (
            <div className="App">
                <h1 className="geeks">Geeks For Geeks</h1>

                <form className="container">
                    <select
                        className="item"
                        name="languages"
                        style={{ width: "200px" }}
                    >
                        <option value="JAVA">JAVA</option>
                        <option value="C++">C++</option>
                        <option value="Javascript" selected>
                            Javascript
                        </option>
                        <option value="Python">
                            Python
                        </option>
                        <option value="R">R</option>
                        <option value="Scala">Scala</option>
                        <option value="Swift">Swift</option>
                    </select>
                </form>
            </div>
        );
    }
}

export default App;
here we used the selected



2.To set default value in react-select you can use the defaultValue attrubute in the Select menu. If none option is integrated with this attribute first option is selected by default. You can create an Array of the object where you will store all options to be displayed and any single object is passed in the defaultValue attribute.
*// App.js

import { Component } from "react";
import Select from "react-select";
import "./App.css";

const options = [
    { value: "C++", label: "C++" },
    { value: "JAVA", label: "JAVA" },
    { value: "Javascript", label: "Javascript" },
    { value: "Python", label: "Python" },
    { value: "Swift", label: "Swift" },
];

class App extends Component {
    constructor(props) {
        super(props);
    }

    render() {
        return (
            <div className="App">
                <h1 className="geeks">Geeks For Geeks</h1>
                <div className="container">
                    <Select
                        className="item"
                        styles={{ width: "20px" }}
                        value={options.value}
                        options={options}
                        defaultValue={options[1]}
                    />
                </div>
            </div>
        );
    }
}

export default App;
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
How to change the position of the element dynamically in ReactJS ?
*To change the position of an element dynamically based on certain conditions or user interactions, we can access and modify its styling and link to certain events.
*When these events trigger that in return will change the position of the element

Approach:
*To change the position of the element dynamically in ReactJS we will link the element position with with a state. Access the state dynamically and modify its value to change the position of the required element.
*access the style 
*and then link some event that update the state
// Filename - App.js

import React, { Component } from "react";

class App extends Component {
    // Create state
    state = {
        xoffset: 0,
        yoffset: 0,
        delta: 10,
    };

    moveTitleToDown = () => {
        this.setState({
            yoffset: this.state.yoffset + this.state.delta,
        });
    };
    moveTitleToRight = () => {
        this.setState({
            xoffset: this.state.xoffset + this.state.delta,
        });
    };
    moveTitleToLeft = () => {
        this.setState({
            xoffset: this.state.xoffset - this.state.delta,
        });
    };
    moveTitleToUp = () => {
        this.setState({
            yoffset: this.state.yoffset - this.state.delta,
        });
    };

    render() {
        return (
            <div>
                {/* Element to Move Dynamically */}
                <h2
                    style={{
                        position: "absolute",
                        left: `${this.state.xoffset}px`,
                        top: `${this.state.yoffset}px`,
                    }}
                >
                    GeeksforGeeks
                </h2>

                {/* Move Controls */}
                <div style={{ marginTop: "80px" }}>
                    <button onClick={this.moveTitleToRight}>
                        Move Title To Right
                    </button>
                    <button onClick={this.moveTitleToDown}>
                        Move Title To Down
                    </button>
                    <button onClick={this.moveTitleToLeft}>
                        Move Title To Left
                    </button>
                    <button onClick={this.moveTitleToUp}>
                        Move Title To Up
                    </button>
                </div>
            </div>
        );
    }
}

export default App;
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
How to Solve Too Many re-renders Error in ReactJS?
*Too many re-renderers" is a React error that happens after you have reached an infinite render loop



Understanding too many re-renders Error
The "Too Many Re-renders" error occurs when
*The state or props in a component are updated continuously in a way that triggers repeated re-renders, creating an infinite loop.
*This can happen if state updates are triggered inside the render method or in useEffect() hooks without proper dependencies, which leads to continuous state updates and re-renders.


Common Causes of "Too Many Re-renders" Error
1.1. State Update Inside Render
*Directly calling setState or useState inside the render method or component body can cause an infinite loop of re-renders, as the state updates trigger a re-render, and the update itself triggers another render.

import React, { useState } from 'react';

function App() {
  const [count, setCount] = useState(0);

  // This causes an infinite loop because setCount is called on every render
  setCount(count + 1);

  return <div>Count: {count}</div>;
}



Fix:
Move the state update to an event handler or a controlled context, like a button click, to prevent it from running on every render.
import React, { useState } from 'react';

function App() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1); // Only updates state on button click
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
}



2.2
*When setState is called inside a useEffect hook without a dependency array (or with an incorrect one), the effect runs after every render, updates the state, and triggers another render, causing an infinite loop.
*import React, { useState, useEffect } from 'react';

function App() {
  const [count, setCount] = useState(0);

  // This useEffect runs after every render, causing an infinite loop
  useEffect(() => {
    setCount(count + 1);
  });

  return <div>Count: {count}</div>;
}


Fix:
Add a dependency array to useEffect to control when the effect runs. If the effect should only run once (e.g., on component mount), use an empty dependency array. If it depends on specific values, include them in the array.



3.33. Conditional State Updates
*3. Conditional State Updates
If a state update is being triggered under certain conditions in a way that causes it to always meet those conditions, it can cause repeated state changes and re-renders.
import React, { useState } from 'react';

function App() {
  const [count, setCount] = useState(0);

  // This condition is always true on every render, causing an infinite loop
  if (count < 10) {
    setCount(count + 1);
  }

  return <div>Count: {count}</div>;
}


Fix:
Move the conditional state update to an event handler or a useEffect with proper dependency management to ensure it doesn't run uncontrollably.


4.4. Event Handlers Causing State Updates on Every Render
*Inline Event Handler)
*Why it‚Äôs Wrong:

setCount(count + 1) is executed immediately during render, not when the button is clicked, causing an infinite loop.

Explanation:

The onClick prop receives a function (() => setCount(count + 1)) that is executed only on click, preventing state updates during rendering.

5.5. Using Functions Inside useEffect that Modify State Continuously
*This occurs when a function inside useEffect updates state based on a condition or value that keeps triggering the effect, causing an infinite re-render loop
*import React, { useState, useEffect } from 'react';

function App() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    // Function that continuously updates state
    const updateCount = () => {
      setCount(count + 1); // Updates state on every render
    };
    updateCount();
  }, [count]); // Dependency on count causes the effect to run repeatedly

  return <div>Count: {count}</div>;
}


Fix:
Ensure the function inside useEffect doesn‚Äôt cause state updates that retrigger the effect uncontrollably. Use conditions or a proper dependency array to limit when the effect runs.

Corrected Example:
import React, { useState, useEffect } from 'react';

function App() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    // Only update state if a specific condition is met
    const updateCount = () => {
      if (count < 5) {
        setCount(count + 1);
      }
    };
    updateCount();
  }, [count]); // Dependency array includes count

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Create a Responsive Navbar using ReactJS
* A responsive navbar adapts its layout based on the screen size
*ensuring easy navigation on both mobile and desktop devices
*// components/Navbar/index.js

import React from "react";
import {
    Nav,
    NavLink,
    Bars,
    NavMenu,
    NavBtn,
    NavBtnLink,
} from "./NavbarElements";

const Navbar = () => {
    return (
        <>
            <Nav>
                <Bars />

                <NavMenu>
                    <NavLink to="/about" >
                        About
                    </NavLink>
                    <NavLink to="/events" activeStyle>
                        Events
                    </NavLink>
                    <NavLink to="/annual" activeStyle>
                        Annual Report
                    </NavLink>
                    <NavLink to="/team" activeStyle>
                        Teams
                    </NavLink>
                    <NavLink to="/blogs" activeStyle>
                        Blogs
                    </NavLink>
                    <NavLink to="/sign-up" activeStyle>
                        Sign Up
                    </NavLink>
                    {/* Second Nav */}
                    {/* <NavBtnLink to='/sign-in'>Sign In</NavBtnLink> */}
                </NavMenu>
                <NavBtn>
                    <NavBtnLink to="/signin">
                        Sign In
                    </NavBtnLink>
                </NavBtn>
            </Nav>
        </>
    );
};

export default Navbar;

// components/Navbar/navbarElements.js

import { FaBars } from "react-icons/fa";
import { NavLink as Link } from "react-router-dom";
import styled from "styled-components";

export const Nav = styled.nav`
    background: #63d471;
    height: 85px;
    display: flex;
    justify-content: space-between;
    padding: 0.2rem calc((100vw - 1000px) / 2);
    z-index: 12;
    /* Third Nav */
    /* justify-content: flex-start; */
`;

export const NavLink = styled(Link)`
    color: #808080;
    display: flex;
    align-items: center;
    text-decoration: none;
    padding: 0 1rem;
    height: 100%;
    cursor: pointer;
    &.active {
        color: #000000;
    }
`;

export const Bars = styled(FaBars)`
    display: none;
    color: #808080;
    @media screen and (max-width: 768px) {
        display: block;
        position: absolute;
        top: 0;
        right: 0;
        transform: translate(-100%, 75%);
        font-size: 1.8rem;
        cursor: pointer;
    }
`;

export const NavMenu = styled.div`
    display: flex;
    align-items: center;
    margin-right: -24px;
    /* Second Nav */
    /* margin-right: 24px; */
    /* Third Nav */
    /* width: 100vw;
  white-space: nowrap; */
    @media screen and (max-width: 768px) {
        display: none;
    }
`;

export const NavBtn = styled.nav`
    display: flex;
    align-items: center;
    margin-right: 24px;
    /* Third Nav */
    /* justify-content: flex-end;
  width: 100vw; */
    @media screen and (max-width: 768px) {
        display: none;
    }
`;

export const NavBtnLink = styled(Link)`
    border-radius: 4px;
    background: #808080;
    padding: 10px 22px;
    color: #000000;
    outline: none;
    border: none;
    cursor: pointer;
    transition: all 0.2s ease-in-out;
    text-decoration: none;
    /* Second Nav */
    margin-left: 24px;
    &:hover {
        transition: all 0.2s ease-in-out;
        background: #fff;
        color: #808080;
    }
`;
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
HTML DOM Window scrollY Property
*The scrollY property of the Window interface returns the number of pixels that the document is currently scrolled vertically in the current window.
*This value is subpixel precise in modern browsers, meaning that it isn't necessarily a whole number.
*This is a read-only property.
*Syntax:

var Scry = window.scrollY
Return Value: The returned value is a double-precision floating-point value indicating the number of pixels the document is currently scrolled vertically from the origin.
*<!DOCTYPE HTML>
<html>

<body style="text-align:center;">
    <h1 style="color:green;">
        G<br>
        e<br>
        e<br>
        k<br>
        s<br>
        f<br>
        o<br>
        r<br>
        G<br>
        e<br>
        e<br>
        k<br>
        s<br>
    </h1>

    <p>
        HTML | window scrollY property
    </p>

    <button onclick="Geeks()">
        Click Here
    </button>
    <p id="a"></p>

    <script>
        var a = document.getElementById("a");
        function Geeks() {
            a.innerHTML = "scrollY is : " 
                    + window.scrollY;
        }
    </script>
</body>

</html>
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
How to change the navbar color when you scroll in ReactJS ?
*// components/Navbar.js

import React, { useState, Fragment } from "react";
import { FaBars } from "react-icons/fa";
import {
    Nav,
    NavContainer,
    NavLogo,
    NavItem,
    NavLinks,
    NavMenu,
    MobileIcon,
} from "./NavbarStyles";
import "../App.css";
const Navbar = () => {
    const [colorChange, setColorchange] = useState(false);
    const changeNavbarColor = () => {
        if (window.scrollY >= 80) {
            setColorchange(true);
        } else {
            setColorchange(false);
        }
    };
    window.addEventListener("scroll", changeNavbarColor);
    return (

        <Fragment>
            <Nav
                className={
                    colorChange
                        ? "navbar colorChange"
                        : "navbar"
                }
            >
                <NavContainer>
                    <NavLogo href="#">
                        GeeksForGeeks
                    </NavLogo>
                    <MobileIcon>
                        <FaBars />
                    </MobileIcon>
                    <NavMenu>
                        <NavItem>
                            <NavLinks href="#">
                                About
                            </NavLinks>
                        </NavItem>
                        <NavItem>
                            <NavLinks href="#">
                                Services
                            </NavLinks>
                        </NavItem>
                        <NavItem>
                            <NavLinks href="#">
                                Events
                            </NavLinks>
                        </NavItem>
                        <NavItem>
                            <NavLinks href="#">
                                Contact
                            </NavLinks>
                        </NavItem>
                        <NavItem>
                            <NavLinks href="#">
                                Sign In
                            </NavLinks>
                        </NavItem>
                    </NavMenu>
                </NavContainer>
            </Nav>
        </Fragment>
    );
};

export default Navbar;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
React styled-components Module
*React Styled-component Module allows us to write CSS within JavaScript in a very modular and reusable way in React

1.CSS in JavaScript: Styled-Components enables you to write CSS directly inside your JavaScript files using tagged template literals. For example:

import styled from 'styled-components';

const Button = styled.button`
  background: blue;
  color: white;
  padding: 10px;
  border: none;
`;


2.Enhanced Developer Experience: By keeping styles and component logic together, developers can work more efficiently.
3.No Mapping Between Components and Styles: In traditional CSS, you write styles in a separate file and link them to components using class names or IDs. Styled-Components removes this separation by embedding styles directly in the component definition, making the connection between a component and its styles seamless.
4.Components as Styling Constructs: Styled-Components treats React components as the foundation for styling. You create styled versions of HTML elements or React components, and these styled components can be used like regular React components in your JSX

const Title = styled.h1`
  font-size: 24px;
  color: #333;
`;

function App() {
  return <Title>Hello, World!</Title>;
}


Steps
*npm i --save styled-components
*// Filename - App.js

import Button from "./Button";

function App() {
    return (
        <div
            style={{
                textAlign: "center",
                margin: "auto",
            }}
        >
            <h1 style={{ color: "green" }}>
                GeeksforGeeks
            </h1>
            <h3>React Styled-components example</h3>
            <Button bg="green"> Click </Button>
            <Button bg="yellow"> Click </Button>
        </div>
    );
}

export default App;
*// Filename - Button.js

import styled from "styled-components";

const Button = styled.div`
    height: 50px;
    width: 100px;
    cursor: pointer;
    text-decoration: none;
    color: blue;
    background-color: ${(props) =>
        props.bg === "green" ? "green" : "yellow"};
    margin: auto;
    font-size: 2rem;
`;

export default Button;
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
React Components
1.How to add a CSS class whenever the component is updated in React JS ?
*If we want to update/add a CSS class when the component is updated or the state/props of components 
*import React, { Component } from 'react';
import styles from './index.css';

class App extends Component {
    state = {
        flag: true
    };

    handleUpdate = () => {
        this.setState(
            prevstate =>
                ({ flag: !prevstate.flag })
        );
    };

    render() {
        const flag = this.state.flag;
        return (
            <div>
                <button
                    onClick={this.handleUpdate}>
                    Show Box
                </button>
                <div className=
                    {
                        `box ${flag
                            === false ?
                            "" :
                            "hidden"}`
                    }>
                    <p>click on button to hide and show the box</p>
                </div>
            </div>
        );
    }
}

export default App; and in index.css
.box {
    width: 100px;
    height: 200;
    padding: 20px;
    border: 1px solid black;
}

.hidden {
    display: none;
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
How to Create a Toggle Switch in React as a Reusable Component ?
1.Note:Without position: relative
üì¶ Box sits in its normal place. If a child inside is position: absolute, that child will try to position itself relative to the whole page instead of the box.

scss
Copy
Edit
Page
 ‚îú‚îÄ‚îÄ [ Box ]
         ‚îî‚îÄ‚îÄ Absolute Child (positions from page)
With position: relative
üì¶ Box still sits in the same place as before, but now:

You can nudge it using top, left, right, bottom ‚Äî without breaking the flow for other elements.

Its absolutely positioned children will now use it as the reference for their coordinates.

scss
Copy
Edit
Page
 ‚îú‚îÄ‚îÄ [ Box (relative) ]
         ‚îî‚îÄ‚îÄ Absolute Child (positions from THIS box)
2.Note:But you can shift it from that normal place using top, right, bottom, or left without affecting the position of surrounding elements.
Example:

html
Copy
Edit
<div style="position: relative; top: 20px; left: 30px; background: lightblue;">
  Relative box
</div>
Without top/left, it would be in the normal spot.

With top: 20px; left: 30px; it moves 20px down and 30px right from where it would normally be.

In a toggle switch UI, position: relative; is usually used so that the moving part (the slider/knob) can be absolutely positioned inside it.

If you like, I can make you a toggle switch visual demo showing exactly how position: relative; affects the knob.






3.Note: display: inline-block;
Makes the element behave like an inline element but allows it to have width/height.

This way, the toggle can be placed next to text without forcing a line break.





Also, it becomes the positioning reference for absolutely positioned children (position: absolute;).

*so first of all reate one omponenet which will receive label hee first div with text align tothe center
*and another div with tex algn to the right
*here position is relative sochild elemenst peforms relative to this
*now we need no break between text label and this toggle so the display:inline block so that no break but have some width
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What are WebSockets?
*WebSockets are a communication protocol that provides full-duplex (two-way) communication between a client (browser) and a server over a single, long-lived TCP connection.
*1. How HTTP Normally Works

HTTP is a request-response protocol.

The client (browser) must always initiate communication.

The server only responds when asked.

Example:

Browser ‚Üí "Hey server, give me new messages."

Server ‚Üí "Here are the new messages."

If the client wants to know again, it has to ask repeatedly (polling).

üëâ That‚Äôs why things like live notifications or chat apps are tricky with plain HTTP ‚Äî the client has to keep asking:
"Do you have something new? Do you have something new?..."



2.2. Polling vs Long Polling vs WebSockets
Polling

Client sends a request every few seconds (setInterval).

Wastes bandwidth if no new data.

E.g., checking every 2 seconds for new messages in a chat.

setInterval(() => {
  fetch("/messages").then(res => res.json()).then(console.log);
}, 2000);


‚ö†Ô∏è Problem ‚Üí Lots of unnecessary requests, high server load.


3.3Long Polling

Client sends a request, but the server holds it open until new data arrives.

After server responds, client immediately sends another request.

Reduces wasted requests but still inefficient because a new HTTP request is created each time



WebSockets (Best)

When a WebSocket connection is opened, it‚Äôs persistent.

Both client and server can send messages anytime, over the same connection.

Example:

Client connects once ‚Üí "Hi server, let‚Äôs stay connected."

Server ‚Üí "Okay, I‚Äôll push new messages whenever I have them."

Now, if a new chat message arrives, the server immediately pushes it to the client.

No need for repeated requests ‚úÖ

üîπ 3. Real-World Example

Let‚Äôs say you build a stock price app:

HTTP Polling:

Browser asks every second: ‚ÄúWhat‚Äôs the stock price now?‚Äù

Server replies with latest price.

1000 users polling = 1000 requests/sec üò¨

WebSockets:

Browser connects once.

Server sends updates only when price changes.

1000 users still connected, but no useless traffic. üöÄ

üîπ 4. Small Analogy

HTTP Polling: You keep asking your friend every 5 sec, ‚ÄúDid you get new WhatsApp messages?‚Äù

WebSockets: Your friend just taps you instantly whenever a new message comes.



1.Using WebSockets in React
1.1. Using Native WebSocket API
*
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
what are custom hooks
*Custom Hooks in React are reusable functions that let you extract and share logic across multiple components.
*Example 2: Custom Hook for Form Handling
import { useState } from "react";

function useForm(initialValues) {
  const [values, setValues] = useState(initialValues);

  function handleChange(e) {
    setValues({
      ...values,
      [e.target.name]: e.target.value,
    });
  }

  return [values, handleChange];
}

export default useForm;


üëâ Usage:

function LoginForm() {
  const [form, handleChange] = useForm({ username: "", password: "" });

  return (
    <form>
      <input name="username" value={form.username} onChange={handleChange} />
      <input name="password" type="password" value={form.password} onChange={handleChange} />
    </form>
  );
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is React Forget?
*React Forget is a compiler that automatically optimizes your React code.
*Its main goal: make memoization automatic so you don‚Äôt have to manually wrap things with useMemo, useCallback, or React.memo.
*Status (as of 2025)

Still experimental.

The React team has been working on it for years, but it‚Äôs not yet shipped in stable React.

Once ready, it will likely be integrated into React‚Äôs build tools (like Next.js, Vite, etc.).
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
1. What are React Server Components?
*React Server Components are a feature in React that let you render components on the server instead of the browser, while still being part of your React tree.
*They can be combined with Client Components to build full apps.

*Client Component = runs in the browser (can use useState, useEffect, event handlers).
üëâ Server Component = runs on the server (can fetch data, access DB, call APIs directly, but can‚Äôt use browser-only features).

Why wre they introduced
*To improve performance by rendering on the server with data already ready.

*To make data fetching easier (fetch directly from server without extra APIs).


How do they work?
*RSCs run on the server and return a special serialized format.
*The client receives this output and merges it into the React tree.
*The browser only downloads what it needs (no database logic or server code gets sent).


4. Example

Server Component (UserList.server.js)

// Runs only on the server
import db from "./db";

export default async function UserList() {
  const users = await db.user.findMany(); // direct DB query!
  return (
    <ul>
      {users.map(u => <li key={u.id}>{u.name}</li>)}
    </ul>
  );
}


Client Component (App.client.js)

"use client"; // tells React this runs in the browser

import UserList from "./UserList.server";

export default function App() {
  return (
    <div>
      <h1>Users</h1>
      <UserList /> {/* Server component rendered inside client */}
    </div>
  );
}


üëâ Notice:

The DB query never reaches the browser.

The bundle stays small, only UI code is sent to client.



*these server side coponnetare basically used in the nex.js 13+ and app router
*here by defauly the coponnets are the rsc ,no getserversid props is requied to fetch the data from or api
*// app/page.tsx (Server Component by default)
export default async function Page() {
  const res = await fetch("https://jsonplaceholder.typicode.com/users");
  const users = await res.json();

  return (
    <ul>
      {users.map((u: any) => (
        <li key={u.id}>{u.name}</li>
      ))}
    </ul>
  );
}

*2. Client Components

If you need state, effects, or event handlers, you mark a component with "use client".

Example:

"use client";  // üëà runs in browser

import { useState } from "react";

export default function Counter() {
  const [count, setCount] = useState(0);
  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
what are react portals ?
*Normally, React components render inside their parent DOM node. But sometimes you want to render outside of it.

Examples:

Modals / Dialogs

Tooltips

Dropdown menus

Popovers

These UI elements should not be ‚Äútrapped‚Äù inside their parent‚Äôs overflow: hidden, z-index, or styling.

*3. How do they work?

React provides a ReactDOM.createPortal(child, container) API.

child ‚Üí what you want to render.

container ‚Üí the DOM node where you want it rendered.



5. Benefits

*Escape parent styles (overflow, z-index, etc.).
*Perfect for modals, dropdowns, and tooltips.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
‚ö° Batching in React
1. What is batching?

Batching means React groups multiple state updates into a single re-render, instead of re-rendering for every single setState or useState call.

This makes React apps faster and more efficient.

2. Why do we need batching?

Without batching, every state update would cause React to re-render immediately ‚Üí leading to performance issues if multiple updates happen at once.
With batching, React waits until the end of the event or async cycle, then re-renders only once.

3. Example Without Batching

Imagine batching didn‚Äôt exist:

function Counter() {
  const [count, setCount] = React.useState(0);
  const [total, setTotal] = React.useState(0);

  function increment() {
    setCount(count + 1); // would cause re-render 1
    setTotal(total + 1); // would cause re-render 2
  }

  return (
    <button onClick={increment}>
      Count: {count}, Total: {total}
    </button>
  );
}


üëâ If React didn‚Äôt batch, clicking the button would re-render twice.
But with batching ‚Üí just 1 re-render.

4. React 17 vs React 18

React 17 and before ‚Üí automatic batching only worked inside React event handlers.
If you updated state inside a setTimeout, fetch, or promise, React would not batch.

React 18+ (with concurrent features) ‚Üí batching works for all updates, even inside async callbacks.

Example (React 18):

setTimeout(() => {
  setCount(c => c + 1);
  setTotal(t => t + 1);
}, 1000);
// ‚úÖ Only one re-render happens in React 18
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
üìù Example Code
function Counter() {
  const [count, setCount] = React.useState(5);

  function handleClick() {
    setCount(count + 5);
    setCount(count + 5);
    setCount(count + 5);

    console.log("Inside handler:", count);
  }

  return (
    <button onClick={handleClick}>
      Count: {count}
    </button>
  );
}

üîé Step-by-Step

Initial state: count = 5.

Inside handleClick, you call:

setCount(count + 5); // uses current value = 5 ‚Üí requests update to 10
setCount(count + 5); // still uses 5 ‚Üí requests update to 10
setCount(count + 5); // still uses 5 ‚Üí requests update to 10


üëâ Because state updates are batched and not applied immediately, all three updates see the same stale value (5).

After batching, React applies the last update ‚Üí count = 10.

console.log("Inside handler:", count) logs the old state (5), because React doesn‚Äôt update state until after the function finishes.

‚úÖ Final Behavior

Console log inside handler:

Inside handler: 5


After re-render, count = 10.

üîÑ If You Want It to Accumulate

You need the functional update form of setState:

setCount(prev => prev + 5);
setCount(prev => prev + 5);
setCount(prev => prev + 5);


Now:

prev starts as 5.

First call ‚Üí 10, second ‚Üí 15, third ‚Üí 20.

‚úÖ Final count = 20.

‚ö° Answer to your question

With your code (setCount(count+5)) ‚Üí final count = 10.

With functional updater (setCount(prev => prev+5)) ‚Üí final count = 20.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
what are synthetic evenst in react js
*Synthetic Events are React‚Äôs wrapper around the native browser events.
*They provide a consistent, cross-browser interface to handle events (like onClick, onChange, onSubmit, etc.) in a way that works the same across all browsers.


Why Synthetic Events?

1.Different browsers implement event systems differently.

2.React normalizes them using SyntheticEvent so you don‚Äôt have to worry about browser inconsistencies.

3.It wraps the native event and makes sure properties and methods (like preventDefault(), stopPropagation()) work the same everywhere.


import React from "react";

function App() {
  function handleClick(event) {
    console.log(event);               // SyntheticEvent object
    console.log(event.nativeEvent);   // The actual browser event
    event.preventDefault();           // Works the same across browsers
  }

  return (
    <button onClick={handleClick}>
      Click Me
    </button>
  );
}

export default App;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
optimization of react application fronten enly
1.1. Rendering Optimization
*Wrap components so they only re-render when props change.

const Child = React.memo(({ value }) => <p>{value}</p>);


*Use useMemo / useCallback
Memoize expensive calculations or stable callbacks to prevent unnecessary renders.

const expensiveValue = useMemo(() => heavyCalc(data), [data]);
const stableFn = useCallback(() => doSomething(id), [id]);

*plit large components ‚Üí Break into smaller ones so React only updates what‚Äôs needed.
*Avoid inline functions/objects in JSX (unless memoized).
function App() {
  const [count, setCount] = React.useState(0);

  return (
    <Child onClick={() => setCount(count + 1)} /> // inline function
  );
}

function Child({ onClick }) {
  console.log("Child rendered");
  return <button onClick={onClick}>Click</button>;
here if the prent is re rendered still the setcount function is agin created ,regerece changes hence child re rendered
Even if count doesn‚Äôt change, on every re-render,
() => setCount(count + 1) is a new function reference.

So Child re-renders unnecessarily.

‚úÖ Optimized with useCallback
function App() {
  const [count, setCount] = React.useState(0);

  const handleClick = React.useCallback(() => {
    setCount((c) => c + 1);
  }, []);

  return <Child onClick={handleClick} />;
}

const Child = React.memo(({ onClick }) => {
  console.log("Child rendered");
  return <button onClick={onClick}>Click</button>;
});


useCallback ensures handleClick has a stable reference.

Child will not re-render unless its props really change.




2.2. State Management
*Lift state carefully ‚Üí Don‚Äôt keep global state for everything; keep local where possible.

*Selector-based state updates (Redux/Zustand) ‚Üí Use useSelector with shallow equal or memoized selectors to avoid extra renders.


3.3. Code Splitting & Lazy Loading
*Use dynamic imports with React.lazy & Suspense:

const Chart = React.lazy(() => import("./Chart"));


4.44. Virtualization
*Suppose you render 10,000 rows in a table
*function BigList() {
  const items = Array.from({ length: 10000 }, (_, i) => `Item ${i}`);
  return (
    <div>
      {items.map((item, index) => (
        <div key={index} style={{ height: 35 }}>
          {item}
        </div>
      ))}
    </div>
  );
}

*but viewpart that is part of screen which is visble without scroll show 20-30 items only
Problems:

*Performance hit: React creates and maintains all 10,000 DOM nodes, even if only 20‚Äì30 are visible in the viewport.


*Memory usage increases unnecessarily.






buffer in Virtualized Lists

When you virtualize a list (with react-window or react-virtualized), React renders:

The items currently visible in the viewport.

A few extra items just above and below the viewport ‚Üí this is the buffer (sometimes called "overscan").

‚ùì Why do we need a buffer?

Without a buffer ‚Üí as soon as you scroll, React has to destroy old DOM nodes and create new ones immediately. This can cause flickering or a "blank gap" if rendering lags.

With a buffer ‚Üí some items above/below are pre-rendered so scrolling feels smooth and seamless.





so to solve this problem
When you virtualize a list (with react-window or react-virtualized), React renders:

*The items currently visible in the viewport.

*A few extra items just above and below the viewport ‚Üí this is the buffer (sometimes called "overscan").




5.Asset optimization
*Use WebP/AVIF instead of PNG/JPEG
<img src="image.webp" alt="optimized" />
*azy load below-the-fold images

‚ÄúBelow the fold‚Äù = images not visible until you scroll down.

Instead of loading them immediately, let the browser load them only when needed.

üëâ Example:

<img src="hero.jpg" alt="hero" />   {/* loads immediately */}
<img src="gallery.jpg" loading="lazy" alt="gallery" /> {/* loads on scroll */}


Saves bandwidth.

Improves initial render speed.


*Compress SVGs

SVGs are XML ‚Üí can contain extra metadata, comments, unused paths.

Tools like SVGO or ImageOptim compress them (sometimes 50%+ smaller).

*Icons

Icons often bloat apps when imported from huge libraries (like Material Icons full pack).

‚úÖ Use react-icons

Lightweight ‚Üí imports only the icons you use.

Example:

import { FaBeer } from "react-icons/fa";

function App() {
  return <h3>Cheers! <FaBeer /></h3>;
}


üëâ Only FaBeer icon is bundled, not the entire set.

*Why Asset Optimization Matters

Faster First Paint (page shows up quickly).

Lower bundle size ‚Üí better Lighthouse/Google PageSpeed score.

Saves mobile data usage.

Improves SEO & Core Web Vitals (esp. Largest Contentful Paint ‚Äì LCP).

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
how to handle the large datasets
1. Virtualization (Best Option)

Instead of rendering all 5000 rows, render only what‚Äôs visible in the viewport.

Libraries: react-window, react-virtualized.

Works for lists, tables, and grids.

üëâ Example (5000 rows with react-window):

import { FixedSizeList as List } from "react-window";

const items = Array.from({ length: 5000 }, (_, i) => `Row ${i}`);

function Row({ index, style }) {
  return <div style={style}>{items[index]}</div>;
}

export default function App() {
  return (
    <List
      height={400}        // viewport height
      itemCount={items.length}
      itemSize={35}       // row height
      width={300}
    >
      {Row}
    </List>
  );
}


üëâ Even though dataset = 5000 rows, DOM = only ~20 rows at a time.


2.function PaginatedTable({ data }) {
  const [page, setPage] = React.useState(1);
  const pageSize = 100;

  const start = (page - 1) * pageSize;
  const end = start + pageSize;
  const currentData = data.slice(start, end);

  return (
    <>
      <table>
        <tbody>
          {currentData.map((row, i) => (
            <tr key={i}><td>{row}</td></tr>
          ))}
        </tbody>
      </table>
      <button onClick={() => setPage(p => p - 1)} disabled={page === 1}>Prev</button>
      <button onClick={() => setPage(p => p + 1)} disabled={end >= data.length}>Next</button>
    </>
  );
}



3.3. Infinite Scrolling

Load initial chunk (say 100 rows), then load more when scrolling near bottom.

Library: react-infinite-scroll-component

Good balance between performance and UX.

üîπ 4. Memoization & Rendering Optimization

Even with 5000 items:

Use React.memo on row components.

Use stable keys (id, not index).

Avoid inline functions/objects passed as props ‚Üí use useCallback / useMemo.

üîπ 5. Debounce/Throttle Operations

If dataset is searchable or filterable:

Debounce input so filtering happens after user stops typing.

Example with lodash:

const handleSearch = _.debounce((value) => {
  setFiltered(data.filter(d => d.includes(value)));
}, 300);

üîπ 6. Offload Heavy Work

Expensive operations (sorting, filtering, aggregations) ‚Üí move outside render, or use Web Workers.

Example: For 5000 rows, sorting on every keystroke will lag ‚Äî debounce it or do it async.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Lazy loading vs efficient rendering


1.Lazy Loading

What it is:
Load content only when it is needed, instead of upfront.
Where it‚Äôs used:

Images (loading="lazy" or IntersectionObserver) ‚Üí only loads when user scrolls near them.

React components (React.lazy + Suspense) ‚Üí only load code for a route/component when visited.

Goal:reduces the load time

2.rendering
*ui upadtes in a way to reduce unnecessary dom work or re-renders
*here it‚Äôs used:

React memoization (React.memo, useMemo, useCallback) ‚Üí avoid recalculations/re-renders.

Virtualization (e.g., react-window, react-virtualized) ‚Üí only render visible list items.

Batching updates ‚Üí React groups multiple setState calls to reduce re-render passes.

Minimizing reconciliation ‚Üí key usage in lists, avoiding deep prop changes.

Goal:after data is loaded then reduce the rendering cost
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
what is intersection observer
*Intersection Observer is a browser API that lets you asynchronously detect
*element enters or leaves the viewport (or another container)
*without continuously listening to scroll events

so our old way is :

<body>
  <div class="spacer">Scroll down üëá</div>
  <div class="watch-me">I‚Äôm being watched!</div>
  <div class="spacer"></div>


*function isInViewport(element) {
  const rect = element.getBoundingClientRect();//retrev position is resect to viewport
  return (
    rect.top >= 0 &&
    rect.left >= 0 &&
    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
    rect.right <= (window.innerWidth || document.documentElement.clientWidth)
  );
}

window.addEventListener("scroll", () => {
  document.querySelectorAll(".watch-me").forEach(el => {
    if (isInViewport(el)) {
      console.log("Element is visible:", el);
    }
  });
});



But now
Observer api
*üîπstep by step
const observer = new IntersectionObserver((entries, observer) => {
  entries.forEach(entry => {
    console.log("Target element:", entry.target);
    console.log("Is visible:", entry.isIntersecting);
    console.log("Visibility ratio:", entry.intersectionRatio);
    console.log("Bounding box:", entry.boundingClientRect);
    console.log("Root box (viewport):", entry.rootBounds);
    console.log("Intersection box (visible part):", entry.intersectionRect);
  });
}, { threshold: [0, 0.5, 1] });

const box = document.querySelector(".watch-me");
observer.observe(box);

*const observer = new IntersectionObserver((entries, observer) => { ... }, options);

*Creates an observer object.

*Callback (entries): The browser calls this function whenever the element enters or leaves the viewport.

*entries.forEach(entry => { ... })

The callback receives an array of IntersectionObserverEntry objects ‚Üí one for each observed element that changed visibility.
*
entry.target

The DOM element being observed (e.g., your .watch-me div).

Lets you update styles, text, etc.

4. entry.isIntersecting

true if the element is currently visible (even partially) in the viewport (or root container).

false if it‚Äôs completely outside.

5. entry.intersectionRatio

A number 0 ‚Üí 1 showing how much of the element is visible.

0 ‚Üí Not visible.

0.5 ‚Üí 50% visible.

1 ‚Üí Fully visible.

6. entry.boundingClientRect

Similar to getBoundingClientRect().

Tells you the element‚Äôs box position (top, left, bottom, right, width, height) relative to the viewport.

Example output:

{
  "x": 50,
  "y": 600,
  "width": 200,
  "height": 200,
  "top": 600,
  "left": 50,
  "bottom": 800,
  "right": 250
}




example:
const box = document.querySelector(".watch-me");

const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      entry.target.style.background = "lightgreen";
      entry.target.textContent = "‚úÖ Visible in viewport!";
    } else {
      entry.target.style.background = "salmon";
      entry.target.textContent = "I‚Äôm being watched!";
    }
  });
}, { threshold: 0.5 }); // trigger when 50% is visible

observer.observe(box);

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is mutation observer
*A built-in JavaScript API that lets you watch the DOM for changes
*add, remove, modify elements or attributes).
*It‚Äôs like an event listener, but instead of listening to clicks or scrolls, it listens to DOM mutations.
*When to Use

*Detect when new elements are added/removed from the DOM.

*Track attribute changes on an element.

*Watch for text/content changes inside elements.

Useful in dynamic apps (React, Angular, etc.), browser extensions, or when working with 3rd-party scripts.
HTML
<div id="container">
  <p>Hello</p>
</div>
<button id="add">Add New Item</button>

JS
// 1. Select the node to observe
const container = document.getElementById("container");

// 2. Create an observer with a callback
const observer = new MutationObserver((mutationsList, observer) => {
  mutationsList.forEach(mutation => {
    console.log("Mutation type:", mutation.type);

    if (mutation.type === "childList") {
      console.log("Added nodes:", mutation.addedNodes);
      console.log("Removed nodes:", mutation.removedNodes);
    }

    if (mutation.type === "attributes") {
      console.log("Attribute changed:", mutation.attributeName);
    }
  });
});

// 3. Tell the observer what to watch
observer.observe(container, {
  childList: true,      // Watch for add/remove of children
  attributes: true,     // Watch for attribute changes
  subtree: true         // Watch entire subtree, not just direct children
});

// 4. Example: Add a new element dynamically
document.getElementById("add").addEventListener("click", () => {
  const newItem = document.createElement("p");
  newItem.textContent = "New item " + Date.now();
  container.appendChild(newItem);
});



-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
what are web workers
*so js is single threade means all ui updates,newtork ll happens on the single theread
*f you run something heavy (e.g., big loops, image processing ui will freeze
Web Workers solve this by letting you run JS code in a separate thread.


What is a Web Worker?
*A background thread that runs JavaScript code parallel to the main thread.
*Doesn‚Äôt have access to the DOM directly (no document or window).
*A background thread that runs JavaScript code parallel to the main thread.

Doesn‚Äôt have access to the DOM directly (no document or window).

Communicates with the main thread using messages (postMessage + onmessage).


Basic Example
worker.js (the worker file)
// Runs in background
self.onmessage = function (e) {
  console.log("Message received from main thread:", e.data);

  // Do heavy calculation
  let sum = 0;
  for (let i = 0; i < 1e9; i++) sum += i;

  // Send result back
  self.postMessage(sum);
};

main.js (main thread)
// Create worker
const worker = new Worker("worker.js");

// Send message to worker
worker.postMessage("Start calculation");

// Receive result
worker.onmessage = function (e) {
  console.log("Message from worker:", e.data);
};
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
0----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Commonly asked react lld design questions and syatem design questions

