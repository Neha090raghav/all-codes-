a
https://takeuforward.org/strivers-a2z-dsa-course/strivers-a2z-dsa-course-sheet-2-atoz striver couse



https://tm.udemy.com/course/react-for-busy-developers-learn-by-doing-ecommerce/learn/lecture/23812390?start=225#overview----continued course on react
https://tm.udemy.com/course/the-complete-javascript-course/learn/lecture/22649357?start=0#overview-javascript course continued 


https://tm.udemy.com/course/html-and-css-bootcamp/learn/lecture/35813470#overview-html css------frontend
https://tm.udemy.com/course/react-tutorial-and-projects-course/learn/lecture/35174758#overview-react course----frontend
https://tm.udemy.com/course/the-complete-guide-to-angular-2/learn/lecture/43778652#overview-angular----frontend



https://tm.udemy.com/course/corejavamadeeasy/learn/lecture/5863424?start=15#overview-java course---coninued
https://tm.udemy.com/course/spring-5-with-spring-boot-2/learn/lecture/43387862#overview-sprinboot course

*https://tm.udemy.com/course/mongodb-the-complete-developers-guide/learn/lecture/13914002#overview----mongo
*https://tm.udemy.com/course/nodejs-express-mongodb-bootcamp/learn/lecture/15064262#overview--both
https://tm.udemy.com/course/react-nodejs-express-mongodb-the-mern-fullstack-guide/learn/lecture/16808122#overview---afterfull stack

deletion of head  sin single ha check if head is null otherwise dlete 
deletion in single for the k check haeda is null than k===1 than emp increase cnt than check cnt==k than take case f prev
insertion in the single double list at k os is check if head===nul nd ===1 ,then if linked list than the k===1 than other cae take cnt+= and vheck cnt==k-1

in the double deletion of head take the case if head===null or head->next==null
fo the k check the head tn ==1 then the cnt++ braek as we have already prev
insertion in the single check same thing but dont take the prev thing

adobe
amazon
pbliscis
airtel
amex
hsbc
Infosys



js,css,react,redux,rtk,typscript,system design frontend
core java,
multithreading
jdbc
spring






Note:hash array take the time complexity as 0(1) to push but space as 0(n)but useful for small array size
*ordered map for push takes o(logn) and the spac as 0(n) same with the ordered set
*unordered map take o(1) and space as 0(n) and same with the unordered set
*(vector push takes the time complexity of 0(1) but space of 0(n)
**for the staircase use that technique of staircase


Container	Insert Time	Access Time	Space	Maintains Order?
Hash Array	O(1)	O(1)	O(N)	❌
vector	O(1)*	O(1)	O(N)	✅ (insertion order)
map	O(log N)	O(log N)	O(N)	✅ (sorted)
unordered_map	O(1)*	O(1)*	O(N)	❌
set	O(log N)	N/A	O(N)	✅ (sorted)
unordered_set	O(1)*	N/A	O(N)	❌

* = amortized average-case, worst-case can be worse

*Reason as stack push takes o(1) and space complexity ill be 0(N)

*for the single linked list than the first bond then frrr
*Unlinks the original head (temp) from both ends (temp->next = NULL and head->prev = NULL)




------------------------------------------------------------------------------------------------------------------------------------------------------------

 *array is a collection of similar data types
*now in c++ we declare array as int arr[6];
*in java we declare array as int arr[]=new int[6]
*if we declare array inside of the int main then memory allocated for array and each elemnt have a garbage value
*if we declare array outside of int main then the memory allocated to array and each elemnt have value 0.
*the maximum size of an array is 10^6 thus we can declare an array int arr[10^6] but inside main.
*the maximum size of an array is 10^7 thus we can declare an array int arr[10^7] but outside main.
*array indexing starts from [0 to n-1];
*now after int arr[6] memory is allocated for 6 element,the 0 th index elemnt is stored at location x,then 1 index elemmet will be stored at x+1,
*so at contigous memeory location these index elements are stored.
*we cant predict these memory lpcations but can predict the index so we access the array  using the index not memmory locations.
1.largest element in an array:
brute force
*so if we sort the array
*then index arr[n-1] will be the last element
then time complexity of merge sort and quick sort is o(nlogn) and space complexity will be o(1)

no better solution
optimal solution
*we know one element will be the largest conside largest=arr[0]
*now traverse and check if largest<a[i],if true then largest=a[i],and hence largest will be largets element,
then time complexity will be o(n)and optimal as we optimized the time complexity from o(nlogn)to o(n)
#include <bits/stdc++.h> 
int largestElement(vector<int> &arr, int n) {
    // Write your code here.
    int largest=arr[0];
    for(int i=0;i<n;i++)
    {
        if(largest<arr[i])
        {
            largest=arr[i];
        }
    }
    return largest;
}
2.second largest element in an array
brute force:
*first sort the array
*first we know that the largest is arr[n-1],but we cant say that arr[n-2]is second largest,bcz if arr[n-2]==largest than its not second largest,so we will agin check arr[n-3]==largest,if not this is secondlargest.
so for(i=n-2;i>=0;i--){
if(a[i]!=largest)
{
secondlargest=a[i];
break;
}}
hence secondlargestelement is the the second largest elemnt in an array
*here time complexity will be o(nlogn)for the sorting and worst case if we traverse whole array and each elemnt is equal to largest element and we didnt get largest and for that traversing tc is o(n) and total tc=o(nlogn)+0(n)
better solution
*first find the largest element in an array 
*then again take the secondelement=-1 supposing no second largest eleemnt considering that the array contains all largest and then traversing each saying for(i=0;i<n;i++)
{
if(secondlargest<a[i]&&a[i]!=largest)
{
secondlargest=a[i];
}
}
now the tc will be o(n)+o(n)
optimal solution:
*now main logic is set largest=a[0] and secondlargest=-1;
*travers from i=1 and check if arr[i]>largest,then secondlargest=largest;largest=arr[i];and largest=arr[i];else if arr[i]<largest&&a[i]>secondlargest
then secondlargest=a[i];
for(int i=0;i<n;i++)
{
if(largest<arr[i])
{
sl=largest;
largest=a[i];
}else if(a[i]<largest&&a[i]>sl){
sl=a[i];
}}

note:in this part we have the thing is that array must have 2 element atleast and has unique means secobdlargest will exists.
*note:another thing  is that here we will take largest=-1 as a[i]>=0 and for second smallest =int_max as a[i]<=10^9 so 
vector<int> getSecondOrderElements(int n, vector<int> a) {
    // Write your code here.
    int largest=a[0];
    int sl=-1;
    for(int i=1;i<n;i++)
    {
        if(largest<a[i])
        {
            sl=largest;
            largest=a[i];
        }else if(largest>a[i]&&a[i]>sl)
        {
            sl=a[i];
        }
    }
    // return sl;
    int smallest=a[0];
    int ss=INT_MAX;
    for(int i=1;i<n;i++)
    {
        if(smallest>a[i])
        {
            ss=smallest;
            smallest=a[i];
        }else if(a[i]>smallest&&a[i]<ss)
        {
            ss=a[i];
        }
    }
    return {sl, ss};
}

*to check if array is sorted or not.
traverse from i=1 and to n and check if a[i]>a[i-1] if true than ohk else set any flag=false and return that flag;
so tc will be o(n)
int isSorted(int n, vector<int> a) {
    // Write your code here.
    for(int i=1;i<n;i++)
    {
        if(a[i]>=a[i-1])
        {

        }else{
            return false;
        }
    }
    return true;
}
*so remove duplicates from given array
so we are given array and it contains duplicates so we need to modidfy them by listing first all unique elements and put them first and replace all by anything and from that modidfied array return the unique elements.
*brute force:so brute force will be the tak as set set<int>st and for(i=0;i<n;i++){
st.insert(a[i]);
}
thus all unique elements will be inserted into set and then the iterate over set,i=0; for(auto it:st)
{
a[i]=st;//here inserting set element into the array 
i++;}
and then arary modidfied return the i;
here tc=o(nlogn)for inserting elements and then 0(n)for inserting elements into an array 
sc=o(n)for the elements stored into an set.
now optimal solution:we will use 2 pointer approach here so the thing is that the first ponter i at 0 then we will find j=i+1 to j<n and if(a[j]!=a[i]) means thay are not duplicate then the it need to be at position i+1 and then i++.
*return i+1;

#include<bits/stdc++.h>
int removeDuplicates(vector<int> &arr, int n) {
	int i=0;
    for(int j=1;j<n;j++)
    {
        if(arr[i]!=arr[j])
        {
            arr[i+1]=arr[j];
            i++;
        }
    }
    return i+1;
    
}
*left rotate array by one place
*so left rotatae means first element at last and then all aothers move toward right.
*so brute will be take the another array and store but we eneed to make changes in orirgonal array
* so optimal solution will be 
temp=arr[0]
for(int i=0;i<n-1;i++)
{
arr[i]=arr[i+1]
}
arr[i]=temp;
#include <bits/stdc++.h> 
vector<int> rotateArray(vector<int>& arr, int n) {
    // Write your code here.
    int temp=arr[0];

    for(int i=0;i<n-1;i++)
    {
        arr[i]=arr[i+1];
    }
    arr[n-1]=temp;
    return arr;

}
atoz dsa course
*learn basics
here time taken is not quivalent to time taken by code to run on different platforms as time taken by code depends on the different systems.
*suppose to a machine we give 10 input size and time it takes is 1s,for 20 input size its 2s,for 30 its 3s  so theta is tthe rate of increase of time with respect to input size and is called the time complexity,
*time complexity is measured in terms of the o(n)
*for(int i=1;i<5;i++){
cout<<i;
}
thus here the thing is if we want the time complexity it is basically the no of steps taken by this piece of code
*here 1 st step will be initialization,second is the comparison,third is the print and 4th is i++ 5 th is again comparison,so the thing is that we cant do it manually so here 3 rules come.
*there are 3 cases best cases is when code takes the less time so if(marks<25){coutraj;}this is executed once hence best case
*worst case is which code takes the most time that is when the condition is met at the last time.
*note:always take time complexity in terms of the worst cases
*always avoid the constants for ex o(n^3+4n^2+8)thus here the n=10^5 then 8 has no significan and must be avoided.
int n=2;
*for(int i=1;i<5;i++){
cout<<i;
} here tc=o(n)  not o(n+1)
*avoid lowe value thus 0(10^6+10^3) here 10^3 must be avoided as its lower than higher balue
*big o is upper bound means worst cases.
*omega for best case also called the loweround.
*theta for average case
*consider for(i=0;i<n;i++)
{
for(int j=0;j<n;j++)
{
}}
thus for i=0 jhave n iteration
for i=1;j have n ieration 
thus total=n+n+     total number of i iteration that is n thsu tc=n/2(2*n+(n-1)*0)=n^2
*consider for(i=0;i<n;i++)
{
for(int j=0;j<=i;j++)
{
}}
for i=0,iteration is 1 that is 0
for i=1;ieration is 2 that is 0,1
thus tc=n/2(2*1+(n-1))=n*n+1/2
*space complexity is the memory that the programme takes.
*big o notation is used
*input space is the space taken to store the input for example we already have input a and b thus space is sinput space and problem is to find the sum
*the extra space needed to solve the problem is caleed the auxilarry space.here sum is taking the auxillary space.
*auxillary+input=space complexity
*if we are using the array int a[n] then the we say we are using o(n) space.
*patterns:
1->first count the no of rows to for outer loop
2->then for  inner loop  and connect columns somewhom to rows
3->print the * inside the inner loop
4->observe the symmetry

1->****
   ****
   ****
   ****


#include <iostream>

using namespace std;
void print1(int n)
{
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            cout<<"*";
        }
        cout<<endl;
    }
}

int main()
{
    int n;
     cin>>n;
    // cout<<"Hello World";
    print1(n);

    return 0;
}




n forest code void nForest(int n) {
	// Write your code here.
	 for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            cout<<"* ";
        }
        cout<<endl;
    }

}



2->*
   **
   ***
   ****
   *****
it has 5 rows and 1 column for the 0  th row and 2 column for the 1st row,3 columns for the 2nd row
/******************************************************************************

                              Online C++ Compiler.
               Code, Compile, Run and Debug C++ program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/

#include <iostream>

using namespace std;
void print1(int n)
{
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<=i;j++)
        {
            cout<<"* ";
        }
        cout<<endl;
    }
}

int main()
{
    int n;
     cin>>n;
    // cout<<"Hello World";
    print1(n);

    return 0;
}
for nz forest 2
for(int i=0;i<n;i++)
    {
        for(int j=0;j<=i;j++)
        {
            cout<<"* ";
        }
        cout<<endl;
    }
3->1
   1 2
   1 2 3
   1 2 3 4
   1 2 3 4 5

thus total row is 5
and 1 st column is in 0th row but here element is also 1,2 column is in 1th row but here element is also 1 and 2
 for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
        {
            cout<<j <<" ";
        }
        cout<<endl;
    }
4->1
   2 2
   3 3 3
   4 4 4 4
   5 5 5 5 5
for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
        {
            cout<<i <<" ";
        }
        cout<<endl;
    }
5.*****
  ****
  ***
  ** 
  *
in this total rows=5
and total 5 columns in 0 th row means total rows-current row will be the no of columns
total 4 columns in 1 th row total rows-current row will be the no of columns
for(int i=0;i<n;i++)
    {
        for(int j=0;j<n-i;j++)
        {
            cout<<" *";
        }
        cout<<endl;
}
6->12345
   1234
   123
   12
   1

so total rows=5
and 5 columns in 0 st row means total colums is n-i but we need to start here from 1 as we need to print the j values total colums=n-i+1
for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n-i+1;j++)
        {
            cout<<j<<" ";
        }
        cout<<endl;
}
7->     *    
       ***
      *****
     *******
    *********
so total row is 5
now for this 9 columns for every row but in 0 th row [4spaces,1 star,4 spaces]
                                           1st th row [3spaces,3 star,3 spaces]
so funda is first all spaces will be printing the n-i-1 spaces and 2*i+1 stars and again n-i-1 spaces after stars
for(int i=0;i<n;i++)
    {
        for(int j=0;j<n-i-1;j++)
        {
            cout<<" ";
        }
for(int k=0;k<2*i+1;k++)
        {
            cout<<"*";
        }
for(int l=0;l<n-i-1;l++)
        {
            cout<<" ";
        }
cout<<endl;
        
}
8->*********
    *******
     *****
      ***
       *
total rows=5
and total columns=9 in every row but 9 columns in 0 row
                                   [1space,7stsrs,1space]in the 1 row
                                   [2space,5stsrs,2space]in the 2 row thus space=i and starts=n-2*i space=i
for(int i=0;i<n;i++)
    {
        for(int j=0;j<i;j++)
        {
            cout<<" ";
        }
for(int k=0;k<2n-(2*i+1);k++)//where n= number of rows
        {
            cout<<"*";
        }
for(int l=0;l<i;l++)
        {
            cout<<" ";
        }
cout<<endl;
        
}
9->start diamond combination of 7 and 8
void nStarDiamond(int n) {
    // Write your code here.
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n-i-1;j++)
        {
            cout<<" ";
        }
for(int k=0;k<2*i+1;k++)
        {
            cout<<"*";
        }
for(int l=0;l<n-i-1;l++)
        {
            cout<<" ";
        }
cout<<endl;
        
}
for(int i=0;i<n;i++)
    {
        for(int j=0;j<i;j++)
        {
            cout<<" ";
        }
for(int k=0;k<2*n-(2*i+1);k++)
        {
            cout<<"*";
        }
for(int l=0;l<i;l++)
        {
            cout<<" ";
        }
cout<<endl;
        
}
}
10->

*
**
***
****
*****
****
***
**
*
now the loop will go like this
for(int i=0;i<2*n-1)where n=5 which is the number of rows till which i can see symmetry
{
stars=i;
if(i==n)
{stars=2*n-i-1;
}

for(int j=0;j<=stars;j++)
{
cout<<("*");
}
}
for(int i=0;i<2*n-1;i++)
    {
       int stars=i;
       if(i==n)
       {
           stars=2*n-i-1;
       } 

       for(int j=0;j<=stars;j++)
       {
           cout<<"*";
       }
       cout<<endl;
    }
*11->1
     0 1
     1 0 1
     0 1 0 1 
     1 0 1 0 1
     
here 5 rows means for(int i=0;i<n;i++)
{
and if(i%2==0)//then start=1 else start=0;
//now for columns
for(int j=0;j<=i;j++)
{
cout<<start;
//now to flip between 0 and 1
start=1-start;
}
cout<<endl;
}
void nBinaryTriangle(int n) {
    // Write your code here.
    int start=1;
    for(int i=0;i<n;i++)
    {
        if(i%2==0)
        {
            start=1;
        }else{
            start=0;
        }
        for(int j=0;j<=i;j++)
        {
            cout<<start<<" ";
            start=1-start;
        }
        cout<<endl;
    }
}
*1      1
 1 2   2 1
 1 2 3 3 2 1

so the pattern is 1 number,6 spaces,1 number

int space=2*(n-1)
for(int i=0;i<rows;i++)
{
for(int j=0;j<=i;j++)
{
cout<<j+1;//number
}


now for space first there is 6 spaces which we got by 2*(n-1)
and on each step reduce it by 2
for(int i=0;i<space;i++)
{
cout<<" ":
for(int k=i;k>=0;k--)
{
cout<<k+1;//numbers but reverse order
}
cout<<endl;
space=space-2;
}


void numberCrown(int n) {
    // Write your code here.
    int spaces=2*(n-1);
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<=i;j++)
        {
            cout<<j+1;
        }
        for(int k=0;k<spaces;k++)
        {
            cout<<" ";
        }
        for(int l=i;l>=0;l--)
        {
            cout<<l+1;
        }
        cout<<endl;
        spaces=spaces-2;
    }
}
*13->
1
2 3
4 5 6
7 8 9 10
11 12 13 14 15
int num=1;

for(int i=0;i<n;i++){
for(int j=0;j<=i;j++)
{
cout<<num<<" ";

}
cout<<endl;
}
14.A
AB
ABC
ABCD
ABCDE

for(int i=0;i<n;i++)
{
for(char j='A';j<='A'+i;j++)
{
cout<<j<<" ";//here 'A'+i means i steps ahead of A
}
cout<<endl;
}
15->ABCDE
    ABCD
    ABC
    AB
    A
for(int i=0;i<n;i++)
{
char c='A';
for(int j=n;j>i;j--)
{
cout<<c<<" ";//here 'A'+i means i steps ahead of A
c++;
}
cout<<endl;
}
now to remove the dependency of any character on the j put j='A' and run till 'A' +(n-i-1)
for(int i=0;i<n;i++)
{

for(char j='A';j<='A'+(n-i-1);j++)
{
cout<<j<<" ";//here 'A'+i means i steps ahead of A

}
cout<<endl;
}

16
A
BB
CCC
DDDD
EEEEE


for(int i=0;i<n;i++){
for(int j=0;j<=i;j++)
{
cout<<'A'+i<<" ";//here code will be taking this 'A'+i as int bcz In C++, when you use the << operator with cout to output a character, the character is treated as its ASCII value. The expression 'A' + i adds the ASCII value of the character 'A' to the value of i. Since characters in C++ are represented as integers using their ASCII values, the result of this addition is an integer.


}
cout<<endl;
}



for(int i=0;i<n;i++){
        char ch='A'+i;
for(int j=0;j<=i;j++)
{
    
cout<<ch<<" ";
}
cout<<endl;
}
*17    A 
      ABA
      ABCAB
     ABCDCBA
its similar to the pattern 7
but it has some patterns
so basically it has 4 spaces,1 letter ,4 spaces
                    3 spaces,3 letters,3 spaces

SO 4 SPACES is basically from the n-i-1,and no  of character will be 2*i+1 but the thing is observing the symmetry it will ++ till 2*i+1/2//half+1,and then it decrease for(int i=0;i<n;i++)
    {
        for(int j=0;j<n-i-1;j++)
        {
            cout<<" ";
        }
char c='A';
breakpoint=2*i+1/2+1;


for(int k=0;k<2*i+1;k++)
        {
            cout<<ch<<" ";
if(k<breakpoint=2*i+1/2+1;)
{
ch++;
}else
{
ch--;
}

        }
for(int l=0;l<n-i-1;l++)
        {
            cout<<" ";
        }
cout<<endl;
        
}
18.E
  DE
  CDE
  BCDE
for(int i=0;i<n;i++)
{
for(char j='E'-i;j<='E';j++)
{
cout<<j<<" ";
}
cout<<endl;
}
*19
**********
****  ****
***    ***
**      **
*        *
----------same below


now the stars spaces stars
       n-i| 5      0 |2*i     5
        4      2       4
        3     4        3 

        4    6         4
for(int i=0;i<n;i++)
{
for(int j=1;j<=n-i;j++)
{
cout<<"*";
}
for(int k=0;k<2*i;k++)
{
cout<<" ";
}
for(int j=0;j<n-i;j++)
{
cout<<"*";
}


}
*20
------------------------------------------------------------------------------------------------------------------------------------------------------------
STL IN C++

*#include<math.h>means you want to include all the library into math.h and now we can use math.h into our code and it will add all the libraries inside it into the programme
*#include<bits/stdc++.h>
using namespace std;
int main()
{
int a;
cin>>a;
}
now if we remove the using namespace std;
#include<bits/stdc++.h>

int main()
{
int a;
cin>>a;//this will give error
std::cin>>a;
}
*c++ stl is  divided into 4 parts 1.algorithms
                                  2.functions
                                  3.containers
                                  4.iterators
*pair is a utility library that stores 2 variables
pair<int,int>p={1,2}
cout<<p.first<<p.second//p.first will get us 1 and second will give 2.
pair<int,pair<int a,int b>>p={1,{2,3}}
cout<<p.first<<p.second.first<<p.second.second
pair<int ,int>arr[]={{1,2},{3,4},{5,6}}//it means pair but pair of array
cout<<arr[0].first;
*now first container is vector,suppose we declared the array as int arr[5]={1,2,3,4,5}now i wanted to add 6 for that we need to modify size and we cant do that as array size are fixed,now to solve this problem vector came which are dynamic in size .
*vector are container whose size are dynamic in nature 
vector<int>v//declaring the vector 
v.push_back(1);// will push 1 into it
v.emplace_back(2);//it will also insert but it is faster than that push_back
vcetor<pair<int,int>>a;//declaring the pair with the vector 
a.push_back({1,2})//here you need to insert like the syntax for pair but a.emplace_back(1,2)//it will automatically consider it 

vector<int>v(5)//declaring container of size 5
vector<int>v1(5,100)//declaring the container with size 5 and 100 is filled in 5 places,note that here after filling 5 we can again insert it at more than 5 positiobs
vector<int>v2(v1)//copying vector v1 into v2

suppose we have vector v={20,15,10,6,7}we can access the elements using v[0],v[1] but we will use iterators,vector<int>::iterator it=v.begin()//here it is the iterator on the vector v and it will point at the memory address of the first eleemnt stored in the vector v and to access the elemnt cout<<*(it);
vector<int>::iterator it=v.end()//it will point to the ele,element just after the least element of the array so it will not point to 7 instead it-- will point to 7 i.e.the last elememnt of the array
now v.back()//means element at the last that is 7
//now fr traversing for(vector<int>::iterator it=v.begin();it!=v.end();it++)
{
cout<<*(it);
}
now auto it=5 //means it will autpomaticaaly assign data type to variables that means 
for(auto it=v.begin();it!=v.end();it++)
{
cout<<*it}
for(auto it:v)//here it means integer data type automatically iterator over the vector with same data type as elemnts of an array
{
cout<<it;

}
now to delete suppose v={10,20,30,40,50} now v.erase(v.begin()+1)//here we provode the location where you wanted to delete
suppose i wanted to delete more than one then v.erase(v.begin()+1,v.end()-2);//here the 2 nd argunennt is one more than position you wanted to delete
now i wanted to have one elememt inserted 2 times continusly the vector<int>v(2,100)
no want to insert the elemt at a particular position then v.insert(v.begin()+1,100)//it mwans insert the element 100 at the 1 st index
v.insert(v.begin()+1,2,100)//it means insert the 100 2 times starting from position with index 0
v.size()//shows the size of the vector
v.pop_back()
v.clear()//erases every element and give empty vector{}
*list is also a container like the vector but the thing is that it allows frontoperation
list<int>ls
ls.push_back(2)//{2}
ls.push_back(4)//{2,4}
ls.push_front(5)//{5,2,4}it will then push it at front as the insert function in vector is very costly this push_front is very cheap
ls.emplce_front(6)//{6,5,4,2}
//rest functions are same as the vector
*deque is another container just like list and vector that also allows the pop of the front 
deque<int>dq;
dq.push_back(1)//{1}
dq.emplace_back(2)//{1,2}
dq.push_front(3);{3,1,2} 
dq.emplace_front(4)//{4,3,1,2}
dq.pop_front()//{3,1,2}
dq.pop_back()//{3,1}
*stack follows the last in first out data structure
stack<int>s1;
s1.push(1)//{1}
s1.push(2)//{2,1}
s1.push(3)//{3,2,1}
s1.top()//3
s1.pop()//{2,1}
s1.size()
s1.empty()
hre top,pop,push take o(1) time complexity
*queue is also fifo structure 
queue<int>q;
q.push(1);{1}
q.push(2);{1,2}
q.push(4);{1,2,4}
q.bqck()//4
q.pop()//pop out 1 and {2,4}
q.front()
*deque is not a linear data structure innstead it has a tree inside it 
deque<int>dq;
dq.push(1){1}
dq.push(8);{1,8}
dq.push(10);{1,8,10}
dq.push(4);{10,8,4,2}
here now elements wll be arranges in descending ordr so at the top will be {10,8,4,2}//this is max heap
dq.top()//10
note:if  you wanted to store the smallest element at the top then for that format is 
priority_queue<int,vector<int>,greater<int>>dq;
dq.push(2};{2}
dq.push(1)//{2,1}=>{1,2}
dq.top()//1
//this is min heap
note:here push takes o(logn) and pop takes o(logn) and top takes o(1)time
note:from the  stach,push,top,pop started
*set<int>st;//means sorted and unique
st.insert(1);
st.insert(2);
st.insert(3);
st.insert(4);
st.insert(5);
auto it=st.find(3)//it will return the itrator means address where 3 is stored
st.erase(5)//it will erase 5 and then maintains the sorted order and if we write st.erase(it)//it will erase element at this iterator
st.count(1)//it will always result in 0 or 1  0 if no occurence and 1 fr sure 1 occurence
*to know if any element exists in the sorted rray or not then we use stl as bool r=binary_search(a,a+n,3)
where a=name of array and t will return if element exists in an array
*lower_bound will return the iterator to the first occurence of elememnt in an array if elemt found and if not found will return an iterator to the element which is just greater than the elememnt if we have an a[]={1,4,5,6,9,9}
int b=lower_bpund(a,a+n,4)-a//1
int c=lower_bpund(a,a+n,7)-a//4-point ata na element greater than 7 as 7 is not found so return 4
int d=lower_bpund(a,a+n,10)-a//6-as 10 does not exists will point at immediate greater of 10,whichALSO NOT exist  thus will point aat the beyond the last eleemnt thus in case of vector int =lower_bound(v.begin(),v.end(),4)-v.begin()
*upper_bound will always return an iterator to the element greater than the given element of its exists
a[]={1,4,5,6,9,9}
int b=lower_bpund(a,a+n,4)-a//2 as the element greater then the 4 is 5
int c=lower_bpund(a,a+n,7)-a//4 as elememnt greater then the 7 is 9
int d=lower_bpund(a,a+n,10)//6 as element greater than the 10 will lie outside
note:all binary search,lower bound,upperbound takes time as o(logn)
*ques:find the first occurence of an element in an sorted array.if it does not exist return -1;
a[]={1,4,4,4,4,9,9,10,11}
int ind=lower_bound(a,a+n,x)-a//
if(ind!=n && a[ind]==x)
{
cout<<ind;
}else
{
cout<<-1;
}
*ques :find the last ocurence of an element if itsv exists.if not exists return -1;
a[]={1,4,4,4,4,9,9,10,11}
int ind=upper_bound(a,a+n,x)-a//
ind--
if(ind>=0 && a[ind]==x)
{
cout<<ind;
}else
{
cout<<-1;
}
*ques:find the largest number smaller tahn x in ana array .if numvber does  not exist then return -1;
a[]={1,4,4,4,4,9,9,10,11}
int ind=lower_bound(a,a+n,x)-a//
ind--;
if(ind>=0 )
{
cout<<ind;
}else
{
cout<<-1;
}
*find the smallest number greater than x in an sorted array .if not exist return -1;
a[]={1,4,4,4,4,9,9,10,11}
int ind=upper_bound(a,a+n,x)-a//

if(ind<n )
{
cout<<ind;
}else
{
cout<<-1;
}
*note:everyhing in set takes time as logarithmic o(logn)
*multiset is used to maintain the sorted order not the unique order
multiset<int>m;
m.insert(1)//{1}
m.insert(1)//{1,1}
m.insert(1)//{1,1,1}
m.erase(1)//it will erase all 1
m.erase(m.find(1))//it will erase at the iterator as find will give iterator at first occurence of 1
*unordered set stores elemt in the unique order but randomized not sorted
here all the function are same as the vector and take times as 0(`1)but here upper_bound and lower_bound does not works
*map is the container where data are stored in key value pairs and the key is unique and in sorted order
map<int,int>mp;
mp[1]=2//means{1,2}//1 is key and 2 is the value
mp.emplace({3,1})//{3,1}where 3 is key and 1 is value
mp.insert({2,4})//{2,4}
|{1,2},{2,4},{3,1}                  |
|                  |
|__________________|
note:for iterating for(auto it:mpp)
{cout<<mpp.first<<mpp.second
}
or
cout<<mpp[1]
cout<<mpp[2]
or
auto it=mp.find(3)//here in the find we passed the key it will give iterator and cout<<(*it).second
*multimap here we can store the multiple key and they need not be unique but sorted
*unordered_map same as unordered_set
*now we learned all the containers and iterators now we will learn the algorithms
if we want to sort an array then the sort(a,a+n)//where a+n is the end out of array iterator and is not included
sort(v.begin(),v.end())
sort(a,a+n,greater<int>)//to sort in the descending order,here greater<int>is the inbuilt comparator which will automatically sort this in descending order
suppose pair<int,int>a[]={{1,2},{2,1},{4,1}}
now i want to sort according to second element and if in case second element are same the arrange according to first in descending order of first so here we have our own way of comparaing and will return our own comparator which will retirn true
sort(a,a+n,comp)
bool comp(pair<int,int>p1,pair<int,int>p2)
{
if(p1.second<p2.second{

return true;
}else
{
return false;
}
if(p1.second==p2.second{
if(p1.first>p2.first
{
return true
}

}
*suppose int num=7;//binary of 7 is111 as computer for int contains 32 bits 0000000000000000000000000111
int cnt=_builtin_popcuount()//will give number of setbits that is 3
------------------------------------------------------------------------------------------------------------------------------------------------------------java collections
 inside  collection framework ,collection  interface comes
*collection interface has children such as list,set,queue
*now for each of list,set,ques several classes are given whose objects are made and then we can iuse these interfaces list,set,queue
1.list interface is used when we want to store items in a contigous fashion
first class is arraylist
class arraylist{
public static void main(String args[])//or String [] args
{
//so the problem with array in java is that their size can be changed they are fixed but arraylist class uses array internally and its size can be increased and decreased

ArrayList<String>studentname=new ArrayList<String>();//this will create the empty array 
studentname.add("rakesh")//this will create an array of size 10 and rakesh is inserted in it and if its size is n and when we are inserting the next element then its size will increase by n+n/2+1,will copy all the element into new size array and will dump the previous array

List<Integer>l=new ArrayList<Integer>();
l.add(1);
l.add(2);//it will take o(n) internally
System.out.println(l)//[1,2]//when any object is passed to the sys out then to string method is always called
l.add(index:1,element:50)//this will insert 50 at the 1 index [1,50,2]
List<Integer>newlist=new ArrayList<Integer>();
newlist.add(3)
newlist.add(4)
l.addall(newlist)//this will copy newlist to l[1,50,2,3,4]
l.get(1)//will return 50 as its stored at the index 1
l.remove(1)//will remove elemet at index 1//will take o(n) internally 
l.remove(Integer.valueof(1))//here we pass the type of elemet which we want to remove
l.clear()//will remove whole list
l.set(1,60)//it will set the element at index 1 to 60 
l.contains(60)//will return true or false value as if contains or not 
now to iterate over list -----------------------
for(integer el:list)
{
sys(el);
}
Iterator<integer>it =l.iterator()//this func will return an iterator 
while(it.hasnext())
{
sys(it.next())//it will print element
}
*next class is the stack 
Stack<String>animals=new Stack<>();
animals.push("dog");
animals.peek()//dog







}
*next class is the linkedlist which is implemented using the list interface as well as queue interface
List<Integer>newlist=new ArrayList<Integer>();/and here function is same as the 

2.queue interface 
queue<integer>q=new linkedlist<>();
q.offer(12);//insert the specified element in queue and if task successfull returns true otherwise return false,q.add()//insert the specified element in queue and if task successfull returns true otherwise throw an exceptions

q.offer(13);
q.offer(14);
System.out.println(q.poll)//it will pop and also return the deleted front item 12

q.peek()//return the head of the queue and returns null if empty,q.element()//returns head of quueue and return exception if empty


second interface is the priority queue interface 
queue<integer>q=new priority_queue<>();
q.offer(14);
q.offer(13);
System.out.println(q)[13,14] as it implements the min heap
queue<integer>q=new priority_queue<>(Comparator.reverseorder());//thsi is to implemement the max jheap


now third class is the arraydeque which inserts element at front and at back

arraydeque<integer>dq=new arraydeque<integer>();
dq.offer(1);//will insert element at the last
dq.offerfirst(2);
dq.offerlast(3)//will insert element at the last {2,1,3}
System.out.println(dq.peekfirst())//2
System.out.println(dq.peek())//2
System.out.println(dq.peeklast())//3
System.out.println(dq.poll())//remove 2 and print 2
System.out.println(dq.polllast())//remove 3 


3.third interface is the set interface ,set has aproperty that here element can be duplicate it must be unique,
set<onteger>q=new hashset<integer>();
q.add(1);
q.add(2);
q.add(3);
System.out.println(q)//it will print in nay randomized order,order can be random
q.remove(2)//it will remove the elemet
q.cotains()
q.isempty()
q.size()
q.clear()
next class is the linkedhashset
set<onteger>q=new linkedhashset<integer>();//it will follow all [ropert of set bt also of linkedlist hence elemt will be inserted in an order
q.add(1);
q.add(2);
q.add(3);
System.out.println(q)//it will print in order,order in which they were inserted
q.remove(2)//it will remove the elemet
q.cotains()
q.isempty()
q.size()
q.clear()

3rd class is
set<onteger>q=new treeset<integer>();//it will contains all propert of set and along with it it also implement the binary search tree hence elememnt will be in sorted order
q.add(1);
q.add(2);
q.add(3);
System.out.println(q)//it will print in order,order is in sorted
q.remove(2)//it will remove the elemet
q.cotains()
q.isempty()
q.size()
q.clear()
note:make a new class as student class student
{
string name,int rollno;
public student(string name,int rollno)
{
this.anme=name,
this.rollno=rollno
}
public string tostring()//this comes from object class
{
return "studentname="+name
}
public boolean equals()//this comes from object cLASS
{
}
public int hashcode()//THIS ALSP comes from the object class
{
return Objcets.hash(rollno);
}
}
now we want that if there are 2 stydents there roll no cant be same ,so lets implement it using hashset
class learnset
{
public static void main(string args[])
{
set<student>s=new hashset<student>();
s.add(new student("neha",1);
s.add(new student("golu",2);
s.add(new student("lucky",4);
s.add(new student("man",1);
System.out.println(s)//this will then give the hashcode so to print unique objects with keys nd values we need ti implement to_stribg method
s.add(new student("neha",1);//it will again consider it to be uniqeu now we need to tell how we want them to be unique or different which we done by equals method where we want to differnetiate object on the basis of roll no and then it will generate hashcode on the basis of roll no,it means if the 2 objects with equal roll no then it will produec same hashcode 
public string tostring()//this comes from object class
{
return "studentname="+name
}
public boolean equals()//this comes from object cLASS
{
}
public int hashcode()//THIS ALSP comes from the object class
{
return Objcets.hash(rollno);
}

}

}
*4th interface is the map interface ,and here key value pairs work 
first class is the hashmap
map<string,integer>m=new hashmap<string,integer>();
m.put("one",1);
m.put("twpo",2);
m.put("three",3);
now here key must be unique ,not it will allow but it will override the last ,in the map element is inserted in throught entrysetm.entryset and within the map there is property entry through which we can iterate over the entryset
for(Map.entry<string,integer>e:m.entryset())
{System.out.println(e.getkey())
System.out.println(e.getkey())
}
here key will be in randomized order
2nd class is the treemap
map<string,integer>m=new treemap<string,integer>();//here key will be in sorted ordeer and then the then its value corresponding
then comes the array class which are applied on the normal array in java like int []number={1,2,3,4,5,6,7,8,9,10}
int index=Arrays.binary_search(number,key:4)//this arary class is also in the java.util package and there is a functions inside that binary_search
*Arrays.sort(number)
*next class is the collection class,here we will see the functions that can be applied on the collection framework
list<integer>list l=new arraylist<nteger>();
l.add(1);
l.add(2);
System.out.println(Collections.min(l))//this collections also comes from the java.util package
System.out.println(Collections.frequency(l,3)
------------------------------------------------------------------------------------------------------------------------------------------------basic maths concept
*digits extraction there comes while(n>0)
{                /10<-7789%10=9
lastdigit=n%10;   778.9 roundoff to 778 as integer |
cout<<lastdigit;
n=n/10
}
1.count of digits
int countDigits(int n){
	// Write your code here.	
	int count=0;
	while(n>0)
	{
		int last=n%10;
		n=n/10;
		count++;

	}
	return count;
}//first way here timw complexity will be how many time this while loop is running that is o(log10(n)+1)
now another way is int count=log10(n)+1
#include<bits/stdc++.h>
int countDigits(int n){
	// Write your code here.	
	int count=log10(n)+1;
	return count;
}
2.reverse a number 
then consider any int reverse=0;

reverse=reverse*10+lastdigit
int reverse(int x) {
         int answer = 0;

        while(x != 0){
            int digit = x % 10;
            if((answer > INT_MAX/10) || (answer < INT_MIN/10)){//this is to check reversed nu,mber does not goes beyond the [-231, 231 - 1]
                return 0;
            }

            answer = answer * 10 + digit;
            x = x / 10;
        }

        return answer;
    }
*check palindrome
palindrome number is that number whose reverse is equal to that number
note:after extraction of reverse of number that number will become 0 so we need to store that number initially to compare it at thw end
{
    // Write your code here
    int dup=n;
    int reverse=0;
    while(n>0)
    {
        int last=n%10;
        reverse=reverse*10+last;
        n=n/10;
    }
    if(reverse==dup)
    {
        return true;
    }else{
        return false;
    }
}
*armstrog numbers
conside 371 if we take each digit and take a cube of that digit and add and if its===371 than that number is called the armstrog number
bool checkArmstrong(int n){
	//Write your code here
	string l = to_string(n);

    int size = l.length();
	int dup=n;
	int sum=0;
	while(n>0)
	{
		int last=n%10;
		sum=sum+pow(last, size);;
		n=n/10;
	}
	if(sum==dup)
	{
		return true;
        } else {
                return false;
        }
}
note:using c++compiler
*print all divisors so basically whjat happens is that 36->divisors are those numbers between 1 and 36 which completely divides 36 and those numbers are 1,2,3,4,6,9,12,18,36
so first thing is that all the divisors lies between 1 to n,including 1 and n ,so we need to loop from 1 to n
for(int i=1;i<=n;i++)
{
if(n%i==o)
{cout<<i;
}
}
so time complexity will be o(n)
now 1*36=36
2*36/2=36
3*36/3=36
4*36/4=36
6*6=36
-------------//till here underrroot of n we can also get the all divisors
9*36/9=36
12*36/12=36
18*36/18=36
36*1=36

for(int i=1;i<=sqrt(n);i++)
{if(n%i===0)
{cout<<i;
if(i!==n/i)
{
cout<<n/i;//second factor 
}

}
}
//as we are not sure of the size so will use the data structure vector in c++ and the in java the list,and then sort it,here time complexity will be o(sqrt n)+o(n*log(n))+o(n) where n is the no of factors
*int sumOfAllDivisors(int n){
	
	// Write your code here.
	 int sum = 0;

        for(int i = 1; i <= n; i++) {

            sum += i * (n / i);

        }

        

        return sum;
	
}sum of all divisors
*prime nubers are those which has 2 factor 1 and the number itself,ex 13,17 but 1 is nt prime number bcz its does not have the 2 factors bool isPrime(int n)
{
	// Write your code here.
	int cnt=0;
	for(int i=1;i*i<=n;i++)
	{
		if(n%i==0)
		{
			cnt++;
			if(i!=n/i)
			{
				cnt++;
			}
		}
	}
	if(cnt==2)
	{
		return true;

	}else
	{
		return false;
	}
}
 a
*gcd of 9,12 now factors of 9 is 1,3,9 and 12 is 1,2,3,4,6,12 and common is 1,3 and among them 3 os highest so 3 is the highest common divisor that divides 9 and 12 both
gcd will be 1  a;lways for 2 numbers
for(int i=1;i<=min(n1,n2);i++)
{
if(n1%i==0 && n2 %i==0)
{
gcd=i;
}

}
now time complexity will be o(min(n1,n2))
but there is euclidean algorithm which says that gcd(a,b)=gcd(a-b,b)where a>b
ex-gcd(20,15)=gcd(5,15)=gcd(10,5)=gcd(5,5)=gcd(0,5) the moment anyone become 0 anothers one is gcd that is 5 
int calcGCD(int n, int m){
    // Write your code here.
    while(n>0 && m>0)
    {
        if(n>m)
        {
            n=n%m;
        }else
        {
            m=m%n;
        }
    }
    if(n==0)
    {
        return m;
    }
    else{
        return n;
    }
}
as it talkes modulus meand divison and divison in while takes o(log(min,(m,n)))
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
recursion
is basically calling itself again and again suppose f()
{
print(1)
f()//here its calling itself again and agin and till infinite times 1 is printed
}
now there is no base condition to it 
f()
{
i(cnt==4)
{
return;//here it is returni g soethmg to the function and f()need no to wat
}
else
{
cnt++;
f()//here origonal f() needs to wait
}
}
basic problems of recursion
*print name n times using recursion int main()
{
int n;
cin>>n;
f(1,n)///this is we are taking  the variable which will iterate till n and corresponding to that iteration the name is printed
}
f(i,n)
{
if(i>n)
{
return;
}
print("neha");
f(i+1,n);//here we are increasing the iterator
}
f(1,3)
/f(2,3)/
/f(3,3)/
/f(4,3)/base condition meet
here time complexity will be o(n)aas we are calling n functions
here space complexity will also be in o(n)as we are using stack space for n funcyions waiting to be completed
*print lineraly from 1 to n 
{
int n;
cin>>n;
f(1,n)///this is we are taking  the variable which will iterate till n and corresponding to that iteration the name is printed
}
f(i,n)
{
if(i>n)
{
return;
}
print(i);
f(i+1,n);//here we are increasing the iterator
}
*print from n to 1 by using recusrsion
{
int n;
cin>>n;
f(n,n)///this is we are taking  the variable which will iterate till n and corresponding to that iteration the name is printed
}
f(i,n)
{
if(i<1)
{
return;
}
print(i);
f(n-1,n);//here we are increasing the iterator
}
*print from 1 to n but using backtracking means does not use call f(i+1,n) used as iterator instead use the backtracking ,in backtracking we are printing anything after recursion call and each recursion leads to the base condition and then backtrack everything 
{
int n;
cin>>n;
f(n,n)///
}
f(i,n)
{
if(i<1)
{
return;
}

f(n-1,n);->f(2,3)->f(1,3)->f(0,3)->base condition meet eturn to f(1,3) print 1 and then back and print 2 and the last print 3//this is backtracking 
print(i);
}
*print fron n to 1 using backtracking #include <iostream>
using namespace std;

void printNumbersBackwards(int i, int n) {
    // Base case: if i is greater than n, return
    if (i > n) {
        return;
    }

    // Make a recursive call with i+1 and n
    printNumbersBackwards(i + 1, n);

    // Print the current value of i
    cout << i << " ";
}

int main() {
    int n;

    // Input the value of n
    cout << "Enter the value of n: ";
    cin >> n;

    // Call the function to print numbers from n to 1
    printNumbersBackwards(1, n);

    return 0;
}
*You are given an integer ‘n’.



Print “Coding Ninjas ” ‘n’ times, without using a loop.
vector<string> printNTimes(int n) {
	if(n==0){

        vector<string> name;

        return name;

    }

    vector<string> name =printNTimes(n-1);

    name.push_back("Coding Ninjas");

    return name;
	

}used backtracking as think we need to first print 1 for that i-1 is needed and for that remind base condition
*
You are given an integer ‘n’.



Your task is to return an array containing integers from 1 to ‘n’ (in increasing order) without using loops.
vector<int> printNos(int x) {
    // Write Your Code Here
    
    
    if(x<1)
    {vector<int>name;
        
        return name;
    }
    vector<int> name =printNos(x-1);

    name.push_back(x);

    return name;

    

}
*now to print from n to 1 using backtracking is not possible vector<int> printNos(int x) {
    // Write Your Code Here


    // Write Your Code Here

    if(x==0)

    {

        vector<int> v;

        return v;

    }

   static vector<int> v;

    v.push_back(x);

    printNos(x-1);

    return v;

    


}
*sum of first n numbers using the recursion 
1st way is parameterized here we are printing  int main()
{
int n;
cin>>n;
f(n,0)///
}
f(i,n)
{
if(i<1)
{
print sum
return;
}
f(i-1,sum+i);
}//here we took minus as its more conveninent and we need to passs extra parameter while cALLING THE FUNCTION
2nd way is funcyional where we are returning the something from function we kne f(n)=n+f(n-1)
and f(0)==0
{
int n;
cin>>n;
f(n)///
}
f(i)
{
if(i==0)
{
return 0;
}
return n+f(n-1);
}
*ou are given an integer ‘n’.



Your task is determining the sum of the first ‘n’ natural numbers and returning it.
long long sumFirstN(long long n) {
    // Write your code here.
    if(n==0)
    {
        return 0;
    }
     if(n==1){

            return 1;

        }
    return sumFirstN(n-1)+n;
}
or return n*n+1/2
*factorial of a number n {
int n;
cin>>n;
f(n)///
}
f(i)
{
if(i==0)
{
return 1;
}
return n*f(n-1);
}
here also time and space complexity will be o(n) and space will be o(n)
*You are given an integer ’n’.



Your task is to return a sorted array (in increasing order) containing all the factorial numbers which are less than or equal to ‘n’.



The factorial number is a factorial of a positive integer, like 24 is a factorial number, as it is a factorial of 4.
long long factorial(long long n){

if(n<=1) return 1;

else return n*factorial(n-1);

}

vector<long long> factorialNumbers(long long n) {
    // Write Your Code Here
     vector<long long> v;

    for(int i=1;i<=n;i++){

        long long  fact=factorial(i);

        if(fact<=n)  v.emplace_back(fact);

        else return v;

    }
}
*reverse an array using recursion
so basic intution is take 2 ponter 1 st 0 index and another at last index while(first<last)
{
swap(a[fisrt],a[last]);
first++;
last--
}
now recusrion using 2 pointer will be {
int n;
cin>>n;
f(0,n-1)///
}
f(i,n)
{
if(n>=i)
{
return ;
}
swap(a[i],a[r]);
f(i+1,r-1)
}
now doing this using single poineter
{
int n;
cin>>n;
f(0)///
}
f(i)
{
if(i>=n/2)
{
return ;
}
swap(a[i],a[n-i-1]);
f(i+1)
}
*Given an array 'arr' of size 'n'.



Return an array with all the elements placed in reverse order.
void revarr(int i,int n,vector<int>&v){

   

       

           if(i>=n/2)     return ;                        //base condition

      

         else      swap(v[i],v[n-i-1]);

 

// Call function recursively

    revarr(i+1, n,v);

}
vector<int> reverseArray(int n, vector<int> &nums)
{
    // Write your code here.
    revarr(0,n,nums);

   return nums;

}
*to check if string is palindrome or not a string is [palindrome if its reverse is euqal to number,here instead of reversal check by index
{
int n;
cin>>n;
bool func(int i,string & str)
{
    if(i>=str.size()/2)
    {
        return true;
    }
    if(str[i]!=str[str.size()-i-1])
    {
        return false;
    }
    return func(i+1,str);
}
bool isPalindrome(string& str) {
    // Write your code here.
    bool  b=func(0,str);
    return b;
}
*You are given a string 'S'. Your task is to check whether the string is palindrome or not. For checking palindrome, consider alphabets and numbers only and ignore the symbols and whitespaces.

Note :

String 'S' is NOT case sensitive.
bool checkPalindrome(string s)
{
     int i = 0;

    int j = s.size() - 1;

 

    while (i <= j) {

        if (!(isalnum(s[i])))

        {

            i++;

        }

         

        else if (!(isalnum(s[j])))

          {

            j--;

        } 

        else if (tolower(s[i]) == tolower(s[j])) 

        {

            i++;

            j--;

           

        } 

        else 

        {

            return false;

        }

    }

 

    return true;
}
*
multiple recursion call mean in function f()
{
f()
f()
}//call to itself but many time in its own function 
fibonacci number are 0,1,1,2 //means sum of its last 2 elements ,so 0th fibonacci number is 0,1st fibonacci number is 1 and 2 nd is 2 so we will be asked which is the nth fibonacci number so f(3)=2
so basically f(n)=f(n-1)+f(n-2)so basically f(n-1) willl be completeed returned amd then f(n-2) will occur
 {
int n;
cin>>n;
f(n)///
}
f(n)
{
if(n<=1)
{
return n ;
}
return f(n-1)+f(n-2)
}
*
------------------------------------------------------------------------------------------------------------------------------------------------------------hashing
*hashing is precomputing and fetching now if we are asked a frequencu of elemet then we need t  create a new array of size n+1 where n is the max element and index is 0 to n where n is the max element and hash[arr[i]]++;
*in the main u can onlt create an array of size 10^6 but if you want to calculate the freqiency for the tsring for that hash[arr[i]-'a']++;
*note that for lowecase you need to creat array of size 26 means indexing from 0 to 25
int main()
{
string s;
cin>>s;
int hash[26]={0};
for(i t i=0;i<26;i++)
{
hash[s[i]-'a']++;
}
while(q--)
{
cin>>char;
cout<<hash[char-'a'];
}//for lowecase 


int main()
{
string s;
cin>>s;
int hash[256]={0};
for(int i=0;i<256;i++)
{
hash[s[i]]++;
}
while(q--)
{
cin>>char;
cout<<hash[char];
}


}for all the character
*note that number hashing can create poble as the number can reach beyong 10^9 but characters cant be 
*as the number hashing can be done with array as array size cant go beyond 10^6 inside the main,so to solve it there comes  th stl in c++ ,map nad the unoerdered_map
*we have arr[]={1,2,3,1,3,2,12 } here map<key,va;ue>where key is the number and the value is the frequency ,here the thing is that it check mpp[1] as mpp[1] is 0 it will do mpp[1]++;hence it will store 4 element only instaed array stored the 13 element;
int arr[6]={1,2,3,1,3,2,12}
map<int,int>mp
for(int i=0;i<6;i++)
{
mp[arr[i]]++;
}
cin>>number;
cout<<mp[number]<<"frequemcy";
for(auto it:mp)
{
cout<<it.first;//note that map store the value->numbetr,element of an array always in sorted order 
}
*note that inserting nad fetching of element from map takes the logarithmic time in any case let it worst ,best or average case
*but if we use unordered_map here key that is value of elememt of array will not be in sorted order and best thing about this is it takes o(1) time for inserting and fetching in best and vaerage case  but in worst case it takes the o(n) times and worst case happens when there is collision i divisoon method 
*note that in map the key can be any data structure but the in unordered_map key cant be any data structure it cna only be primitive type
*problem statement
You are given an array 'arr' of length 'n' containing integers within the range '1' to 'x'.



Your task is to count the frequency of all elements from 1 to n.
#include<bits/stdc++.h>

using namespace std;
vector<int> countFrequency(int n, int x, vector<int> &nums){
    // Write your code here.
    map<int,int>mpp;
    for(int i=0;i<n;i++)
    {
        mpp[nums[i]]++;
    }
    vector<int>ret;
    for(int i=1;i<=n;i++)
    {
ret.push_back(mpp[i]);
    }
    return ret;
}
or
#include<bits/stdc++.h>

using namespace std;
vector<int> countFrequency(int n, int x, vector<int> &nums){
    // Write your code here.
      vector<int> hash(n);
    for(int i=0;i<n;i++)
    {
        hash[nums[i]]++;
    }
    vector<int>ret;
    for(int i=1;i<=n;i++)
    {
ret.push_back(hash[i]);
    }
    return ret;
}//using the number hashing 
*ques:Problem statement
Given an array 'v' of 'n' numbers.



Your task is to find and return the highest and lowest frequency elements.


If there are multiple elements that have the highest frequency or lowest frequency, pick the smallest element.

vector<int> getFrequencies(vector<int>& v) {
    // Write Your Code Here
     int n= v.size();
    int maxi = INT_MIN,mini = INT_MAX;
    int maxFirst,minFirst;
    vector<int> ans;
    map<int,int> mp;
    for(int i=0;i<n;i++)
    {
        mp[v[i]]++;
    }
    
    
   for(auto it:mp){
        if (it.second > maxi) {
          maxi = it.second;
          maxFirst = it.first;
        }
        if(it.second<mini){
            mini = it.second;
            minFirst = it.first;
        }
   }
    ans.push_back(maxFirst);
    ans.push_back(minFirst);
    return ans;


}

Note:if you want to rint the element nd freueney n the order the elemenst is pesent in the array then take any vector and while storing the aelemeny in map make chck if(mpp.find(arr[i])==mpp.end() tore in some vector to store the unique elements and then the  iterate over the array and find th frequency correspeding to vector rlemenst


------------------------------------------------------------------------------------------------------------------------------------------------------------
selection sort
*int arr[]={13,46,24,52,20,9}
selection sort means minimum find minimum that is 9 and put it at first and first element at the minimum element pos menas swap,so find minimum and then swap.
*{9,46,24,52,20,13}henc e after minimum swap first position is sorted now fnd the minimum right to first position 
that is 13 and thyen swap with 2 nd positions
*{9,13,24,52,20,46}now look for minimum right to 13 and that is 20 and then swap with 3rd pos
*{9,13,20,52,24,46}
*{9,13,20,24,52,46}

*{9,13,20,24,46,52}




observation is iterate from 0 to n-1 and find minimum tgen swap(a[mini],a[0])
observation is iterate from 1 to n-1 and find minimum tgen swap(a[mini],a[1])
observation is iterate from 2 to n-1 and find minimum tgen swap(a[mini],a[2])
observation is iterate from n-2 to n-1 and find minimum tgen swap(a[mini],a[n-2])

#include<bits/stdc++.h>
int main()
{
cin>>n;
int arr[n];
for(int i=0;i<n;i++)
{
cin>>arr[i];
}
selection_sort(arr,n);
}
}
void selection_sort(int arr[],int n)
{
for(int i=0;i<=n-2;i++)
{
mini=i;
for(int j=i;j<n;j++)
{
if(arr[j]<arr[mini])
{
mini=j;
}
}
swap(arr[i],arr[mini]);

}
};
and its coding ninjas code is #include<bits/stdc++.h>

int main() {
    // Write C++ code here
    std::cout << "Welcome to Code 360 Online Compiler!!";
    
    
    int arr[5]={6,5,7,2,4};
    for(int i=0;i<=3;i++){
        int mini=i;
        for(int j=i;j<=4;j++){
            if(arr[mini]>arr[j]){
                mini=j;
            }
            swap(arr[i],arr[mini]);

        }
    }
    for(int i=0;i<5;i++){
        cout<<arr[i];

    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------
time complexity will be for outerloop index is 0 inner loop runs for n and for second turns runs n-1 times hence the toatl=n/2(2*1+(n-1) that is n2 and it is its worst,average and best
*bubble sort key is find max ,push max to last by adajacent swaps
int arr[]={13,46,24,52,20,9}
1 st round
13,46 sorted
46,24 not sorted 24,46
46,52 sorted and like this one round will put max element at last
thus first loop goes from 0 to n-1//for one round of adjacent swaps and ,max at arr[n-1]
second goes from 0 to n-2
third goes from 0 to n-3
last goes from 0 to 1
for(inyt i=n-1;i>=1;i--)
{
for(int j=0;j<=i;j++)//for this at arr[n-1] comapred with one mre than this will give runtime errors make no sense ,so use j<=i-1
{
if(arr[j]>arr[j+1])//for this 
{
swap(arr[j],arr[j+1]);
}
}

int main()
{
cin>>n;
int arr[n];
for(int i=0;i<n;i++)
{
cin>>arr[i];
}
bubble_sort(arr,n);
}
}
void bubble_sort(int arr[],int n)
{
for(int i=n-1;i>=1;i--)
{

for(int j=0;j=<i-1;j++)
{
if(arr[j]>arr[j+1])
{
swap(arr[j],arr[j+1]);
}
}


}

}

}
now here also worst and average case  time complexity will be o(n^2) but best time complexity will be o(n) as there might be in one inner loop no swap and if no swap break from the outerloop also 
int main()
{
cin>>n;
int arr[n];
for(int i=0;i<n;i++)
{
cin>>arr[i];
}
bubble_sort(arr,n);
}
}
void bubble_sort(int arr[],int n)
{
for(int i=n-1;i>=1;i--)
{
int didswap=1;

for(int j=0;j=<i-1;j++)
{
if(arr[j]>arr[j+1])
{
swap(arr[j],arr[j+1]);
didswap=0;
}
}
if(didswap==1)
{
break;//hence no need to run next iteration
}


}

}

}//this is the best case for bubble sort

code from oding ninjas is #include<bits/stdc++.h>

int main() {
    // Write C++ code here
    std::cout << "Welcome to Code 360 Online Compiler!!";
    
    
    int arr[5]={6,5,7,2,4};
    for(int i=4;i>=1;i--){
        
        for(int j=0;j<=i-1;j++){
            if(arr[j]>arr[j+1]){
                swap(arr[j],arr[j+1]);
            }
           

        }
    }
    for(int i=0;i<5;i++){
        cout<<arr[i];

    }
}






------------------------------------------------------------------------------------------------------------------------------------------------------------
*insertion sort  mains strategy is pick the element and put at its correct order 
int arr[]={14,9,15,12,6,8,13}
now 14 is alraedy sorted
14,9 not sorted thus 9,14 is 
9,14,15 also sorted
9,14,15,12 not sorted sor swa
p to left 12,15 swap,12,14 
9,12,14,15,6 not sorted
for(int i=0;i<n;i++)
{
int j=i;
while(j>0 && arr[j-1]>arr[j])
{
swap(arr[j],arr[j-1]);
j--;
}
}
now worst time and the average time complexity will be o(n^2) but best will be if the rray is sorted than no swap hence no entrance to while loop and hence o(n)
*#include<bits/stdc++.h>


using namespace std;

void insertionSort(int arr[], int n)
{int j;
    //write your code here
    for(int i=0;i<n;i++)
    {
        j=i;
        while(j>0 && arr[j-1]>arr[j])
        {
            swap(arr[j],arr[j-1]);
            j--;
        }
    }
}
code using coding ni jas
#include <iostream>
using namespace std;
#include<bits/stdc++.h>

int main() {
    // Write C++ code here
    std::cout << "Welcome to Code 360 Online Compiler!!";
    
    int j;
    int arr[5]={6,5,7,2,4};
    for(int i=0;i<=4;i++){
         j=i;
        
       while(j>0&&arr[j-1]>arr[j]){
           swap(arr[j],arr[j-1]);
           j--;
       }
    }
    for(int i=0;i<5;i++){
        cout<<arr[i];

    }
}




------------------------------------------------------------------------------------------------------------------------------------------------------------
note :always use the #include<bits/stdc++.h>


using namespace std;
*
merge sort


int arr[]={3,1,2,4,1,5,2,6,4}
merge sort means divide so there are 2 ways to divide this 9 element arr either 4,5 or 5,4 so consider as 5,4 sor
[3,1,2,4,1] and [5,2,6,4]
now again divide left most array again didvided to [3,1,2] and [4,1]
now agin didvided to [3,1] and [2]
again divided to [3],[1], now it cant be further didvided so now merge these 2 array,whixh re also sorted but resulting array must be sorted .
*so not instaed of breakoing this array and then merging lets divide them inti 2 parst then sorted then merge it 
so mid=low+high/2;
first array divide again and again so mergesort(arr,low,mid)
mergesort(arr,mid+1,high);
then merge(arr,low,mid,high)
here base condition is if(high=low)
{
return;}
and merge(int arr[],int low,int mid,int high)
{
int low=low;
int right=mid+1;
while(low<=mid and and right<=high)
{
if(arr[low]<arr[rih])
{
temp.push_back(arr[low]);
l++;
}
else
{
temp.push_back(arr[right]);
right++;

}
}
while(low<=mid)
{
temp.push_back(arr[low]);
l++;
}
while(right<=high)
{
temp.push_back(arr[right]);
right++;
}
for(innt i=low;i<=hihj;i++)
{
arr[i]=temp[i-low];
}
#include<bits/stdc++.h>


using namespace std;
void merge(vector<int> &arr, int l,int mid, int r)
{
    vector<int>temp;
    int left=l;
    int right=mid+1;
    while(left<=mid && right<=r)
    {
        if(arr[left]<=arr[right])
        {
            temp.push_back(arr[left]);
            left++;

        }else{
            temp.push_back(arr[right]);
            right++;

        }
    }
    while(left<=mid)
    {
         temp.push_back(arr[left]);
            left++;

    }
     while(right<=r)
    {
         temp.push_back(arr[right]);
            right++;

    }
    for(int i=l;i<=r;i++)
    {
        arr[i]=temp[i - l];;
    }

}
void mergeSort(vector<int> &arr, int l, int r) {
    if(l>=r)
    {
        return;
    }
    int mid=(l+r)/2;
    mergeSort(arr,l,mid);
     mergeSort(arr,mid+1,r);
     merge(arr,l,mid,r);

    // Write Your Code Here
    
}here timecomplexity is o(nlogn)
* #include<bits/stdc++.h>
void bubbleSort(vector<int>& arr, int n) 
{
    //write your code here
    if(n==1)
    {
        return;
    }
    for(int i=0;i<=n-2;i++)
    {
        if(arr[i]>arr[i+1])
        {
            swap(arr[i],arr[i+1]);
        }
    }
    bubbleSort(arr, n-1);
   
}recursive bubbble sort
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*quick sort is used as it tkes time complexity as o(nlogn) and space complexity as o(1) mesns it does not store the temporarary araay
int arr[]={4,6,2,5,7,9,1,3}
*pick up pivot and put it at the correct plae in an sorted array and then all smaller to leftand all greater to right
pick up the pivot element and place it in sorted array so pick up 4 and place it in its correct pos in sorted rray and hence array will be at the 4 th pos and all the samllef to left amd greater to right hence{2,1,3,4,6,5,7,9}
*then same then for the left half arrayof 4 and right half
*so take 2 pointers int i=0;int j=n-1;
*and piot =arr[i];
*now to maek the pivot to be stored at the correct pos u need to make the territory of the sorted array such all toward left are samller nd lal toward right is greater
*and to make that iterate over i and j 
*find first from left which is greater than the pivot and left which is smaller and swap
*and stop as as soon as i>j
*then swap the arr[j] and arr[pivot]
*now we can see the artion =where the pivot was placed initially
*bow we need to sort the array from left to arr[part-1] and arr[p+1]  high
*
--------lass Solution {	
  public:
    // Function to sort an array using quick sort algorithm.
    void quickSort(vector<int>& arr, int low, int high) {
        // code here
        if(low>=high)
        {
            return;
        }
        int part=partition(arr,low,high);
        quickSort(arr,low,part-1);
         quickSort(arr,part+1,high);
        
        
    }

  public:
    // Function that takes last element as pivot, places the pivot element at
    // its correct position in sorted array, and places all smaller elements
    // to left of pivot and all greater elements to right of pivot.
    int partition(vector<int>& arr, int low, int high) {
        int pivot=arr[high];
        int i=low;
        int j=high;
        while(i<j)
        {
            while(pivot>=arr[i]&&i<=j)
            {
                i++;
            }
            while(pivot<=arr[j]&&j>=i)
            {
                j--;
            }
            if(i<j)
            {
                std::swap(arr[i]),arr[j];
            }
        }
        std::swap(arr[pivot],arr[j]);
        return j;
        // code here
    }
};
----------------------------------------------------------------------------------------------------------------------------------------------------
BASICS OF ARRAY
an array is a data structure which conatins elements but that elemet type must be same measn if they are inetegrs then all must be integers maeans similar element array
*in int main it is declared as int arr[6] and in java int arr[]=new int [6] and if declared inside the int main then the in all 6 places garbage value will be assigned.and ig declared outside main globally then the all 6 value must be filled with 0
*and in memory a chunk of 6 memory allocation will be there where 0 th index elemet iwll be stored at random
 address and if know that address we can predict the address of the next element storage.
*larhgest element in an array int arr[]={3,2,1,5,2}
now the brute force solution will be to sort this array and arr[n-1] will be the largest and the time complexity if we use the merge sort and quick sort will be o(nlogn) 
*now int largest=arr[0]//as we knw one the elmemnt will laways the largest element so for(int i=1;i<n;i++)
{
if(largest<arr[i])
{
largest=arr[i];
}
}
return arr[i];
}
*second largest element in an array int arr[]={1,2,4,7,7,5}
so brute force will be sort this then arr[]={1,2,4,5,7,7} hence the largest =arr[n-1] and secondlargest cant be arr[n-2] so we need to iterate from n-2 to 0 and see if elemmet is not qual to largest will be seconf largest
for(int i=n-2;i>=0;i--)
{
if(largest!=arr[i])
{
secondlargest=arr[i];
break;
}
} so time complexity will be  o(nlogn) for sorting the rray and o(n) for worst case of finding secondlargest elememnt


    }
 int largest=a[0];
    int sl=-1;
    for(int i=1;i<n;i++)
    {
        if(largest<a[i])
        {
            sl=largest;
            largest=a[i];
        }else if(largest>a[i]&&a[i]>sl)
        {
            sl=a[i];
        }
    }//this is the optimized code
------------------------------------------------------------------------------------------------------------------------------------------------------------
check if the array is sorted
for(int i=1;i<n;i++)
{
if(arr[i-1]<=arr[i])
{
}else
{
return false;
}
return tre;


---------------------------------------------------------------------------------------------------------------------------------------------------------------------
check if te array is rotated and sorted
*int arr[]={3,4,5,1,2}


array is sorted as arr[i]>arr[i+1] and but the will be exaclt and exactlyoe point such that arr[i]<arr[i-1]
*so ta cntand mark it when arr[i]<arr[i-1]
*and another condition is check that arr[n-1]<arr[0] if should be true no cnt increase and false if cnt++ 
*cnt<=1 return class Solution {
public:
    bool check(vector<int>& nums) {
       int n=nums.size();
        int cnt=0;
        for(int i=1;i<n;i++){
            if(nums[i-1]>nums[i]){
                cnt++;
            }
        }
        if(nums[n-1]>nums[0]){
            cnt++;
        }
        return cnt<=1;
    }
};


*here question is that why cnt increase  whn n-1>0
------------------------------------------------------------------------------------------------------------------------------------------------------------
s
*remove duplicates in place from sorted array
int arr[]={1,1,2,2,2,3,3}
means modigy this array such a way that all unique elements are placed at its starting nad then return the number of unique elements
set<int?st;
for(int i=0;i<n;i++)
{
st.insert(arr[i];//all unique elements will be be stored here
}
index=0;
for(auto it:st)
{
arr[index]=it;
index++;
}
return index;
now time complexity will be as insert in set takes place around logn() and hence n for for lopp hence nlogn+n->for second loop
now to do this in 0(n) we will use 2 pointer approach first take i=0;
and j=1;
iterate over j and find if(arr[i]!=arr[j]);
the {arr[i+1]=arr[j];
i++;
j++;
}else
{
j++;
}

int i=0;
    for(int j=1;j<n;j++)
    {
        if(arr[i]!=arr[j])
        {
            arr[i+1]=arr[j];
            i++;
        }
    }
    return i+1;
------------------------------------------------------------------------------------------------------------------------------------------------------------
*left roate the array in one place
 int temp=arr[0];

    for(int i=1;i<n;i++)
    {
        arr[i-1]=arr[i];
    }
    arr[n-1]=temp;
    return arr;
------------------------------------------------------------------------------------------------------------------------------------------------------------
*left rotate the array by d places
int arr[]={1,2,3,4,5,6,7}
 here we rotate it by the 7 places then resulting array will be the this array again
and if we want to rotate it by the 8 it means we need to  rotate it by 1 places as 8%7==1 this means we need to do d%n where n is  the size of an array
lets left rotate it by 3 places then the 
now first store the temp[]={1,2,3}
for(int i=d;i<n;i++)//now shifting 
{
arr[i-d]=arr[i];
}
int j=0;
now where to put so for(int i=n-d;i<n;i++)
{
arr[i]=temp[j]//or tem[i-(n-d)]
j++;
}

code coorect vector<int> rotateArray(vector<int>arr, int k) {
    // Write your code here.
    vector<int>temp;
    for(int i=0;i<k;i++)
    {
        temp.push_back(arr[i]);
    }
    for(int i=k;i<arr.size();i++)
    {
        arr[i-k]=arr[i];
    }
    for(int i=arr.size()-k;i<arr.size();i++)
    {
arr[i]=temp[i-(arr.size()-k)];
    }
    return arr;
}
***till here
------------------------------------------------------------------------------------------------------------------------------------------------------------
move zero to end
*1.Brute Force will be simple Remove all zeroes and count them. Then push 0 at the back of zeroes total count.
*two pointer will like starting two pointers  left right at the same point and then right pointer moves till it finds number other then 0 (like 1,2,3,4..) then swap it with 0
* int n = nums.size();
        int left = 0;

        for(int right=0;right<n;right++){
            if(nums[right] != 0){
                swap(nums[right],nums[left]);
                left++;
            }
        }
-----------------------------------------------------------------------------------------------------------------------------------------------------------
union of 2 sorted array
int arr1[]={1,1,2,3,4,5}it can have duplicate
int arr2[]={2,3,4,4,5}it can have duplicates
union in sorted order means first store all unique from arr1 and then iterate over the 2nd array and if any elemey in arr2 is found in temp dont add them and if not found then add ->means union will contain all the unique elemnts
*brute force Note:will be  as we wanted unique and then the ordered then that means we can use the set
set<int>st;
for(int i=0;i<arr1.size();i++)
{
st.insert(arr1[i];->it will take o(n1*logn1)time,n1-arr1 size
}
for(int i=0;i<arr2.size();i++)
{
st.insert(arr2[i];it will take o(n2*logn)time,n2-arr2 size


}
vector<int>temp(st.size());
for(auto it:st)
{temp.push_back(st);

}
time complexity will be o(n1logn1)+o(n2logn2)+o(n1+n2) as if both contains the uniquw element



optimal take 2 pointer 1 pointing to arr1 and other to arr2
int i=0;
int j=0;
vector<int>union;
while(i<n1 && j<n2)
{
if(arr1[i]<=arr2[j])
{
if(union.size()==0 || union.back()!=arr1[i]])
{
union.push_back(arr1[i]);
i++;
}else
{
if(union.size()==0 ||union.back()!=arr22[j]])
{
union.push_back(arr2[j]);
j++;
}
while(i<n1)
{if(union.back()!=arr1[i]])
{
union.push_back(arr1[i]);
i++;
}
}
while(j<n2)
{if(union.back()!=arr2[j]])
{
union.push_back(arr2[j]);
j++;
}
}



code correct 
vector < int > sortedArray(vector < int > a, vector < int > b) {
    // Write your code here
    int i=0;
    int j=0;
    int n1=a.size();
    int n2=b.size();
    vector<int>unionarr;
    while(i<n1 && j<n2)
    {
        if(a[i]<=b[j])->first considering the sorted order
        {
            if(unionarr.size()==0|| unionarr.back()!=a[i])
            {
                unionarr.push_back(a[i]);
                
            }
            i++;//if noy then increase i;        

        }else{
            if(unionarr.size()==0|| unionarr.back()!=b[j])
            {
                unionarr.push_back(b[j]);
                
            }
            j++;

        }
    }
    while(i<n1)
    {
        if(unionarr.size()==0|| unionarr.back()!=a[i])
            {
                unionarr.push_back(a[i]);
               
            }
             i++;

    }
    while(j<n2)
    {
         if(unionarr.size()==0|| unionarr.back()!=b[j])
            {
                unionarr.push_back(b[j]);
               
            }
             j++;

    }
    return unionarr;
}
*



}
return union;
tillll this Complexity: O(n1 + n2)
------------------------------------------------------------------------------------------------------------------------------------------------------------
find the missing element in ana array
we will be given n=5 
int arr[]={1,2,4,5}->this array wil contains n-1 numbers and these numbers are from 1 to n
note:we have to find the number between 1 to n which is not there in in the array
so 3 is the number
 so the brute force will be for(int i=1;i<=n;i++)
{
flag=0;
for(int j=0;j<n-1;j++)
{
if(arr[j]==i)
{

flag=1;
break;
}
}
if(flag==0)
{
return i;
}
}
so the time complexity will be o(n*n)


we can also do it using hashing as hash(n+1)={0};
for(int i=0;i<n-1;i++)
{
hash[i]++;
}
for(int i=1;i<=n;i++)
{
if(hash[i]==0)
{
return i;
}
}


so time complexity will be 0(2*n) but i want to reduce space complexity 
Note:using ash array uses th 0(1) for th assigning whre as the ordered map usues theUsing map<int, int>:
Balanced BST (Red-Black Tree)

Insert/find: O(log n)
✅ Total: O(n log n)

optimal

int sum1=n*(n+1)/2;//from 1 to n sum comes from n/2+(2*a+(n-1)*d)
int sum2=0;
for(int i=0;i<n-1;i++)
{
sum2=sum2+arr[i];//sum of all elements in an array
}
return sum1-sum2;
so time complexity will be o(n) and space  will be 0(1)




more ptimal can be by using xor 
a^a=0
0^a=a

now we will take xor1=1^2^3...N;
xor2=all arr[i] element 
return xor1^xor2 but it wi;ll take o(2*n)
for(int i=0;i<=n-1;i++)
{
xor2=xor^arr[i];
xor1=xor1^(i+1)
}
xor1=xor1*n;
return xor1^xor2



now the xor technique is good as sum techniq sum1=n*n+!/2 if n=10^5 then sum1 will be 10^10 and we then need to take long hence more menory but xor never excced the limits

*here remember that when we are using the map and finding the correct number iterate till when required
*ad in xor as Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array. then int xor2=0;
       for(int i=0;i<nums.size();i++)
       {
        xor1=xor1^nums[i];
        xor2=xor2^i;
        
        }
        xor2=xor2^nums.size();
        return xor1^xor2;

 
------------------------------------------------------------------------------------------------------------------------------------------------------------
maximum no of consecutive ones
*int arr[]={1,1,0,1,1,1,0,1,1}
here the first count must be of consecutive and second count must be of maximum
int cons=0;
int max=0;
for(int i=0;i<n;i++)
{
if(arr[i]==1)
{
cons++;
max=max(max,cons)

}else
{
cons=0;
}
}
return max;
------------------------------------------------------------------------------------------------------------------------------------------------------------
find the numbers that appears once and the numbers that appears twice
*int arr[]={1,1,2,3,3,4,4}
we have an array where all the numbers appear twice but there is one number that appears once find that number
for(int i=0;i<n;i++)
{
int cnt=1;
for(int j=i+1;j<n;j++)
{
if(arr[j]==arr[i])
{
cnt++;
}
}
if(cnt==)
{
return nums[i];
}
}
time complexity will be o(n*n)




better solution can be hashing which can be done hash(maxelementinarray+1);
for(int i=0;i<n;i++)
{
hash[nums[i]]++;
}
for(int i=0;i<m;j++)
{
if(hash[nums[i]]==1)
{
return nums[i];
}
}


here time complexity is 0(3*n)\
and time complexity will be 0(n)

usig xor nt getSingleElement(vector<int> &arr){
	// Write your code here.	
	int xorr=0;
	for(int i=0;i<arr.size();i++)
	{
		xorr=xorr^arr[i];
	}
	return xorr;
}


Note:hash array tak 0(1) for operaton and space complexity is 0(n) and in map ordered tme complexity is o(log) and space complexity is 9(n) but plese note that hash rray is good for the mall values but for large value we uses map
-----------------------------------------------------------------------------------------------------------------------------------------------------------
find the longest subarray with sum as k and array contains positive elements
int arr[]={1,2,3,1,1,1,1,4,2,3}
*when i say subaaray it means contigous part of an array mean element from array but taken at position whuch are continuous no break in between
[1] is a contigous part of an array
[1,1,1]is the contigous part of an array
[4,2,3]is a subarray
[1,2,3] is a subarray as here each element is taken from continous part of an array
*suppose sum is given is 3 so subarray with sum 3 is 
[1,2]
[3]
[1,1,1]here length is 3 that is largest

so first thing is to generate all the subarrays
[1]
[1,2]
[1,2,3
[1,2,3,1]
[1,2,3,1,1]
....
.....
.......
.........then
[2]
[2,3]

so keep i=0;
j=0;
then i=0 j=0 from i to j is subaaray the j++,
then from i to j is subaray 
j++
from i to j subaaray


for(int i=0;i<n;i++)
{
for(int j-i;j<n;j++))
{
for(int k=i to j)
{
sum=sum+arr[k];
}
if(sum==givensum)
{
len=max(len,j-i+1)
}



return len;

*now observe 1 sum=1
1 ,2=sum+2
1,2,3->sum=sum2+3 

so why use the 3rd loop
for(int i=0;i<n;i++)
{
for(int j=i;j<n;j++))
{
len=max(len,j-i+1)

}


2nd method can be hashing . . . . .
int arr[]={1,2,3,1,1,1,1,4,2,3}
consider till 5th elemnt the prefix sum is x,then there are 5 subaaray with last element as 5th point,consider any point 3rd till is the subaaray wwith sum as k then remaining points subaraay sum is x-k,then reverse engineering if we find x-k then for sure subaaray with sum as k present present
and in any subaaray if sum is x-k,then the remaining subaaray must have sum as k
so consider sum=0,len=0 len as 0 as initially no subaarray is found
get first elemnet as 1 thus sum=1, and it is not eqaula to k=3,thus in hashmap m,m.insert(1,0) where 0 is the index of 1
get second element as 2 hence sum=3 which is equal to 3 means,{1,2} is the subarray giving the sum and hence length will be 2,hence m.insert(3,1)where 3 is the sum and 1 is till tis we got the subbarray with sum as k
*now get the 3rd element which is 3thus get the sum as 6 . . . standing at last .,which can be 3 thsy 6-3=3,is there any sum as 3 in hashmap yes,thus insert(6,2) but its length will be 2-1=1 which is not greater than 2 thus length will be 2
*
now code
map<long long,int>presum;
int maxlen=0;
int sum=0;
for(int i=0;i<arr.size();i++)
{
sum=sum+arr[i];
if(sum==k)
{
maxlen=max(maxlen,i+1)
}
requiredpre=sum-k;
if(presum.find(requiredpre)!=presum.end())//if find
{
int len=i-presum[requiredpre];
maxlen=max(maxlen,len);
}

;//but suppose[2,0,0,3]the len=3-2==1 but no longest subbaray with sum 3 must be0,0,3 so thing we did is if sum find in array still updation,but that must be removed
if(presu.find(sum)==presume.end())
{
presum[sum]=i
}





}

code correct 
  long long sum=0;
    map<long long ,int>presummap;
    int maxlen=0;
    for(int i=0;i<a.size();i++)
    {
        sum=sum+a[i];
        if(sum==k)
        {
            maxlen=max(maxlen,i+1);
        }
        long long requiredsum=sum-k;
        if(presummap.find(requiredsum)!=presummap.end())
        {
            int len=i-presummap[requiredsum];
            maxlen=max(maxlen,len);
        }
       
            presummap[sum]=i;//always
        
    }
    return maxlen;


note:same code works fpr negative number,but it is partially accepted
 note:but for problem which contains both positive nad negative numberss and 0this is the optimal approach
*Here time complexity will be o(n) considering as the  unodrdered map and if we consider the orerd then 0(n*logn) and space complexity willbe o(n) as we are using the mnap
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*now for the arary that ontains the positive and 0 we need tofind the optimal approach
 note:tae  then right++ ,for thr continuity,thus sum increase and as  soon as sum>k then trim the left part till sum>k



*using 2 pointer approach
 int maxlen=0;
    int left=0;
    int right=0;
    long long sum=a[0];
    while(right<a.size())
    {while(sum>k && left<=right)
    {
        sum=sum-a[left];
        left++;
    }
        if(sum==k)
        {
maxlen=max(maxlen,(right-left)+1);
        }
        right++;
        if(right<a.size())
        {
            sum=sum+a[right];
        }

    }
    return maxlen;
    here time complexity will be 0(2*n)//this is optimal solution for the array with positive number or negative
Here space complexity will be o(1)
------------------------------------------------------------------------------------------------------------------------------------------------------------

*2 sum problem
int arr[]={2,6,5,811}
we have to give 2 element from array whose sum is equal to the target
1.st variety is to return the true or false if we get element whose sum is equal to target
2nd variety can be we have to return an array containig the indexes of 2 element whose sum is equla to the target

brute force will be for(int i=0;i<=n-2;i++)
{
for(int j=i+1;j<n;j++)
{
if(arr[i]+arr[j]==sum)
{
temp.push_back(i);
temp.push_back(j);
}
}
}


second method can be hashing
first we take any elemnet and then want next element whose sum is sum ,and that element is sum - element at which we are iterating,we will chwck if that ,means tand at any element once and check if NEXT element exist in previous array as 2,6 is same as 6,2 giving total as 8
map<int,int>mpp;
for(int i=0;i<n;i++)
{
if(mpp.find(sum-arr[i])!=mpp.end())//if found
{
return "yes";//temp.push_back(mpp[sum-arr[i]])
}else
{
mpp[arr[i]]=i;
}
}
return "no";
Sp here time complexity will be o(n*logn) and the space complexity will be 0(n)



#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        map<int,int>mpp;
        
        
        for(int i=0;i<nums.size();i++)
        {
          if(mpp.find(target-nums[i])!=mpp.end())
          {
             
              return {mpp[target-nums[i]],i};
          }
            mpp[nums[i]]=i;
        }
        return {-1,-1};
        
    }
};


Each Operation Inside:
mpp.find(...) is O(log n) because map in C++ is implemented as a balanced BST (Red-Black Tree)

mpp[nums[i]] = i is also O(log n)
so the time complexity will be o(n*logn)//logn due to as we use the ordered_map
and if we use the unordered_map then use the 0*n)
so sort the array
we can use the 2 pointer approach here take i=0 and left=j
first sort the array
while(i<j)
{
sum=arr[i]+arr[j];
if(sum<target)
{
i++
}else
{
j--;
}else
{
return "yes"
}//thsi sis optimal solution for the part where we need to return the yes or no
*for variety 2 that mapping algo is the best
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------from 

*so the brute force soltion will be to sort an array using the merge sort or the quick sort
*sort an array of 0s 1s and 2s
int arr[]={0,1,2,0,1,2,1,2,0,0,0,1}
int cnt0=0
int cnt1=0;
int cnt2=0;
for(int i=0;i<n;i++)
{
if(arr[i]==0)
{
cnt0=0;
}else if(arr[i]==1)
{
cnt11++;

}else
{
cnt2++;
}
for(int i=0;i<cnt0;i++)
{
arr[i]=0;
}
for(int j=cnt0;i<cnt1+cnt0;i++)
{
arr[i]=1;
}
for(int j=cnt1+cnt0;i<cnt2+cnt0+cnt1;i++)
{
arr[i]=2;
}

//here time complexity will be o(3n)

so now the dutch national flag algorithm comes which uses the 3 pointer approach
from 0 t0 low-1 everything will be 0
from low to mid-1 will be 1
from mid to high will be the random number and thay are in unsorted order consisting of 0,1,2
*from high+1 to n-1 will be the 2s
*the one which contains 0s and 1 s are sorted and one that contains 2s are also sorted, if we manage to sort the unsorted array between mid and high,and *that unsorted array is our array
*so take mid=0 consider 
a[mid]==0,then its left will not be sorted so put 0 at the place where low position and A[LOW] to the a[mid] position  now array will be sorted
now till 0 to mid is sorted unsorted is now mid is mid+ to the high
now 0s are from 0 to low-1 and low has also increase
so swap(a[low],a[mid];
mid++;\
low++
*now take mid==1
then alreadybsorted and simply mid++
*id mid==2 then swap(a[mid],a[high]
high--;

 int mid=0;
    int low=0;
    int high=n-1;
   while(mid<=high)
    {
        if(arr[mid]==0)
        {
            swap(arr[low],arr[mid]);
            mid++;
            low++;
        }else if(arr[mid]==1)
        {
            mid++;
        }else{
            swap(arr[mid],arr[high]);
            high--;
        }
    }
------------------------------------------------------------------------------------------------------------------------------------------------------------
int arr[]={2,2,3,3,1,2,2}
we have to find the element which appears more than n/2 times

brute force will be for(int i=0;i<n;i++)
pick up the lement and j=i+1;j<n;j++,if arr[i]==arr[j],cnt++;come out of inner loop if cnt>n/2 then return arr[i];
here time complexity will be o(n*n)

here brute force will be for each element take out cnt from the whole array not from that to the right


so here the brute force solution will be for(int i=0;i<n;i++)
{
int cnt=0;
for(int j=0;j<n;j++)
{
if(arr[i]==arr[j])
{
cnt++;
}
}
if(cnt>n/2)
{
return arr[i];s
}

}
Here time complexity will be O(n*n)

second way is we can use the map
map<int,int>mpp;
for(int i=0;i<n;i++)
{
mpp[arr[i]++;
}//this will whole take time AS nlogn
for(auto it:mpp)
{
if(it.scond>arr.size()/2)
{
return it.first;
}
}//this will take time as o(n)

hence total time will be  o(n)+o(logn*n)
but he space complexity will be o(n)

*another is we can use the moorey voting algorithm
which says that takeint ele;
int cnt=0;
take forst element then ele=elemnt;
cnt++;
next element if not equal to ele then cnt--
if at any stage cnt==0;
till that array no element is majority bcz till that array if taken should contains one majority element ,but not 




*so after the iteration is completed the element el value is the majority element for sure if the majority element exists
*so the second step will be y=to check if the majority element exists or not

then verify that the element frequency ois greater than n/2 then only return the elemnt
*int majorityElement(vector<int> v) {
	// Write your code here
	int el;
	int cnt=0;
	int count=0;
	for(int i=0;i<nums.size();i++)
	{
		if(cnt==0)
		{
			cnt=1;
			el=nums[i];
		}else if(nums[i]==el)
		{
			cnt++;
		}else
		{
			cnt--;
		}
	}
	for(int i=0;i<nums.size();i++)
	{
		if(nums[i]==el)
		{
count++;
		}
	}
	if(count>nums.size()/2)
	{
		return el;
	}
        return -1;



note :please take care if cnt not zero than update the cnt to++ or --
*and the thing nextis tht the always t=check if the majority element exist or not
------------------------------------------------------------------------------------------------------------------------------------------------------------

maximum subaaray sum
*int arr[]=[-2,-3,4,-1,-2,1,5,-3}
now the brute force will be
for(int i=0;i<n;i++){
for(int j=i;j<n;j++)
{
for(int k=i;k<j;k++)
{
sum=sum+arr[k];
}
maxi=max(sum,maxi);


hence the time complexity will be o(n*n*n)
*now to optimize it we can for(int i=0;i<n;i++){
int sum=0;
for(int j=i;j<n;j++)

sum=sum+arr[j];//here only
maxi=max(sum,maxi);

}
now time complexity will be o(n*n)


*int arr[]={-2,-3,4,-1,-2,1,1,5,-3}

now the kadane algorithms

now the linear time 
first take sum=0;
then take maxsum=INT_MIN;


take the sum=-2 and max is also -2 but if sum is less tan 0 gain update sum as the 0 as -2 will make sum as egative sam,e with -3 now with sum as 4 update max as 4 and then  it is not less than 0 so  dont make sum as 0 and return maxi
for(int i=0;i<n;i++)
sum=sum+arr[i]
if(maxi<sum)
{
maxi=sum;
}
if(sum<0)
{
sum=0;

here time complexity will be o(n)
#include<bits/stdc++.h>
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int sum=0;
        int maxsum=INT_MIN;
        for(int i=0;i<nums.size();i++)
        {
            sum=sum+nums[i];
            maxsum=max(maxsum,sum);
            if(sum<0)
            {
                sum=0;
            }
        }
       
        return maxsum;
        
    }
};
*there can be a followup question here that the if we want store that maximum subarray sum array
*-2,-3,4,-1,-2,1,1,5,-3
*so here whenever we were staring with with formation of subbrya with sum>0 we are always at firsthaving the sum==0
*
if sum==0{
start=i;
}
if(sum>maxsum)
{
anstart=start;
ansend=i;
}
*thus subarray from ansstart to ans end will be the subarray
*
------------------------------------------------------------------------------------------------------------------------------------------------------------
stock buy and sell
*basically we are given the 
*we re given int arr[]={7,1,5,3,6,4}
*on the 1st day price is 7
*on the second day price is 1
*so here uppose i buythe tock on an day 2 thatis price is 1
*nd then sell on another ay is 5 and price is 6
*so net profit is 5 and e need to maximie the profit
*so if you are selling at the ith day,then you must buy
the minimum from 0 to i-1 days
*so starting from the 1 index we can take the for the selling day if i can take the count of the minimum on  left

*so what we will do is the from take mini=a[0];
int profit=0;
for(nt i=1;i<n;i++)
{
int cost=a[i]-mini;
profit=max(profit,cost);
mini=min(mini,a[i]);
}

using namespace std;
#include<bits/stdc++.h>
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int mini=prices[0];
        int profit=0;
        for(int i=1;i<prices.size();i++)
        {
            int cost=prices[i]-mini;
            profit=max(profit,cost);
            mini=min(mini,prices[i]);
        }
        return profit;
        
    }
};
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Note:✅ 1. Normal Arrays in C++
a) Fixed size, uninitialized:
cpp
Copy
Edit
int arr[5];  // Uninitialized, may contain garbage values
b) Fixed size, initialized to 0:
cpp
Copy
Edit
int arr[5] = {0};  // All elements will be 0
c) Fixed size, with specific values:
cpp
Copy
Edit
int arr[5] = {1, 2, 3, 4, 5};
✅ 2. Vectors in C++
You need to #include <vector>.

a) Empty vector:
cpp
Copy
Edit
vector<int> v;  // Empty vector
b) With specific values:
cpp
Copy
Edit
vector<int> v = {1, 2, 3, 4, 5};
c) With fixed size and default value (e.g., 0):
cpp
Copy
Edit
vector<int> v(5, 0);  // Size 5, all elements initialized to 0
d) With fixed size (elements will be default initialized, for int it's 0):
cpp
Copy
Edit
vector<int> v(5);  // Same as vector<int> v(5, 0);

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
we are said that we have an array with equal no of positive elements and equal no of negative elements
int arr[]={3,1,-2,-5,2,-4}
so take out all positive [3,1,2] and and all negative [-2,-5,-4] and arrang so that positive lies at every 0,2,4 index and all negativbe lies at 1,3 ,5 index
*brute force solution will be take 2 array arr1[]of size n/2 and another array arr2[] of size n/2
index1=0,index2=0;
for(int i=0;i<n;i++)
{
if(arr[i]>0)
{
arr1[index1]=arr[i];
index1++;
}else
{
arr2[index2]=arr[i];
index2++;

}
for(int i=0;i<n/2;i++)
{
arr[2*i]=arr1[i];
arr[2*i+1]=arr2[i];
}
hence time complexty will be o(2
*n) and space is o(n)

so a little more optimal solution will be where we will take the extra space will be so we cant optimize the space complexity but can reduce the time complexity by when we pick element the order where we are storing store in the correct way and then return that newly created array
*
class Solution {
public:
    vector<int> rearrangeArray(vector<int>& nums) {
        vector<int>ans(nums.size(),0);
        int posindex=0;
        int negindex=1;
        for(int i=0;i<nums.size();i++)
        {
            if(nums[i]>0)
            {
                ans[posindex]=nums[i];
                posindex=posindex+2;
            }else
            {
                ans[negindex]=nums[i];
                negindex=negindex+2;
            }
        }
        return ans;
        
    }
};--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
so another variety of question is is we have an array which does not contain equal no of positive or naegative elements 
*consider int arr[]={1,2,-4,-5,3,6}
*for this scenario there can be 2 cases either no of positive>negative
*no of negative>no of positive
*
now the question arise that if the array does not contains equal no of ones and 0s then the we will jump to the brute force solution
*if no of positive is not equal to the number of negative then there might be 2 possibily as no of positive might be greater than the no of negative or no of negative might be greater than the no of positve
int arr[]={-1,2,3,4,-3,1} here 4 positive and 2 negative so take 2 array arr pos and array neg and theirs size will be eual to minimum number of numbers in both array and this only condition will make as suppose that no of positive is equal to negative
for(int i=0;i<n;i++)
{
if(arrr[i]>0)
{
pos[]=arr[i]
}else
{neg[]=arr[i]
}
}
for(int i=0;i<min(pos.size;(),neg.size());i++)
{
arr[2*i]=pos[i];
arr[2*i+1]=neg[i];

}//addition pos value
ind=2*min(pos.size;(),neg.size());
for(int i=min(pos.size;(),neg.size());i<pos.size();i++)
{arr[ind]=arr[i]
ind++;

}




-----------------------------------------------------------------------------------------------------------------------------------------------------------------
*next permuatation
*so we will be gven an arry
*and the int arr[]{3,1,2}
*we can arrange it in 3! and get 6 ways in which these elements can be arranged
*now the permutation measn in sorted order
*hence [1,2,3]
[1,3,2]
[2,1,3]
[2,3,1]
[3,1,2]
[3,2,1
*and each way of arranging is calle the pemutation
*and we need to return the next permuatio of the 3,1,2 that is 3,2,1

*now the edge case willbe that if we are given [3,2,1] than as its next permuation will be the first rearrangement
*so the brute force will be to generate all the permutations,liner search for the given array permuaton match,next index will be next permutation
*so for the time complexity we will se the time for generating all the permutations will be (n!*n) here n factorialwill be for all permuattaion in sortedorder and each permuation wil be of lengyh n
*so here the time complexity with the brute force will be very high
*now there is no better solution as but we can use the stl next_permutation(arr.begin(),arr.end());return a
*now lets move to the optimal solution
*so now the consider arr as [2,1,5,4,3,0,0]
*consider raj,raax,rbx for the aj and rax there is long prefix match
*so we are looking for the longer prefix match
*s tarting from the right we will tr to arrange the element so that we can do the prefx match 
*but result must be greater tha the whole
*we will try to do longest prefix match measn aggae ka match so that whole number is greater
*consider from 0 to 5 index 6 index left hence no arrangement is possible 
*from 0 to 4 then 2 index left hence 2 rearrangement possible
*now move to 0 to 3 3 index left and 6 ararngemnet possible find that arrangement which make whole number greater than the number
*from 0 to 0 index 6! hence 120 rearangemnet possible but one rearrangement number greater than the actual number is and greatest is 2,1,5,4,3,1,0,0
*so at any index keeping i-1 prefix same we wil check if we can get greater number if greater tha a[i] is possible toward i+1 just greater
*so 1.find out the breaking point a[i]<a[i+1]
*then the from i+1 to n find just greater than the a[i]s
*swap a[i] and greate than 2 places filled then sort the array from i+1
*
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
int breakind=-1;
        for(int i=nums.size()-2;i>=0;i--)
        {
            if(nums[i]<nums[i+1])
            {breakind=i;
            break;

            }
        }
        if(breakind==-1)
        {
    reverse(nums.begin(),nums.end()); 
        }
        else
        {
            for(int i=nums.size()-1;i>=breakind+1;i--)
            {
                if(nums[i]>nums[breakind])
                {
                    swap(nums[i],nums[breakind]);
                    break;
                }
            }
            reverse(nums.begin()+breakind+1,nums.end());
        }
        
    }
};
Note:so here the n-2 will have the last dip
------------------------------------------------------------------------------------------------------------------------------------------------------------
leaders in array
*int arr[]={10,22,12,3,0,6}
leader is one to which all towards right is smaller such as 22 is leader,12 is leader,6 is leader
and format is the one in which we are finding
*so the brute force will be for(int i=0;i<n;i++)
{
int swap=0;
for(int j=i+1;j<n;j++)
{
if(arr[j]<arr[i])
{
}else
{swap=1;
break;
}
}
if(swap==0)
{
ans.push_back(arr[i]);
}
}


now the optimal solution will be if we take 22 and to right the max among all is 6 so if 22>6 means it will be greater of all on right
so first task to to stand at a  particlar index and find the max at right so stand will start  from the i=n-1 find the max from right so take max=INT_MIN; and traverse from right
for(int i=n-1;i>=o;i--)
{
if(arri[i]>max)
{
max=arr[i];//first update max
ans.push_back(arr[i]);then the leaders
}
}
but here ans array will be [6,12,22],so reverse this


using namespace std;
#include<bits/stdc++.h>
class Solution {
    // Function to find the leaders in the array.
  public:
    vector<int> leaders(vector<int>& arr) {
        int max=INT_MIN;
        vector<int>ans;
        for(int i=arr.size()-1;i>=0;i--)
        {
            if(arr[i]>=max)
            {
                max=arr[i];
                ans.push_back(arr[i]);
            }
        }
        reverse(ans.begin(),ans.end());
        return ans;
        // Code here
    }
};
------------------------------------------------------------------------------------------------------------------------------------------------------------
longest consecutive subsequence
int arr[]={102,4,100,1,101,3,2,1,1} 
*we need to find the longest consecutive subsequence
*consecutive means in orders suppose i say i pick up 1,2,3,4 so they are consecutive and are in sequence  length is 4 an if  we take 100,101,102 then length is 3
*brute force olution wll be if i take x than i will look for x+1,x+2,
*so lets take longest subsequence len to be 1 longlen=1
*so iterate first elemet is an cnt=1;el=a[i] then iteart from starting if found x+1 then cnt++
*than take the max of len and the cnt
*
int len=1;
for(int i=0;i<n;i++)
{
int x=a[i];
int cnt=1;//for consecutivity of subsequence corresponding to each element in an aray
while(linear_search(a,a+n,x+1))
{
cnt++;
x=x+1;
}
len=max(len,cnt);
}

but here time complexity will be 0(n*n)


*now more optimal solution will be first sort it {1,1,1,2,2,2,3,3,4,100,100,101,101,102} as to club together for cnscutivity
*
so that they kind of in the consecutive subsequence then then longestlen=1,then nextsmaller to tell what was the last samller element seen for a particular element in array and cnt=0 to tell if any element is part of sequence by comparing with last then cnt++ or else its new sequene thn cnt=1
*
first element is 1 so to part of subsequence must somethins as 101 just like part must have 100 sameas the it  its leftsmaller must be element 0, ,if not then then update as it can part f subsequence ad hen cnt=1;and alsoupdate the lastelememnet to the arr[i],then update the leftsmaller and then cnt++ indicate that it has become the starting point of subsequence
*
next is 1 so its left part must be 0 but its not but if its equal to element then no need to change anything as the last element already was startin or the part of subseqnece 
next is 1 so its left part must be 0 but its not but if its equal to element then nothing 

next is 2 then its left must be 1 and it is then cnt++;
and left smaller =element;
and update the long=2
same till cnt=4 len=4 smaller=4
next is 100 check its smaller is 99 but its not then cnt=1;
smaller=element
 // Write your code here.
    int cnt=0;
    int len=1;
    int smaller=INT_MIN;
    sort(a.begin(),a.end());
    for(int i=0;i<a.size();i++)
    {
        if(a[i]-1==smaller)
        {
            cnt++;
            smaller=a[i];
        }
        else if(a[i]!=smaller)
        {
            cnt=1;
            smaller=a[i];
        }
        len=max(len,cnt);
    }
    return len;
here tikme complexity will be o(nlogn)//for sorting and 0(n) for array 
now optimal will be that if we can remove the sorting of an array
*the interviewer must say yo cant sort the array


now we can have the unorderset where we store element then iterate over set and for particular set if the smaller exist in set it means its not starting point and if not than its starting point
*just as same as te optimal solution
*

using namespace std;
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int>st;
        if(nums.size()==0)
        {
            return 0;
        }
        int len=1;
        for(int i=0;i<nums.size();i++)
        {
            st.insert(nums[i]);
        }
        for(auto it:st)
        {
            if(st.find(it-1)==st.end())
            {
                int cnt=1;
                int x=it;
                while(st.find(x+1)!=st.end())
                {
                    cnt++;
                    x++;
                }
                len=max(len,cnt);
            }
        }
        return len;

        
    }
};
----------------------------------------------------------------------------------------------------------------------------------------------------------
rotate the matrix by 90 degree
we will be given a n*n matrix
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16

rotae it by 90 degrees
13 9 5 1
14 10 6 2
15 11 7 3
16 12 8 4

[0][0]=[0][3]
[0][1]=[1][3]
[0][2]=[2][3]
[0][3]=[3][3]

[1][0]=[0][2]
[1][1]=[1][2]

this means j of the original array will go to i of the newarray i(new)==j(orig)
j(new)==(n-i-1)orig

so for(int i=0;i<n;i++)
{
for(int j=0;j<n;j++)
{
ans[j][n-1-i]=arr[i][j]
}
}
so time and space complexity will be o(n*n)
now interview will sya that solve it in the inplace
so the observation is first column became the row 0 but in reverse order first make the first column as row 0

for that take the transpose of matrix
1 5 9 13
2 6 10 14
3 7 11 15
4 8 12 16

now for the transpose of matrix if i!=j
swap(a[j][i],a[i][j])
now for traversing for row we will go from for(int i=0;i<=n-2;i++)//then go from 0 to n-2
{
for(int j=i+1;j<=n-1;j++)//will go if i,then i+1 to n-1
{
swap(a[i][j],a[j][i]);
}
}
and then reverse every row
for(int i=0;i<mat.size();i++)
{
revrse(mat[i].begin(),mat[i].end());
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
set matrix to 0
*traverse the rows and find if that row column 0 is 0 make it trye
*iterate from the colum
*for (int row = 0; row < matrix.size(); row++) {
    if (matrix[row][0] == 0) zeroinFirstCol = true;
    for (int col = 1; col < matrix[0].size(); col++) {
        if (matrix[row][col] == 0) {
            matrix[row][0] = 0;
            matrix[0][col] = 0;
        }
    }
}

*then iterate frombottom
*and from back
*or (int row = matrix.size() - 1; row >= 0; row--) {
    for (int col = matrix[0].size() - 1; col >= 1; col--) {
        if (matrix[row][0] == 0 || matrix[0][col] == 0) {
            matrix[row][col] = 0;
        }
    }
    if (zeroinFirstCol) {
        matrix[row][0] = 0;
    }
}
Then while traversing again we can just check if the first element of the row or colu

------------------------------------------------------------------------------------------------------------------------------------------------------------
*spiral matrix
we are given n*m matrix
1 2 3 4 5 6 
          7  
          8 
          9
          10
 
16 15 14 13 12 11
we ned to print it in spiral order

so the pattern will be right->bottom->left->top
here left=0,right=5,top=0,bottom=5,here left and right for the column traversal and top and bottom for the row traversal

for(int i=left;i<=right;i++)
{print(arr[top][i]);//here row fixed column changes for the right traversal

)
}// 
top++;//alla about the right portion 
for(int i=top;i<=bottom;i++)
{
println(arr[i][right])
}
right--;all about bottom traversal

for(int i=right;i>=left;i--)
{
println(arr[bottom][i]
}
bottom--;//all about lefy traversal
for(int i=bottom;i>=top;i--)
{
ptint(arr[i][left];
}
left++;//all about top traversal



 int n=MATRIX.size();
    int m=MATRIX[0].size();
    int left=0;
    int right=m-1;
    int top=0;
    int bottom=n-1;
    vector<int>ans;
    while(top<=bottom&&left<=right)//this is case so thatto make the outer boundary squear
    {
        for(int i=left;i<=right;i++)
        {
            ans.push_back(MATRIX[top][i]);
        }
        top++;
        for(int i=top;i<=bottom;i++)
        {
            ans.push_back(MATRIX[i][right]);
        }
        right--;
        if(top<=bottom)
        {
             for(int i=right;i>=left;i--)
        {
            ans.push_back(MATRIX[bottom][i]);
        }
       
        }
         bottom--;
         if(left<=right)
         {  for(int i=bottom;i>=top;i--)
        {
            ans.push_back(MATRIX[i][left]);
        }

         }
         left++;
    }
    return ans;
}
if we have only one row the right traversal no bottom no ;left but for nro left so check if(top<=bottom) 
*another use case will be in last part te top mpart not done bez leftwas not leass than right so there put condition if(left<=right)
-----------------------------------------------------------------------------------------------------------------------------------------------------------
count the subarray with given sum k
int arr={1,2,3,-3,1,1,1,4,2,,-3}
so the brute force willl be first of o(n*n*n)
but by running 2 loops we can also reduce it to 0(n*n)


till at any point consider the sum as x  and within its index there lies the elememts with sum as k,consider at same end point there are 2 subaarrays with sum as k, then there are 2 subarray with prefix sum as x-k;
*and so we do reveerse engineering that say till any point sum is s ,will will figure out how many s-k are present and that no of s-k will be the number of times k preesnt
*so the ds we will be used will be hashmap storing prefix sum s-k ,and the value must be cnt which is basically how many times prefix sum occured


so intution will be store {0,1} in hashmap than take presum as 1 then see if hashmap contains 1-3=-2 if n then store {1,1} then check for 2 as 1+2 is 3 and 3-3==0 is present in array so increase the count=1;and store {3,1}
similarly store {3,2} as 1 increase as this {3,1} alreadty present
#include<bits/stdc++.h>
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
         map<int,int>mpp;
    int presum=0;
    int cnt=0;
    mpp[0]=1;
    for(int i=0;i<nums.size();i++)
    {
        presum=presum+nums[i];
        int remove=presum-k;
        cnt=cnt+mpp[remove];//if found
        mpp[presum]=mpp[presum]+1;//,if found or not
    }
        return cnt;
        
    }
};
-------------------------------------------------------
pascal triangle with n and r
long long nCr(int n, int r) {
    if (r > n) return 0;
    long long res = 1;
    for (int i = 0; i < r; i++) {
        res = res * (n - i) / (i + 1);
    }
    return res;
}
for the row
vector<vector<int>> generate(int numRows) {
        vector<vector<int>>temp(numRows);
        for(int i=0;i<numRows;i++)
        {
            temp[i].resize(i+1);
            temp[i][0]=temp[i][i]=1;
            for(int j=1;j<i;j++)
            {
                temp[i][j]=temp[i-1][j-1]+temp[i-1][j];
            }
        }
        return temp;
        
    }
};
View less
 
Write your notes here
Select related tags
0/5

-----------------------------------------------------------------------------------------------------------------------------------------------------------
majority element greater than m/3;
int arr[]={1,1,1,,3,3,2,2,2}
here element taht appear 8/3=2 times means greater than 2 is 3 that is minmal and if one lemnent 3 times 3+3=6 less than 8 are 1,2 so at max there can be 2 element
see here so max number of elements that can be geater tha 2 is n/3
brute force will be take list as []
traverse take i=0 that is 1 than traverse j =i to n and see if(arr[i]==arr[j];
cnt++;
if(cnt>n/3)
{
[].push_back(Arr[i])
} //
//if([] already contains arr[i],then continue to next i


anoyher method can be hashing
but in hashing first time we are inserting and second time iterating to get cnt >n/3
we can reduce the step when we are inserting and as soon as hash[nums[i]]>n/3 then store [1] move to next 1 and see if one alrady in hashmap continue to next iteration
// Write your code here
	vector<int>ls;
	map<int ,int>mpp;
	int mini=(int)(v.size()/3)+1;
	for(int i=0;i<v.size();i++)
	{
		mpp[v[i]]++;
		if(mpp[v[i]]==mini)
		{
			ls.push_back(v[i]);
		}
		if(ls.size()==2)
		{
			break;
		}
	}
	sort(v.begin(),v.end());
	return v;
time complexity qill be o(n)*(logn)

now the logic of n/2 times that if element is greater than n/2 than no one should cancel its count for the frequency,and and if greater frequency remains element than check that element count >n/2 than tere there can be oe element soele=0;cnt=0; the element,here at max  

but here n/3 there can be max 2 elements 
int cnt1=0,int cnt2=0;
for(int i=0;i<n;i++)
{
if(ant1==0)
{
cnt1=1;
el=cnt1;
}else if(cnt2==0)
{
cnt2=1;
el2=cnt2;
}else if(el==arr[i])
{
cnt1++;
}else if(el2==arr[i])
{
cnt2++;
}else
{
cnt1--,cnt2--;
}



}
conside {2,1,1,,3,1}
for 2 
cnt1=1;
el1=2

for 1
cnt2=1;
el2=1;

for 1
cnt2=2;
el2=1;
for 3
cnt1=0,cnt2=1;
for 1
cnt1=1;
el1=1;
but that must not be case this case from for loop will only take if nums[i]!=el2//this is edge case s edge case must be taken cae that if any cnt=0;ten update oly if nums[i]!=el2 and vce vrsa tue


vector<int> majorityElement(vector<int> v) {
	// Write your code here
	int cnt1=0;
        int cnt2=1;
        int el1=INT_MIN;
        int el2=INT_MIN;
        vector<int>ans;
        for(int i=0;i<v.size();i++)
        {
            if(cnt1==0 && el2!=v[i])
            {
                cnt1=1;
                el1=v[i];
            }else 
            if(cnt2==0 && el1!=v[i])
            {
                cnt2=1;
                el2=v[i];
            }else if(v[i]==el1)
            {
                cnt1++;
            }else if(v[i]==el2)
            {
                cnt2++;
            }else
            {
                cnt1--;
                cnt2--;
            }
        }
        int ct1=0;
        int ct2=0;
        for(int i=0;i<v.size();i++)
        {
            if(v[i]==el1)
            {
                ct1++;
            }
            if(v[i]==el2)
            {
                ct2++;
            } 
        }
        int mini=(int)(v.size()/3)+1;
        if(ct1>=mini)
        {
            ans.push_back(el1);//one more than that is the mni
        }
        if(ct2>=mini)
        {
            ans.push_back(el2);
        }
        sort(ans.begin(),ans.end());
        return ans;
}
------------------------------------------------------------------------------------------------------------------------------------------------------------
//startfrom here
3 sum problem
int arr[]={-1,0,1,2,-1,-4}
we have to find 3 elements such that arr[i]+arr[j]+arr[k]
*but condtions one element cant be taken twice means three elements cant be arr[i],arr[i],ar[j]mans
* i!=j!=k not possible
*means elemets must be unique
*and we cant return the duplicate triplets
*means on sorting we need not to return the duplicate triplets
*


so these 3 elements can be [-1,2,-1] and [0,1,-1] 
*return aall the triplets but thes triplts must not be duplicate means [-1,2,-1] and [0,1,-1]  and [-2,-1,-1] we cant return as  [-1,2,-1] and [-2,-1,-1] will be considered as the duplicates as when we sort it eerytriplete nd check that this trilet exists befoe or not
*

*

for(int i=0;i<n;i++)
{
for(int j=i+1;j<n;j++)
{
for(int k=j+1;k<n;++)
{
if(arr[i]+arr[j]+arr[k]==0)
{
vector<int>temp={arr[i],arr[j],arr[k]};//used to insert n any vector while initalizing
sort(temp.begin(),temp.end());//sort that triplets and
set.insert(temp);//then insert here as set is used to store the unique elemnst
}
}
vector<vector<int>>ans(set.begin(),set.end())//to convert set into vecor
}

but time complexity 
*Triple loop           → O(n³)
Sort 3 elements       → O(1)
Insert into set       → O(log n³) = O(log n)

Total per triplet     → O(log n)
Total complexity      → O(n³ log n)

*so next will be hashing 

so we are looking for arr[k]=-arr[i]-arr[j];
consider {-1,0,1,2,-1,-4}
imortantpoint i!=j!=k
suppose i=0 and j=4 then -(-2)=+2 find in hashmapwhich so we wll pu all the things in between in hashmap 
*so the thing is uppose we have i somewhere and j somewere we will look that someone in he array such that it must be not equal to arr[i] and arr[j]
*suppose i is at 0 and j=4 so the find one must be not equal to these therby e will store the n between of this index in hashmap
*so start with both i and j pointing to same index
*che if -(ar[i]+arr[j])exist in array or not 
*if not then hashmap(arr[j]]=j;
*j++
*if then sort(arr[i,arr[j],hashma[-(arr[i])+arr[j]) and put it in set
Note:for every i iteration there will be new hashmap created
*class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
       set<vector<int>> st;
        int n = nums.size();

        for (int i = 0; i < n; i++) {
            unordered_map<int, int> mpp;
            for (int j = i + 1; j < n; j++) {
                int third = -(nums[i] + nums[j]);
                if (mpp.find(third) != mpp.end()) {
                    vector<int> temp = {nums[i], nums[j], third};
                    sort(temp.begin(), temp.end());
                    st.insert(temp);
                }
                mpp[nums[j]] = j;
            }
        }

        return vector<vector<int>>(st.begin(), st.end());
        
    }
};
-----------------------------------------------------------------------------------------------------------------------------------------------------------
4 sum problem
int arr[]={1,2,-1,-2,2,0,-1}
keep  i=0;
int j=i+1;
l=i+2;take here hashet
and see if(-arr[i]+arr[j]+arr[k] is there in hashset or not if not insert that arr[k] in hashset,so basically everything between j and k is put in hashset

#include<bits/stdc++.h>
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    // Write your code here
   
     set<vector<int>>st;
    for(int i=0;i<nums.size();i++)
    {
        for(int j=i+1;j<nums.size();j++)
        {
            set<long long>hashset;
            for(int k=j+1;k<nums.size();k++)
            {
              if(hashset.find(-(nums[i]+nums[j]+nums[k])) != hashset.end())
                {
                  vector<int> temp = {nums[i], nums[j], nums[k],
                                      -(nums[i] + nums[j] + nums[k])};
                  sort(temp.begin(), temp.end());
                  st.insert(temp);
                }

   hashset.insert(nums[k]);

            }
        }
    }
    vector<vector<int>>ans(st.begin(),st.end());
    return ans;
}

but here time complexity will be o(n*n);
*optimal solution will be #include<bits/stdc++.h>
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    // Write your code here
   
      vector<vector<int>>ans;
    sort(nums.begin(),nums.end());
   for(int i=0;i<nums.size();i++)
   {
       if(i>0 && nums[i]==nums[i-1])//increase i till its equal to avoid duplicate triplets
       {
           continue;
       }
       for(int j=i+1;j<nums.size();j++)
       {
         if(j!=i+10 && nums[j]==nums[j-1])//increase i till its equal to avoid duplicate triplets
       {
           continue;
       }
       int k=j+1;
       int l=nums.size()-1;
       while(k<l)
       {
           int sum=nums[i]+nums[j]+nums[k]+nums[l];
           if(sum<target)
           {
               k++;
           }else if(sum>target)
           {
               l--;
           }else{
               vector<int>temp={nums[i],nums[j],nums[k],nums[l]};
               ans.push_back(temp);
               k++;
               l--;
               while(k<l && nums[k]==nums[k-1])
               {
                   k++;
               }
               while (k < l && nums[l] == nums[l + 1]) {
                   l--;
               }
           }
       }
       }
   }
   return ans;

}------to be done
------------------------------------------------------------------------------------------------------------------------------------------------------------
longest subaaray with 0 sum
*given ana rray having both positive and negative integers
*we have the compute the length
*of largest subarray with sum as 0
*int arr[]={15,-2,2,-8,1,7,10,23}
*so he naive solution will be o(n*n*n) then it will short to 0(n*n)
*suppose [1,2,0]
*we are saying that till the all 3 we have sum as s and we say that from 1,2 we are getting sum as 3 then after that sum will be 0
*so take the hashmap and take sum=0
*this sum variable will take crare of the prefix sum
*check if its equal to 0 no then add to hashmap
*
*we say take presum=15 compare it with 0 no the n find if 15 in hashmap or not no the  the hashmap.insert(15,0)
*then again take presum=presum=13 its not equal to 0 as 13 not in ararya so hashmap(13,1)
*hpresum=15 nad hashmap.insert(15,2)
*presum=7 than hashmap(7,3)
*presum=8 and hashmap(8,4)
*same as the maximum length subaaray with sum as k


#include<bits/stdc++.h>
class Solution {
  public:
    int maxLen(vector<int>& arr, int n) {
        // Your code here
        map<int,int>mpp;
        int presum=0;
        int maxlen=INT_MIN;
        for(int i=0;i<n;i++)
        {presum=presum+arr[i];
        if(presum==0)
        {
            maxlen=max(maxlen,i+1);
        }
        if(mpp.find(presum)!=mpp.end())
        {
            int len=i-mpp[presum];
            maxlen=max(maxlen,len);
        }else
        {
            mpp[presum]=i;
        }
            
        }
        return maxlen;
    }
};
-----------------------------------------------------------------------------------------------------------------------------------------------------------
count the number of subarray with xor as k
*int Solution::solve(vector<int> &A, int B) {
    map<int,int>mpp;
    int cnt=0;
    mpp[0]=1;
    int presum=0;
    for(int i=0;i<A.size();i++)
    {
        presum=presum^A[i];
        int required=presum^B;
        cnt=cnt+mpp[required];
        mpp[presum]=mpp[presum]+1;
    }
    return cnt;
}
------------------------------------------------------------------------------------------------------------------------------------------------------------
merge overlapping intervals
*we will be given an aary of n subinteravals
*int arrr[]={{1,3},{2,6},{8,9},{9,11},{8,10},{2,4},{15,18},{16,17}}
*what is subintervals {1,3} means starts at 1 and end at 3
*we have to merge overlapping intervals into one
*and return how many subintervals you can give me
*so first approach will be sort this array
*so when we sort the array of pairs first they are sort on basis of first element and then on the basis of second element of a pair
*[{1,3},{2,4},{2,6},{8,9},{8,10},{9,11},{15,18},{16,17}}
*stand at 0th index that measn at {1,3} say thisis my subinterval
*and standing at 0 th index go to the 2,4 say are you overlapping measn is its first that is 2 is before the 3 true
*and we say yes its overlapping
*and if overlapping lets expand the {1,3} rhat wil expand to the {1,max(3,4}}
*and movee next next is also overlapping so expand mobe to next next is not overlapping so we say we got aour final 1st subinterval and break
*next move the i to the {2,4} but ist  already there in the finalised subinterval and we know this because its decond part is also therevin the {1,4}
*move to next
*please take care of the less than equal to sign
*class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        sort(intervals.begin(),intervals.end());
        vector<vector<int>>ans;
        for(int i=0;i<intervals.size();i++)
        {
            if(!ans.empty() && intervals[i][1]<=ans.back()[1])
            {
                continue;
            }
            
            for(int j=i+1;j<intervals.size();j++)
            {
                if(intervals[j][0]<=intervals[i][1])
                {
                    intervals[i][1]=max(intervals[i][1],intervals[j][1]);
                }else
                {
                    break;
                }
            }
            ans.push_back({intervals[i][0],intervals[i][1]});
        }
        return ans;
        
    }
};
*so here time complexity will be o(n*logn)+o(2*n)
*so here we will reduce standing at 1 and looking for the next and doing the j traversl
*so take first and make its first interval and put it in vector
*then next check if arr[i][0]<ans.back()[1] then update the interval in ans
*else
*take the new interval and push it in array
*vector<vector<int>> merge(vector<vector<int>>& intervals) {
        sort(intervals.begin(),intervals.end());
        vector<vector<int>>ans;
        for(int i=0;i<intervals.size();i++)
        {
           if(ans.empty() || ans.back()[1]<=intervals[i][0])
           {
               ans.push_back(intervals[i]);
           }else
           {
               if(intervals[i][1]<=ans.back()[1])
               {
                   ans.back()[1]=max(ans.back()[1],intervals[i][1]);
               }
           }
        }
        return ans;
        
    }
};
Note: ans.back()[1]<=intervals[i][0]) this is else codiion hence we are adding


------------------------------------------------------------------------------------------------------------------------------------------------------------
Merge 2 sortedarray without extra space
*we wil be given 2 arrays
*int arr1={1,3,5,7}
*int arr2[]={0,6,8,9}
*we need to merge2 array but we ned not tocreat new array so thatit takes space of o(n)
*instead arrange eementsin these arrays
*so its should be like the arr1 must store 0,1,3,5
*
and arr2 must be 6,7,89
*So the brute force appoach will be 
*int i=0;
int j=0;
vector<in>temp;
whie(i<arr.size()&&&j<arr2.size())
{
if(arr1[i]<=arr2[j])
{
temp.push_back(arr1[i]);
i++
}else
{
temp.push_back(arr2[j]);
j++


}
}
*while(i<arr1.sie())
{

}
*and then for(int i=0;i<arr1.size()+arr2.size();i++)
{
if(i<arr1.size())
{
arr1[i]=temp[i];
}else
{
arr2[i-n]=temp[i]
}
}

🔁 Time Complexity:
Merging both arrays into temp: O(n + m)

Copying back into arr1 and arr2: O(n + m)

🔹Total Time Complexity = O(n + m)

💾 Space Complexity:
Temporary array temp of size n + m

🔹Space Complexity = O(n + m) (not allowed in the constraint)



*so lets discuss the to reduce space complexity
*so here more better solution will be i will ay whats the largest in arr1 and whats the smallest in teh arr2
*we nt oth in sorted so these bigger and smaller is creating issue
*int eft=arr1.size()-1;
int ght=0;
while(left>=0 &&right<=arr2.size()){
if(arr[left]>arr[right]){
swap()
}else
{
break;
}
}
sort(rr1)
sort(arr2)
here time complexity will b e o(nlogn+o(mlohm)+0(n) nd space as 0(1)


Now we will use the gap method technique which uss the shll script
*take left=0 and right=gap
*then compare if arr1[left]<a22[right]
*left++,right++
*as soon as right move out of boundary then restart
*by reducing value of gap
*gap=cel of gap/2
*class Solution {
    void swapIfGreater(long arr1[], long arr2[], int ind1, int ind2) {
        if (arr1[ind1] > arr2[ind2]) {
            swap(arr1[ind1], arr2[ind2]);
        }
    }

public:
    // Function to merge the arrays.
    void merge(long arr1[], long arr2[], int n, int m) {
        int len = n + m;
        int gap = (len / 2) + (len % 2);
        
        while (gap > 0) {
            int left = 0;
            int right = left + gap;

            while (right < len) {
                // arr1 and arr2
                if (left < n && right >= n) {
                    swapIfGreater(arr1, arr2, left, right - n);
                }
                // both in arr2
                else if (left >= n) {
                    swapIfGreater(arr2, arr2, left - n, right - n);
                }
                // both in arr1
                else {
                    swapIfGreater(arr1, arr1, left, right);
                }
                left++, right++;
            }

            if (gap == 1) break;
            gap = (gap / 2) + (gap % 2);
        }
    }
};
Metric	Value
Time Complexity	O((n + m) * log(n + m))
Space Complexity	O(1) (in-place, no extra space)








----------------------------------------------------------------------------------------------------------------------------------------------------------------
find the issig and the repeating numbers
int arr[]={4,3,6,2,1,1}
given an rray of n integers and thee itegers are from 1to n
here repeating numbers is  1 and the msiisng numbers is 5
so the brute force will be for(int i=1;i<=n;i++)
{
int cnt=0;
for(int j=0;j<n;j++)
{
if(arr[j]==i)
{
cnt++;
}
if(cnt==2)
{
repeating =i;
}
if(cnt==0)
{
missing=i;
}
}
}
and time complexity will be o(n*n)

another can be we can tak hashmap or hasharray with size as n+1

 vector<int> findTwoElement(vector<int> arr, int n) {
        // code here
        vector<int>hashmap(n+1);
        int repeating=-1;
        int missing=-1;
        for(int i=0;i<n;i++)
        {
            hashmap[arr[i]]++;
        }
        for(int i=1;i<=n;i++)
        {
            if(hashmap[i]==2)
            {
                repeating=i;
            }else
            if(hashmap[i]==0)
            {
                missing=i;
            }
            if(repeating!=-1 && missing!=-1)
            {
                return {repeating,missing};
            }
        }
    }
};
here time complexity will be o(2*n) and space complexity will be of o(n)
*So here the time complexity will be the creating problem will be the o(n)
*consider the x as the repeating number and y as the missing number
*take the sum of all elements of the array as s
*then sum of all lemenets from 1 to n as asn
*then s-sn=wew 
*here s will come out as the repeating number and sn as the missing
**now to rduce the space complexity best thaing will be sum all numbers -sum of all n numbers ,where sum of all n numbers is n*(n+1)/2;
x-y=-4,where x is the sum of all all the elemnts in an array and y is the the sum of numbers of 1ton
* sum 
another is take sqyare and add thus
x^2-y^2=24
where x-y we have thus we wilget x+y;
and solving thex+y and x-y we will get x and y
vector<int> findTwoElement(vector<int> arr, int n) {
        // code here
     
     long long SN=(n*(n+1))/2;
     long long S2N=(n*(n+1)*(2*n+1))/6;
     long long S=0;
     long long S2=0;
     for(int i=0;i<n;i++)
     {
         S=S+arr[i];
         S2=S2+(long long)arr[i]*(long long)arr[i];
         
     }
     long long val1=S-SN;
     long long val2=S2-S2N;
     long long val3=val2/val1;
     long long x=(val1+val3)/2;
     long long y=val3-x;
     return {(int)x,(int)y};

------------------------------------------------------------------------------------------------------------------------------------------------------------
*count inversions
*int arr[]={5,3,2,4,1}
so we need to count the no of pairs{}
such that the {a[i],a[j]}were a[i]>a[j]and i<j
hence pairs can be {5,4},{5,3},{5,2},{5,1} then {3,1},{3,2},{2,1} hence 8
so brute forecwill be o(n*n) and space is o(1)

*for(int i=0;i<n;i+)
{
for(int j=i+1;j<n;j++)
{
if(a[i]>a[j])
{
cnt++;
}}
}
*so here the time complexity will be o(n*n) and space complexity will be o(1)
*so we will be given the 2 sorted array
*
*take array as [2,3,5,6] and another array as [2,2,4,4,8]
*how manypairs you{a[i],a[j]} you can make susch that the i is fro the left most sorted array and the righ element from the right most sorted array
here tak left=0 for iterating over this array1 which is  sorted and then right=0 over array 2 which is sorted
*our main aim is to find find a[left]>a[right] 
*Note:here we will see if condition check only then move both pointer ek saath else if false
*if not left++;
*
*next as we know we have no 2 arraus we ahve the one array we need to make it as the 2
*so we can think of the merge sort algorithm
*

*

public:
    // arr[]: Input Array
    // N : Size of the Array arr[]
    // Function to count inversions in the array.
    int merge(long long arr[],long long low,long long mid,long long high)
    {int count=0;
       vector<int>temp;
    long left=low;
    long right=mid+1;
    while(left<=mid && right<=high)
    {
        if(arr[left]<=arr[right])
        {
            temp.push_back(arr[left]);
            left++;

        }else{
            count=count+(mid-left+1);
            temp.push_back(arr[right]);
            right++;

        }
    }
    while(left<=mid)
    {
         temp.push_back(arr[left]);
            left++;

    }
     while(right<=high)
    {
         temp.push_back(arr[right]);
            right++;

    }
    for(int i=low;i<=high;i++)
    {
        arr[i]=temp[i - low];;
    }
    return count;

    }
    int mergesort(long long arr[],long long low,long long high)
    {int cnt=0;
        
        if(low>=high)
        {
            return cnt;
        long long mid=(low+high)/2;
       cnt=cnt+ mergesort(arr,low,mid);
          cnt=cnt+mergesort(arr,mid+1,high);
          cnt=cnt+merge(arr,low,mid,high);
          return cnt;
        
    }
    long long int inversionCount(long long arr[], long long N)
    {
        // Your Code Here
        return mergesort(arr,0,N-1);
    }

};
------------------------------------------------------------------------------------------------------------------------------------------------------------
reverse pairs*****-hard

int arr[]={40,25,19,12.9.6.2}
find pairs such that i<j amd a[i]>2*a[j]

hence possible pairs can be (6,2)
(9,2)
(12,2)
(19,2)
(25,2)
(40,2)
now brute force will take o(n*n)
so we are given the sorted array [6,13,21,25] and[1,2,3,4,4,4,5,9,11,13}
for this if we ask that can 
for I iterating over arr1 ad j iterating over array 2
if(arr1[i]>2*arr2[j])
{
6>1j++
6>2>j++//hence whie loop

}
and here e
{
i++;
}
bcz for 13 it will always contains 1 and 2




and solution for this is class Solution {
public:
    void merge(vector<int>& nums,int low ,int mid,int high)
    {
      
       vector<int>temp;
    long left=low;
    long right=mid+1;
    while(left<=mid && right<=high)
    {
        if(nums[left]<=nums[right])
        {
            temp.push_back(nums[left]);
            left++;

        }else{
           
            temp.push_back(nums[right]);
            right++;

        }
    }
    while(left<=mid)
    {
         temp.push_back(nums[left]);
            left++;

    }
     while(right<=high)
    {
         temp.push_back(nums[right]);
            right++;

    }
    for(int i=low;i<=high;i++)
    {
        nums[i]=temp[i - low];;
    }
    }
    int countreverse(vector<int>& nums,int low ,int mid,int high)
    {
        int count=0;
        int right=mid+1;
        for(int i=low;i<=mid;i++)
        {
           while(right <= high && static_cast<long long>(nums[i]) > 2 * static_cast<long long>(nums[right]))
    {
        right++;
    }
            count=count+(right-(mid+1));
        }
     return count;
    }
    int mergesort(vector<int>& nums,int low ,int high)
    {int count=0;
        if(low>=high)
        {
            return count;
            
        }
     int mid=(low+high)/2;
     count=count+mergesort(nums,low,mid);
     count=count+mergesort(nums,mid+1,high);
     count=count+countreverse(nums,low,mid,high);
     merge(nums,low,mid,high);
     return count;
     
     
    }
    int reversePairs(vector<int>& nums) {
        return mergesort(nums,0,nums.size()-1);
        
    }
};
------------------------------------------------------------------------------------------------------------------------------------------------------------maximum poduct subaaray
*int arr[]={2,3,-2,4}
and maxpsubarray=6;
so brute force will be
for(int i=0;i<n;i++)
{
for(int j=i;j<n;j++)
{\
prod=1;
for(int k=i;k<=j;k++)
{
//subaaray 
prod=prod=arr[k];
}
max=max(prod,max)
}



now 0(n*n) can be for(int i=0;i<n;i++)
{
prod=1;
for(int j=0;j<n;j++)
{\
prod=prod=arr[j];//as we are just multiplying one more to orginla
}max=max(prod,max)
}}


now the optimal solution will be one observable
*first scenario will be if all positive multiply all
*if even negative then 
multiply all elements
*if odd negative will make product negative so we will remove 1negative such that it become positive nad we can find maximum product subaaray in either suffix or prefix

*4th condition will be if contains 0
*
ex-int arr[]={2,3,-2,4}
so take pefix=-1;
suffix=n-i-1;
pref=pref*arr[i];
suf=suff*arr[i];

 if(pref==0)
{
pref=1;

}
 if(suff==0)
{
suff=1;

}
max=max(maxi,max(prefi,suffi)

#include<bits/stdc++.h>
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int prefsum=1;
        int suffixsum=1;
        int maxi=INT_MIN;
        for(int i=0;i<nums.size();i++)
        {
             if(prefsum==0)
            {
                prefsum=1;
            }
            if(suffixsum==0)
            {
                suffixsum=1;
            }
            prefsum=prefsum*nums[i];
            suffixsum=suffixsum*nums[nums.size()-i-1];
           
            maxi=max(maxi,max(prefsum,suffixsum));
        }
        return maxi;
        
    }
};
------------------------------------------------------------------------------------------------------------------------------------------------------------
binary search
it is a search algorithm in a limited searach space
*binary search is always performed when aray is sorted
*and its best example is when we open dictionary to find the word
*int arr[]={3,4,6,7,
9,1,2,16,17}
*so binary search space is whole array and to store the search space we use couple of variables so low,high and everything between low and high is the search space
*then find mid=low+high/2;
see if arr[mid]===target no if target<arr[mid] the the right after mid will not be search sspace and mid will also be not search space so high=mid-1
*so the code will be fn(arr,n,target)
{
int low=0;
int high=n-1;5
while(low<=high)//loop inssearch space
{
int mid=low+high/2;
if(arr[mid]==target)
{
return mid;
}else if(target<arr[mid]{
high=mid-1;
}else
{
low=mid+1;
}

}
}
return -1;//this is iterative code
*here the number of steps are same in a function which takes different values of low and high
*so basically fn(int arr,int low,int high)//we are reducing the search space
{
if(low>high)
{
return -1;
}//base case
int mid=low+high/2;
if(arr[mid]==target)
{
retun mid;}
else if(target<arr[mid])
{
 return fn(arr,low,mid-1)//function call and return sometging
}else
{
fn(arr,mid+1,high)
}
}therefore recursive calls is class Solution {
public:
    int bs(vector<int>& nums, int low,int high,int target)
    {
        if(low>high)
        {
            return -1;
        }
        int mid=(low+high)/2;
        if(nums[mid]==target)
        {
            return mid;
        }else if(nums[mid]<target)
        {
            return bs(nums,mid+1,high,target);
        }else
        {
            return bs(nums,low,mid-1,target);
        }
    }
    int search(vector<int>& nums, int target) {
      return bs(nums,0,nums.size()-1,target);
        
    }
};
*now time complexity is for 32 length search space reduces to 16 to 8 to 4 to 2 to 1 in 6 steps that is 2 to power 5 is 32 and hence 6 is logn(32) kind of 
*suppose low=0;and high=INT_MAX so int mid=low+high/2;
suppose low==high then int mid cant store 2*int_max so use long long mid and case called overflow case another alternative without using mid as long long is 
int mid=low+(high-low)/2;
------------------------------------------------------------------------------------------------------------------------------------------------------------
lower bound
*the smallest inex such that arr[index]==target or arr[inddx]>target
*for lower bound to be implemented
int arr[]={3,5,8,15,19} target=8
so 8 >=8 and also smallet index,so smallet index is 2
suppose if target would be 9 then the 15>=9 so smallest index will be 3
*note that if no lowr bound found still binds ti 
*so basically if (arr[mid]>=x)
{
}//this might be a answer so ans=mid;
high=mid-1;
else{
low=mid+1
}



 // Your code here
        int ans=n;
        int low=0;
        int high=n-1;
        while(low<=high)
        {
            int mid=(low+high)/2;
            if(v[mid]>=x)
            {
                ans=mid;
                 high=mid-1;//smallest index
               
               
            }else
            {
                 low=mid+1;
            }
        }
        return ans;

but in coding rounds ensure that int l=lower_bound(arr.begin(),arr.end(),x)//this will return the iterator so subtract-arr.begin()
*so the time complexity will be 0(logn)
*upperbound-greater index but number greater than  x not equals to
*int ans=n;
        int low=0;
        int high=n-1;
        while(low<=high)
        {
            int mid=(low+high)/2;
            if(v[mid]>x)
            {
                ans=mid;
low=mid+1;

                 
               
               
            }else
            {
                 high=mid-1;

            }
        }
        return ans;
*-----------------------------------------------------------------------------------------------------------------------------------------------------------
search insert positions
*given the sorted array
*if element find in array then return index else if not found in array find the index where it can be inserted to maintain the sorted order
*int arr[]={1,2,4,7}

x=6;
so it must be inserted at 3 position its just same as saying find the lowerboind
*  
-----------------------------------------------------------------------------------------------------------------------------------------------------------
remenber 
floor is the eement in ana array<=x butthe element must be the larget
cei is the element in an array which is greater ha >=x but heta element must be he smallests
*class Solution {
public:
    vector<int> getFloorAndCeil(vector<int> nums, int x) {
        int floor = -1, ceil = -1;
        int low = 0, high = nums.size() - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (nums[mid] == x) {
                floor = ceil = x;
                break;
            } else if (nums[mid] < x) {
                floor = nums[mid]; // Potential floor
                low = mid + 1;
            } else {
                ceil = nums[mid]; // Potential ceil
                high = mid - 1;
            }
        }

        return {floor, ceil};
   
    }
};in one binary searh
------------------------------------------------------------------------------------------------------------------------------------------------------------
first and the last occurrence of x
*it arr[]={2,4,6,8,8,8,11,13}
imagine i give you x=8 so the indexis 2 and 5 s return {3,5}
*so if x=11 then first and last will be the {6,6}
*so brute force will be do inear searchand take 2 variable first and last=-1;
*traverse as soon as first is 8 then first=3 and last will be also 3,always update checking fir
*st==-1 and last ==-1 to check first update
*then traverse continue again if 8==target and first !=-1 then last=i;//only update the last
*so lower bound is smallest number>=x and upper bound is greatest number >x
*so lowest index will be lower_bound and greatest index is upper_bound-1
*edge case suppose target=10 then lowerbound=11 index which should not be therese so lower_bound(x) and chack arr[lowerbpund]!=x and if arr[lower_bound]!=n
*#include<bits/stdc++.h>

class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int lb=lower_bound(nums.begin(),nums.end(),target)-nums.begin();
        if(lb==nums.size()|| nums[lb]!=target)
        {
            return {-1,-1};
        }
        int ub=upper_bound(nums.begin(),nums.end(),target)-nums.begin();
        return{lb,ub-1};
        
    }
};
*now writing this code from scratch findfirstoccurence(vector<int>arr,int n,int k)
{
int low = 0, high = n - 1;
int answer = -1;

while (low <= high) {
    int mid = low + (high - low) / 2;

    if (arr[mid] == target) {
        answer = mid;
        high = mid - 1;  // Search left for first occurrence
    } 
    else if (arr[mid] > target) {
        answer = mid;    // This could still be a valid lower bound
        high = mid - 1;
    } 
    else {
        low = mid + 1;
    }
}

findlastoccurence(vector<int>arr,int n,int k)
{
int low=0;
int high=n-1;
while(low<=high)
{
int mid=low+high/2;
if(arr[mid]==x)
{
last=mid;
low=mid+1
}//can be ans and move toward left to get lease;
else if(arr[mid]>target
{
answer = mid;
low=mid+1;
}else
{
high=mid-1

}
}
*
------------------------------------------------------------------------------------------------------------------------------------------------------------
count the number of occurences of x
so last occurrence -first ocuurence +1
*
------------------------------------------------------------------------------------------------------------------------------------------------------------


search element in the rotated sorted array
*we are given an array and its rotated sorted array 
suppose arr[]={1,2,3,4,5,6}
*and then we stand at 4 and rotate it 4 then array will be [4,5,6,,1,2,3]
*now suppose int arr[]={7,8,9,1,2,3,4,5,6,} and we need to search for the target that is 1
*first part is solve for the unique elements
*suppose target=8 then the mid=5 as arr[4]>target no thus low=mid+1 we will search in right part but we cant trust blindlyas the here the left[part is not sorted
*so we will dnetify the sorted part and then find if target lies between hem or nt
*
*so first thing we will do is identify the sorted part in which target can be present
*consider target as 1 then  then check which is sorted part as arr[0] is not less than arr[mid] so the right part is sorted\
*do a check that 1 lies between 2 and the last if not then eleiminates this part and then high=mid-1
*class Solution {
public:
    int search(vector<int>& nums, int target) {
        int low=0;
        int high=nums.size()-1;
        while(low<=high)
        {
            int mid=(low+high)/2;
            if(nums[mid]==target)
            {
                return mid;
            }//left sorted
            if(nums[low]<=nums[mid])
            {
                if(nums[low]<=target&& target<=nums[mid])
                {
                    high=mid-1;
                }else
                {
                    low=mid+1;
                }
            }else
            {
                if(nums[mid]<=target&& target<=nums[high])
                {
                    low=mid+1;
                }else
                {
                    high=mid-1;
                }
            }
            
        }
        return -1;
    }
};
*note here 0+3/2=1 meana floor values
*so this case is first identify the sorteda nd serach for th value if present then fins else low=mid+1
------------------------------------------------------------------------------------------------------------------------------------------------------------
nneds to do 
search in rotaed array 2-duplicates
*
int arr[]={7,8,1,2,2,3,3,3,4,5,6}

target=3 and we dont need to return the index we nsed to return the true or false
*consider the array as [0,7,1,2,3,4,4,5]
*here mid is 3 index so 2<=5 hence 3 lies  in between easily identify the sorted part
*we cant use the above approach here as consider int arr[]={3,1,2,3,3,3,3}
here arr[mid]=3 now here we cant identify which is sorted as arr[low]<=arr[mid] and arr[mid]<=arr[high]
*as arr[low]==arr[mid]==arr[highh] we are not able to find the sorted part
*
*now if i trim down the condition that arr[low]=arr[mid]=arr[high]
*so if arr[mid]!=target that we check at the first nor will be arr[low] so low-- so is high-- so continue to get the mid
*

class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int low=0;
        int high=nums.size()-1;
        while(low<=high)
        {
            int mid=(low+high)/2;
            if(nums[mid]==target)
            {
                return true;
            }//else
            if(nums[low]==nums[mid]&&nums[mid]==nums[high])
            {
                low=low+1;
                high=high-1;
                continue;
                
            }//left sorted
            if(nums[low]<=nums[mid])
            {
                if(nums[low]<=target&& target<=nums[mid])
                {
                    high=mid-1;
                }else
                {
                    low=mid+1;
                }
            }else
            {
                if(nums[mid]<=target&& target<=nums[high])
                {
                    low=mid+1;
                }else
                {
                    high=mid-1;
                }
            }
            
        }
        return false;
        
    }
};
-----------------------------------------------------------------------------------------------------------------------------------------------------------
find minmum in rotated sorte array
*given arr[]={4,5,6,7,0,1,2}
*so here initially it was {0,1,2,4,5,6,7}
*now it was rotated at pivot 4 and from pivot all after rigjt including 4 conmes at front
*so here 4 is the pivot
*so here the brute force will be of the finding of the minimum
*and that finding of minimum takes 0(n)
*first fugure outthe sorted part
*now here mid=3 that is element 7 so the lef half is sorted
*here left half is  sorted  b
*now ths sorted part may or mayntcontain the minimum
*so here right part is not sorted because its right part contains the point of roattion and hence notsorted and contais minimum
*but see the exmaple=[4,5,1,2,3]
*so here the mid=2 here right part is sorted but left half does no contain minimum instead the right half contains
*so we can say that the sorted part might have the answer or not
*so we will pick the minimum from sorted part and eliminated
*
*
*so take the minimum of this store it as it can contain and if not contains then low=md+1//if left one is sorted array
*else oif right then store then minim high=mid-1;


class Solution {
public:
    int findMin(vector<int>& nums) {
        int low=0;
        int ans=INT_MAX;
        int high=nums.size()-1;
        while(low<=high)
        {
            int mid=low+(high-low)/2;
            if(nums[low]<=nums[mid])
            {
                ans=min(ans,nums[low]);
                low=mid+1;

            }else
            {
ans=min(ans,nums[mid]);
                high=mid-1;
            }
        }
        return ans;
        
    }
};
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
find the minimum in sorted arry 2 hich contains duplicates

class Solution {
public:
    int findMin(vector<int>& nums) {
         int low=0;
        int ans=INT_MAX;
        int high=nums.size()-1;
        while(low<=high)
        {
            int mid=low+(high-low)/2;
            if(nums[low]==nums[mid]==nums[high])
            {
                ans=min(ans,nums[low]);
                low=low+1;
                high=high-1;
                continue;
            }
            if(nums[low]<=nums[mid])
            {
                ans=min(ans,nums[low]);
                low=mid+1;

            }else
            {
ans=min(ans,nums[mid]);
                high=mid-1;
            }
        }
        return ans;
        
    }
};
------------------------------------------------------------------------------------------------------------------------------------------------------------
find out how many times has an array has been rotated and these contains unique elements
*
*int arr[]={3,4,5,1,2}
*so iniial it was [1,2,3,4,5] and it has been rottaed 3 
*so here if we can keep track of the minim array index that manytimes the array is rotated
*this is we can find the minimum and return the index of minimum 

	int findKRotation(int arr[], int n) {
	    // code here
	    int low=0;
	    int index=-1;
        int ans=INT_MAX;
        int high=n;
        while(low<=high)
        {
            int mid=(low+high)/2;
            if(arr[low]<=arr[mid])//left sported store minimum and move
            {
                if(ans>=arr[low]){
               ans=arr[low];
               index=low;
                low=mid+1;
                }
            }else//right sorted store minimum and move
            {if(ans>=arr[mid]){
                ans=arr[mid];
                index=mid;
                 high=mid-1;
                
            }
                
             
            
                
            }
        }
        return index;
	}
------------------------------------------------------------------------------------------------------------------------------------------------------------
*single elemnt in an sorted array
*int arr[]={1,1,2,2,3,3,3,4,,5,5,6,6,6}
*here most of the element is  appears atleasttwice nd all appearin the 2 will be adjacent
*it is guarantee there is one element appeared once and all other appeared twice
*Note:here the element is in sorted order
*Note:guarnteed all elements will be twice and adjacent
*Note:one element is once
*note:means at random index i elemen it is single if at right it doesnot have the exat element and not at left if any then that element is not single
*so according to first condition that the if standing at any index,if its elements is appearing twice than duplicate element mus be at i+1 or the i-1
*if single then on bith side no duplicates will be present
for(int i=;i<n;i++)
{
if(arr[i+1]!=arr[i]&&arr[i-1]!==arr[i])//single
{
single=arr[i];
break;
}//at middle 
at starting if(i==0)
{
if(arr[i]!=arr[i+1]
{single=arr[i];
break;
}
at last
if(i==n-1)
{
if(arr[i]==arr[i-1)
{
single=arr[i];
break;

}
}
}
}

time complexity will be o(n)
*
lets take(1,1)here first one is at even and second at odd index sme with 2,2 and 3,3 but 5,5 we have first odd then even
*so we ot if we are standing on the even index and t the riht we have same element than we are standing at the left half of single element
*and if we are sanding at the odd index and towards its right we ahve same element measn we are standing at the right half of the single element
*so we can say(even,odd) then we are standing at left half of element and element is at right half
*and if odd,evene we are the right half and single elmenet is at the left half
*so the code start if n==0 return arr
*if arr[0]!=arr[1] return arr[0]
*if arr[n-1]!=arr[n-2]
* then chack single elemenet condition
*then we need to eleiminiate so alwats eliminate where single element is not prsesnt
*not how tochcek if element not present in which half so check if midd is odd index and check hwre same element lies as its left and left is even index so eleminatethe left hald
*or if mid is even index nd its next elemeny is same then also eliminate the left half
*
*if evene we are left half so element this left and move to next 
*class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        if(nums.size()==1)
        {
            return nums[0];
        }
        if(nums[0]!=nums[1])
        {
            return nums[0];
        }
        if(nums[nums.size()-1]!=nums[nums.size()-2])
        {
            return nums[nums.size()-1];
        }
        int low=1;
        int high=nums.size()-2;
        while(low<=high)
        {
            int mid=low+(high-low)/2;
            if(nums[mid]!=nums[mid+1]&&nums[mid]!=nums[mid-1])
            {
                return nums[mid];
            }
            if((mid%2==1 && nums[mid]==nums[mid-1])|| (mid%2==0&&nums[mid]==nums[mid+1]))
            {
                low=mid+1;

            }else
            {
                high=mid-1;
            }
        }
        return -1;
        
    }
};
----------------------------------------------------------------------------------------------------------------------------------------------------------
find the peak element
*an element with standing  at  aarr[i]>arr[i-1] &&arr[i]>arr[i+1]
*int arr[]=[1,2,3,4,5,6,7,8,5,1] here we have 8 where the curve is decreasing so we have the peak elemnts as 8
*
*int ar[]={1,2,1,3,5,6,4]
it has 2 peaks 2 and 6
*int arr[]=[1,2,3,4,5]
*and it has peak 5 as the question take - infinity before arrya and infinitity at the after array end
*
*and for 1st or last elemnt to be peak conside before first element is -infinity and after the last lemmnt as infinity
*firstly brute force will be 0(n)
*so here its not sorted but kind of sorted tendency as some part is sorted and some are not
*so lets first solve for thr one peak take the example as int arr[]=[1,2,3,4,5,6,7,8,5,1]
*so remember if there is one element than that element will be peak return that
*so steps will be find mid check if it can be peak if not
*and if its greater than its left menas its increasing and the peak will be toward righ
*class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        if(nums.size()==1)
        {
            return 0;
        }
        if(nums[0]>nums[1])
        {
            return 0;
        }
        if(nums[nums.size()-1]>nums[nums.size()-2])
        {
            return nums.size()-1;
        }
        int low=1;
        int high=nums.size()-2;
        while(low<=high)
        {
            int mid=low+(high-low)/2;
            if(nums[mid]>nums[mid+1]&& nums[mid]>nums[mid-1])
            {
                return mid;
            }else if(nums[mid]>nums[mid-1])
            {
                low=mid+1;
            }else
            {
                high=mid-1;

            }
        }
        return -1;
        
    }
};
*so this is for the single peak
*now for multiple peaks
*same code condition works
*but in multiple peaks ther can be mountains drop down condition where arr[mid]<arr[mid+1] and arr[mid]<arr[mid-1] so for that you can elemei any part
*so for multiple peaks just 
int findPeakElement(vector<int>& nums) {
        if(nums.size()==1)
        {
            return 0;
        }
        if(nums[0]>nums[1])
        {
            return 0;
        }
        if(nums[nums.size()-1]>nums[nums.size()-2])
        {
            return nums.size()-1;
        }
        int low=1;
        int high=nums.size()-2;
        while(low<=high)
        {
            int mid=low+(high-low)/2;
            if(nums[mid]>nums[mid+1]&& nums[mid]>nums[mid-1])
            {
                return mid;
            }else if(nums[mid]>nums[mid-1])
            {
                low=mid+1;
            }else if(nums[mid]>nums[mid+1])
            {
                high=mid-1;

            }
high=mid-1;//just this change
        }
        return -1;
        
    }
};

-----------------------------------------------------------------------------------------------------------------------------------------------------------
find the square root of an integer
*square root of 25 is 5
*square root of 35 is 5. sometging when converted to floor will be 5 so return the floor value
*note :first thing we know the range and another thing is find miin or max means some can be possible ans and some cant be  we will always apply binary search 
*
*so naive solution an be for(int i=1;i<=n;i++)
{
if(i*i<=n)
{ ty
ans=i;//as we need the floor value
}else
{
break;
}
}

here when we need to find the square root of 25  here 1 ,2 3,4 ,5 can be ans and 6,7,8,9 will not be ans when these time of problem s arise always apply binary serach
*
so int low=1;
int high=n;
while(low<=high)
{
int mid=low+high/2;
if(mid*mid<=n)
{
ans=mid;
low=mid+1;
}else
{
high=mid-1;
}

}

return ans or high both are correct

note:if we know range and then find the min or max through this we know some are ans and some cant be so use binary search there.
------------------------------------------------------------------------------------------------------------------------------------------------------------
from here


*find the nth root of an integer
* so by linear seacrch
*suppose m is an integer then the for we need to find the nth root of m
for(int i=1;i<=m;i++)
{
for(int j=0;i<n;j++)
{
prod=prod*i;
}
if(prod==m)
{
cout<<i;
}
if(prod>m)
{
break;
}
}
therefore the complexity will be o(m*logn)whre logn is the methd to find the power
*so suppose the n=4 and m=69 
so 1*1*1*1=1 less
then low=mid+1;
same for 2 ,for for 3*3*3*3 greater than 69 hence ight of the 3 cant be answer but left can conatin so high=mid-1;

	int func(int mid,int n,int m)
	{
	    long long ans=1;
	    for(int i=1;i<=n;i++)
	    {
	        ans=ans*mid;
	         if(ans>m)
	        {
	            return 2;
	        }
	    }
	    if(ans==m)
	    {
	    return 1;
	    }
	    return 0;
	}
	int NthRoot(int n, int m)
	{
	    // Code here.
	    int low=1;
	    int high=m;
	    while(low<=high)
	    {
	        int mid=(low+high)/2;
	        int midn=func(mid,n,m);
	        if(midn==1)
	        {
	            return mid;
	        }else if(midn==0)
	        {
	            low=mid+1;
	        }else
	        {
	            high=mid-1;
	        }
	    }
	    return -1;
	}  
------------------------------------------------------------------------------------------------------------------------------------------------------------
koo eating bananas
*we aree given an array of piles
*in aray we have n piles
*on each piles we have the certain amount of bananas
*int piles[]={3,6,7,1}//on the first piles is 3 bananas,on the secnd is the 6 bananas
*we are given a parameter h as which is no of hours h=8;
*koko needs to eat bananas in the fast manner
*but the max time koko can take is 8
*we have to return the minimum integer k where k is basically the no of bananas per hour such that he can at all bananans with h hpurs
*let k=2 banana per hours then for arr[0] the time is 3 ideally 1.5 but ceil value taken then 2
*so taotal hours will be 15 whixh is more than the 8 hours
*so take 4 banasas/per hours
*so letting bananas/hours can go from 1 to the max element in an array
int fn(int arr,int hours)
{
int ttalhrs=0;
for(int i=0;i<n;++)
{
totalhours=totalhours+cei(arr[i]/hours);
}
return totalhours

}
*so the brute force sol will be for(int i=1;i<=maxelem;i++)
{
timespent=fn(arr,i);
if(timespent<=h)
{
return i;//which will be minimum
}
}
so here 1not possible.2 not possible,3 not possible and 4 possible,5 possible

for int low=1;
int high=maxelemet;
while(low<=high)
{int mid=low+high/2;
timespent=fn(arr,mid);
if(timespent<=h)
{
ans=mid;
high=mid-1;//minimum
}else
{
low=mid+1;//towards right
}

}



correct code is class Solution {
public:
    int findmax(vector<int>& piles)
    {
        int maxi=INT_MIN;
        for(int i=0;i<piles.size();i++)
        {
            if(maxi<piles[i])
            {
                maxi=piles[i];
            }
        }
        return maxi;
    }
    int func(vector<int>& piles, int hours)
    {
        int totalhours=0;
        for(int i=0;i<piles.size();i++)
        {
            totalhours=totalhours+ceil((double)piles[i]/(double)hours);
        }
        return totalhours;
    }
    int minEatingSpeed(vector<int>& piles, int h) {
        int low=1;
        int ans=0;
       
        int high=findmax(piles);
        while(low<=high)
        {
            int mid=(low+high)/2;
            int timespent=func(piles,mid);
            if(timespent<=h)
            {
                ans=mid;
                high=mid-1;
                
            }else
            {
                low=mid+1;
            }
            
        }return ans;
        
    }
};
//here the thing is ess tha the given hours then high=mid-1;

------------------------------------------------------------------------------------------------------------------------------------------------------------

minmnumber of bouquets
*we are given the arr of days where days are the noof days in which flowers will bloom
* int arr]={7,7,7,7,13,11,12,7}
*here 0th ndex flower means i will bloom on the 7 th day
*we have to retun the minimum no of days to make m bouquets with k numbers of consecutive flowers
*now to make the bouquet my flowers mst ave bloomed
*lets take the no of days as 13 ie the maxelement then the all flowers must haave bloomed and we can make m bouquets hence it can be the answer
*if we take 7h days then we cant make 2 bouquets as 3 consecutive flowers cant be made
*if we take 12th days still we can make the m bouquets with k consecutive flowers
*if we take 11 then no and also below that no so here we know range and then for some ans can be possible and for some cant be
*so to return -1 we have to if m*k >n where n is th no of element in an array,return -1
*so the low will be the minimum element in an array and the high will be the max element in array
*so lets take mid as 7 suppose then int cnt=0;
iterate over tge array and take those which are ==arr[i] or less then arra[i],then for those only cnt++ ,else we need to make cnt =0;but before that cnt no of bouquets tiil ehre so 4/2=1 then cnt==0;and and for the last after iteration again the cnt of bouquets ,outside the iterating loops check if the number of bouquets if less then that day cant be possible need to taje different days
*func(arr,day,m,k)
{
for(int i=0;i<n;i++)
{

if(arr[i]<=day)
{
cnt++;
}else
{
cntbqt=cntbqt+(cnt/k);
cnt=0;

}
}
cntbqt=cntbqt+(cnt/k);
if(cntbqt<m)
{
return false;
}else
{
return true;
}

int low=min;
int high=max;
while(low<=high)
{
int mid=low+high/2;
if(func(arr,mid,m,k)==true)
{
ans=mid;
high=mid-1;
}else
{
low=mid+1;
}
}






code correct class Solution {
public:
    int min(vector<int>& bloomDay)
    {
        int mini=INT_MAX;
        for(int i=0;i<bloomDay.size();i++)
        {
            if(mini>bloomDay[i])
            {
                mini=bloomDay[i];
            }
            
        }
        return mini;
    }
     int max(vector<int>& bloomDay)
    {
        int maxi=INT_MIN;
        for(int i=0;i<bloomDay.size();i++)
        {
            if(maxi<bloomDay[i])
            {
                maxi=bloomDay[i];
            }
            
        }
        return maxi;
    }
    bool fun(vector<int>& bloomDay,int mid, int m, int k)
    {
        int cnt=0;
        int cntbqt=0;
        for(int i=0;i<bloomDay.size();i++)
        {
            if(bloomDay[i]<=mid)
            {
                cnt++;
                
            }else
            {
                cntbqt=cntbqt+cnt/k;
                cnt=0;
                
            }
        }
        cntbqt=cntbqt+cnt/k;
        if(cntbqt<m)
        {
            return false;
        }else
        {
            return true;
        }
    }
    int minDays(vector<int>& bloomDay, int m, int k) {
        int low=min(bloomDay);
        int ans=0;
        int high=max(bloomDay);
        if(m*k>bloomDay.size())
        {
            return -1;
        }
        while(low<=high)
        {
            int mid=(low+high)/2;
            if(fun(bloomDay,mid,m,k)==true)
            {
                ans=mid;
                high=mid-1;
            }else
            {
                low=mid+1;
            }
            
        }return ans;
        
        
    }
};
//here if the no of bouquets is greater than or equal to given than high=mid-1;
*here minmum will be the minium element in an rray and max will be the max element in an array
*
------------------------------------------------------------------------------------------------------------------------------------------------------------
least capacity to ship packages within d days
*given arr[]={1,,3,4,5,6,7,8,9,10} days=5;
we have a ship consisting of n item here n is 10 items
*each item has weight as 0th item as wight as 1kg,1st item has weight as 2 kg
*ship can run once in a day
*we have to to load these items in the ship so that these total can be shipped in 5 days
*we have to tell the what least capacity should be loaded in ship so that all item can be shipped in 5 days
*lets take capacity as 100 then days taken is 1 to ship all item s but needs minimum
*10 then numner of days taken is greater so move for days greater than 10
*than 15 is the day whre no of days is 5 exactly nad below that no f days grater than 5 so no answer bwlow th e15 days and above it there are answers 


now here the range of days is from min=maxelement in an array
max=summation of all wieighs
and below15 days not possible to be taken of 
so here binary search can be applied      


*so brute force will be for(int i=min;i<=max;i++)
{
int returndays=fn(wights,i);
if(return days<=dys)/as we are movng from front
{
return i}
}

*fn(wights,int mid)
{
it days=1;//
it load=0;for(int i=0;i<n;i++)
{
if(load+weigt[i]>mid)//this need to be doe before adding weight in load 
{
days=days+1;
load=weight[i];
}else
{
load=load+weight[i];
}
}
retrn days;

}



so optialsoltion willl be binary search
*class Solution {
public:
    int max(vector<int>& weights)
    {
        int maxi=INT_MIN;
        for(int i=0;i<weights.size();i++)
        {
            if(maxi<weights[i])
            {
                maxi=weights[i];
            }
        }
        return maxi;
        
    }
    int sum(vector<int>& weights)
    {
        int sum=0;
         for(int i=0;i<weights.size();i++)
        {
           sum=sum+weights[i];
        }
        return sum;
        
        
    }
    int func(vector<int>& weights, int mid)
    {
        int day=1;
        int load=0;
        for(int i=0;i<weights.size();i++)
        {if(load+weights[i]>mid)
        {
            day=day+1;
            load=weights[i];
        }else
        {
            load=load+weights[i];
        }
            
        }
        return day;
        
    }
    int shipWithinDays(vector<int>& weights, int days) {
        int low=max(weights);
        int high=sum(weights);
        int ans=0;
        while(low<=high)
        {
            int mid=(low+high)/2;
            int returndays=func(weights,mid);
            if(returndays<=days)
            {
                ans=mid;
                high=mid-1;
            }else
            {
                low=mid+1;
            }
        }
        return ans;
        
    }
};
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
find the samllest divisor given a threshold
*given int arr[]={1,2,5,9}
*and threshold=6;
*supoose take divior as 4 then didvide each element by 4 then take ceil and add 1+1+2+3=7 which is not less than 7
*take that as 5 thena 1+1+1+2 which is less than 6 can be nas
*so 1,2,3,4 not possible 5,6 possible so here we know ranges and then the possible answers so binary search will be applied
*so minimum will be 1 and high can b max element in an array
*so the brute force solution will be for(int i=1;i<=max(arr);i++)
{
int sum=0;
for(int j=0;i<ar.size();i++)
{
sum=sum+arr[j]/i;
}
if(sum<=threshold)
{
return i;
}
}

so time complexity will be o(n*n)


class Solution {
public:
    int max(vector<int>& nums)
    {
        int maxi=INT_MIN;
        for(int i=0;i<nums.size();i++)
        {
            if(maxi<nums[i])
            {
                maxi=nums[i];
            }
        }
        return maxi;
    }
    int func(vector<int>& nums, int mid)
    {
        int ans=0;
        for(int i=0;i<nums.size();i++)
        {
            ans=ans+ceil(double(nums[i])/double(mid));
        }
        return ans;
    }
    int smallestDivisor(vector<int>& nums, int threshold) {
        int low=1;
        int ans=0;
        int high=max(nums);
        while(low<=high)
        {
            int mid=(low+high)/2;
            if(func(nums,mid)<=threshold)
            {
                ans=mid;
                high=mid-1;
            }else
            {
                low=mid+1;
            }
        }
        return ans;
        
    }
};
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
kth missing positive integer
given an arry[]={2,3,4,7,11}
all numbers in arary are between 1 and the max element in array
1,2,3,4,5,6,7,8,9,10,11 first first number is 1,5,6,8,9 so if k=5 then missing kth number is 9
*consider array as nt arr[]={5,7,10,12}
*then the if i say find he 6th missing positive integer then iteate find 5 which is smaller so here if(arr[i]k<) then the k+1 will be answer
*consider take k=6 then the iterate 5 <6 thus mke the k as 7 here arr[i]=<k so here k is now 8  and hence 8 is the answer
*so brute force solution will be for(int i=0;i<n;i++)
{
if(arr[i]<=k)
{
k++;
}else
{
break;
}
}
return k;
*
*so here time complexity will be 0(n)
*now we want more optimized solution so o(logn) we will use the binary search

*now consider int arr[]={2,3,4,7,11} and k=5,the  answer is 9,then the and its lies between the 7 and 11
*so our first task is to find out the indexes between which our ans lies
* so at 7 ideally i+1 musy be present hence numbet missing are 7-4=3numbers are missing 
*and at 11 must be 5 hence number mssing are 11-5=6 numbers are mssin and we re loking for 5 th numbers
*so we needs binary search first for the k=5h mans between the missing numbers
int low=0;
int high=n-1;
while(low<=high)
{
int mid=low+hj/2;
int missing=arr[mid]-(mid+1);
if(missing <k)
{
low=mid+1;
}else
{
high=mid-1;
}


}
*sonow low <high
*so number will be arr[high]+more whre more=k-missing where missing is arr[high]-(high+1);
so formulae for number will be high+1+k;



class Solution {
public:
    int findKthPositive(vector<int>& arr, int k) {
        int low=0;
        int high=arr.size()-1;
        while(low<=high)
        {
            int mid=(low+high)/2;
            int missing=arr[mid]-(mid+1);
            if(missing<k)
            {
                low=mid+1;
            }else
            {
                high=mid-1;
             }
        }
        return high+1+k;
        
    }
};
------------------------------------------------------------------------------------------------------------------------------------------------------------
aggressive cows
*as previously we have the binary search on answer where we need to find the minimum or max
*now there is second category of questions we have to find mi of max r max of min
*so the question is we have int arr=[0,3,4,7,10,9]
*basically we have n stll where n is the size of array
*and each stall position is given
*we have o place k=4 cows and each cows and be placed frm 0 t0 4-1
*but the minimum distance between the 2 cows must be max
*so lets forst sort itso arr will become int ar[]={0,3,4,7,9,10}
*and we place cow at 0,1,2,3
*so the distance between the ows are 3,1,3,3,7,4
*ans the min is 1
*and this minum is always beteen the consecutive cows
*similary if we place at 0,2,4,5 then the distance is minimum s 1
*similary if we place aat the 0,2,3,5 minimum distance is 3
*Note:minimum will be akways between the consecutive
*now thre are different configuration to find the min
*we need to maximize the min so the max is 3
*so lets take the mini as 1 then cow 1 placed at 0 index and we need to have the minimu distance as 1 so second w can nbe placed at the 1 index as 1<=3 then th second cow can be placed at the 2 index as 1<=1
*so lets take the min as the 2 then at index 0,1 and third cow ca be put at 2 as 2<=1 thenthe tird cow can be out as 3 index as 2<=4 then the 4 cow can be place 4
*so wih 3 also can be placed 4 cows
*so after he 4 answers is not possible 
*Note:we will always be given 2 cows
*so the minimum distance ranges from 1 to max-min
*max-min i w have the 2 cows
*So here brute forc will be the for(int i=1;i<mx-min;i++)
{
if(canweplace(arr,i,cows)
{
continue
}else
{
return i-1;
}

}
*canweplace(arr,dist,cows)
{
int cntcowsinternal=1;
int lst=arr[9];
for(inti=1;i<n;i++)
{
if(arr[i]-last>=dist)
{cntcowsinternal++;
lat=arr[i];
}
}
if(cntcows>=cows)
{
return true}else
{
return false
}
}



Hence the optimal solton will be class Solution {
public:
bool canWePlace(vector<int> &nums,int dist, int k)
{
    int last=nums[0];
    int count=1;
    for(int i=0;i<nums.size();i++)
    {
        if(nums[i]-last>=dist)
        {
            count++;
            last=nums[i];
        }
    }
    if(count>=k)
    {
        return true;
    }else{
        return false;
    }
}
    int aggressiveCows(vector<int> &nums, int k) {
        int low=1;
        sort(nums.begin(),nums.end());
        int high=nums[nums.size()-1]-nums[0];
        int ans=0;
        while(low<=high)
        {
            int mid=low+(high-low)/2;
            if(canWePlace(nums,mid,k)==true)
            {
                ans=mid;
                low=mid+1;
            }else
            {
                high=mid-1;
            }
        }
        return ans;
        
    }
};
-----------------------------------------------------------------------------------------------------------------------------------------------------------
*book allocation problem------again-----again unerstand
*given int arr[]={25,46,28,49,24}
*we will be given n books  where i th book contains x pages so 0 h book contains 25 pages,1 st book contains 46 books

*we will be given students=4;
*weneed to allocate books to students such that each student must get atleast one book and 
and one books only gven to one stuent an
 book alcation to student mstbe in continous manner
*so return -1 wil
l take place when the no of books is greater than the no of students
*so 25/46/28/49,24->here maximum will be 73 if we arrange books in this order
*so 25/46/28,49/24 here maximum is 77
*so 25/46,28/49/24 here maximum number of pages are 74
*so 25,46/28/49/24 here maximum number of pages are 71
consider max is 49 that is max element in array we are taking moer student so we nnned to increase it
*so here the find mini will be max eleme s in an array na dthe max will the sum
*so here finding min is target for that find all max
* 
*for(int i=max;i<=sum;i++)
{
if(func(arr,i}===m)
{
return i;
}
fuc(arr,pages)
{
in std=1;
int reele=0;
for(inti=0;i<n;i++)
{
if(presele+arr[i]<=pages)//before adding must be samller tah the pages
{
prese=prese+arr[i];
}else
{
std++;
preele=arr[i];
}
}
return cnt;

nowfor biary search if my nt is less than means to have more students we nend todown the barrier high=mid-1;else low=mid+1;
*return low; for the max as it exceeds the high


#include<bits/stdc++.h>
int func(vector<int>& arr,int pages)
{
    int  std=1;
    long long presum=0;
    for(int i=0;i<arr.size();i++)
    {if(presum+arr[i]<=pages)
    {
        presum=presum+arr[i];
    }else{
        std++;
        presum=arr[i];
    }
    return std;

    }
}
int findPages(vector<int>& arr, int n, int m) {
    if(m>n)
    {
        return -1;
    }
    int low=*max_element(arr.begin(),arr.end());
int high=accumulate(arr.begin(),arr.end(),0);
while(low<=high)
{
    long long mid =(low+high)/2;
    int count=func(arr,mid);
    if(count>m)
    {low=mid+1;
       
    }else
    {
        
         high=mid-1;
    }
}
return low;
    // Write your code here.
}


------------------------------------------------------------------------------------------------------------------------------------------------------------
split array largest sum/painter partition----agan
same as the allocate books/painte partitions
------------------------------------------------------------------------------------------------------------------------------------------------------------
Minimize the max distance togas sation---again
*int arr[={1,2,3,4,5}
*we are given array wich consist of coordinates of 5 gas stations
*we have to place k=4 gas stations
*we have to minimise the maxdistance beteen the gas stations
*so we ned to inserts the gas station between th lements
*if i plaace the new nexy gas station on coordinates 6,7,8,9
*[1,2,3,4,5,6,7,8,9] and here the max distance between them is 1 and hence the minimum ndistance between the array is 1
*[1,1.25,1.5,1.75,2,3,4,4.5,5] so here the max distance is 1 and minimum is 1
*[1,1.5,2,2.5,3,3.5,4,4.5,5] here the max distance is the 0.5 and minimum distance is 0.5
*so here the minimum distance is 0.5
*int arr[]=[1,7] and k=2
*if we put [1,7,8,9] here max distance is 6  are we reducing the max distance no 
*so the right extreme part is not good
*so we need to place them in between so [1,2 4,7] so here the distance between them 1,2,3 ma
x is 3 but here we are not reducing as here max is not minimized between the consecutive distance
*so we have 1,7 we place 2 gas stations here so 7-1=6 and split it into 3 consecutive part so 6/3 =2 is diatnce between the 2 consecutive pats
*so [1,3,5,7]
*consider int arr[]={1,13,17,23} and k=5
*here k=1,so we will place it between the max-12,4,6
*so we place it between the {1,13} so the consecutive parts is 2 so it breaks as {1,7,13}{17,23}
*if k=2,then {1,7,13,17,23} so here the max are -6,6,4,6
*so place it between the 17,23 so here split in 2 parts hece 6,2=3 so {17,20,23}
*{1,7,13,17,20,23}
*so here k=3,here the max are {-6,6,4,3,3}
*so i will place it between th 1 and 7 and 6 divide in 2 parts=3 so {1,4,7,13,17,20,23}
*so the main point here is that the we will take k= and keep track of empty place between the elements initially 
*and for(int i=1;i<k;i++)
{
}
*in loop main work will be to find the max between 2 elements nd in whch section it lies from array of sections we made
*for(int i=0;i<k;i++)
{
int maxdiff=-1;maxsection=-1;//wher in section max value is happning
for(int j=0;j<n-1;j++)
{
int diff=arr[i+1]-arr[i];
but if there is already some value present in the section
sectionlenegth=diff/howmanyplaced[i]+1;

if(maxdiff<sectionlength)
{
maxdiff=sectionlength;
maxscetion=i;
}
}
hash[maxsection]++;S

}
then we will run loop of fiding max between elemnts of array 
for(int i=0;i<n-1;i++)
{
int sectionlength=arr[i+1]-arr[i]/howmanyplaced[i]+1;
if(max<sectionlenegth)
{
max=sectionlenegth;
}

}


return maxi;
*now its complexity is o(k*n)
*now the inorder to reduce n to logn we can use pq where pq.push(2) take logn time pq.push(3) take logn and pq.top will give 3 that is max at top
*
------------------------------------------------------------------------------------------------------------------------------------------------------------
meian of 2 sorte arrays
*
we can be given 2 arrays of equal size or not of equal size
*int arr[]={1,3,4,7,10,12} and arr2[]={2,3,6,15}
*we are given thse 2 arrays and they re of uneqal arrays size
*so reultan rry whch is srted is [1,2,3,3,4,6,7,10,12,15} where n=10
*so here we an find median whichis there i ana rray so the median is between 4 and 6=4+6/2=5,so we nedd to take the 2 elemens and find the median from these 2
*conside int arr[]={2,3,4} and arr2[]={1,3}
*so net array is [1,2,3,3,4} here n=5 and hence median is 3
*so the brute force will ne i=0;
j=0;
while(i<arr1.size()&&j<arr2.size())
{
if(arr1[i]<arr2[j])
{
ans.push_back(arr1[i]);
i++;
}else
{
ans.push_back(arr2[j]);
j++;

}
}

while(i<arr1.size())
{
ans.push_back(arr1[i]);
i++;

}
while(j<arr2.size())
{
ans.push_back(arr2[j]);
j++;

}

n=arr1.size()+arr2.size();
if(n%2!==0)
{
return ans[n/2];
}else
{
return ans[n/2]+n/2-1]/2]
}
*here the space comlexiy will be o(n)
*
*so basically we are finding the index at the last why cant be possible if we find the index at when we are merging them
*for that we need to find the index1 and index 2 where index1=n/2-1 and index2 ==n/2 and find the elemenst at this and add
*so initiall cnt=0;
if(arr1[i]<arr2[j])
{
if(cnt===index1){
ele1=arr[i];
}
if(cnt===index2){
ele2=arr[i];
}
ans.push_back(arr1[i]);
i++;
}


class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int cnt=0;
        int i=0;
        int j=0;
        int ele1=-1;
        int ele2=-1;
        int ind2=(nums1.size()+nums2.size())/2;
    int ind1=ind2-1;
        while(i<nums1.size()&&j<nums2.size())
        {
            if(nums1[i]<nums2[j])
            {
                if(cnt==ind1)
                {
                    ele1=nums1[i];
                }
                if(cnt==ind2)
                {
                    ele2=nums1[i];
                }
                i++;
                cnt++;
            }else
            {
                 if(cnt==ind1)
                {
                    ele1=nums2[j];
                }
                if(cnt==ind2)
                {
                    ele2=nums2[j];
                }
                j++;
                cnt++;
                
            }
        }
        while(i<nums1.size())
        {
             if(cnt==ind1)
                {
                    ele1=nums1[i];
                }
                if(cnt==ind2)
                {
                    ele2=nums1[i];
                }
                i++;
                cnt++;
            
        }
        while(j<nums2.size())
        {
            
                 if(cnt==ind1)
                {
                    ele1=nums2[j];
                }
                if(cnt==ind2)
                {
                    ele2=nums2[j];
                }
                j++;
                cnt++;
            
        }
        int n=nums1.size()+nums2.size();
        if(n%2==1)
        {
            return el2;
        }else return double(double((ele1+ele2)/2);
        
        
    }
};


*so here time complexity was 0(n1)+0(n2)
*so we will ry tooptimize it in erms of o(logn)
*so int arr[]={1,3,4,7,10,12}
*in arr2[]={2,3,6,15}
*here total n=10
*so merged sorted array will be[1,2,3,3,4,6,7,10,12,15]
*so median will be 5 between the 4 and 6
*so towards the 5 are 5 ele,emts out of which 3 from arr1 and 2 from arr2
*same for the right half of the median
*so we need to first make the correct left hald and right half
*so we need to make the left half containing 5 elememnys by taking 3 from arr1 and 2 elements from arra2
*so if we take the oelemets from the arr1 then arr2 contains 4 elekmnst <5 so we need to tak 1 from arr1
*s 1,2,3,6,15||3,4,7,10,12 is not valid combination
*next take 2 elemns from arr1 and 3 from the arr2
*1,2,3,3,6||4,7,10,12,again not a valid symmetry
*so now pick 3 elements from the array 1 and 2 elements from arr2
*[1,2,3,3,4||6,7,10,12,15] valid symmetry
*so here 0,1,2 number of elements from arr1 not possible,3 possible and above that not possible
*and we know range too from 0 to 5 no of elements need to be taken from arr1 ,
*now how to know its valid symmetry by simple observation
consider 4 elements from arr1 and 1 from the arr2
   1 3 4 7|10,12
         2|3,6,15

so ideally 7<3 so that 7 comes on the right side but not and 2<10 true 
*now consider 3 3elemens from the arr1 and 2 from the arr2 so 1 3 4| 7 10 12
                                                                2 3| 6 15
so herethe l1 which is greatest of 3 taken from arr1 and ad 3 ishighest of 2 elenenstaken from arr 1 and r1 is smallest from arr1 nad r2 is smaleest from arr2
*so median will be max(l1,l2)+min(r1,r2)/2;
*
so now for now we can take lements from arr1 is 0 to 6
*so if we take 4 elements from the arr1 and if l1>r1 then high=mid-1;
*else low=mid+1;
*so ierate why not on arra2[]so low=0 and high=4 so mid1=2 so we are saying take 2 elements from arr2 and mid2=5-2=3 elemnts 
*doing this this comes that l1=arr[mid1-1]
*l2=arr2[mid2-1]
*r1=arr1[mid1] and r2=arr2[mid2]
*
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int n1=nums1.size();
        int n2=nums2.size();
        if(n1>n2)
        {
            return findMedianSortedArrays(nums2,nums1);
        }
        int left=(n1+n2+1)/2;
        int n=(n1+n2);
        int low=0;
        int high=n1
        while(low<=high)
        {
            int mid1=(low+high)/2;this elements taken from the arr2
            int mid2=left-mid1;//taken from arr1
            if(mid1<n1)
            {
                int r1=nums1[mid1];
            }
            if(mid2<n2)
            {
              int r2=nums2[mid2kth];
            }
            if(mid1-1>=0)
            {
                int l1=nums1[mid1-1];
                
            }
            if(mid2-1>=0)
            {
                int l2=nums2[mid2-1];
            }
            if(l1<r2 && l2<r1)
            {
                if(n%2==1)
                {
                    return max(l1,l2);
                }else
                {
                    return (double)(max(l1,l2)+min(r1,r2))/2.0;
                }
            }
            if(l1>r2)
            {
                high=mid-1;
            }else
            {
                low=mid+1;
            }
        }
        return 0;
                            
        
        
    }
};
------------------------------------------------------------------------------------------------------------------------------------------------------------
*kth element of 2 sorted arrays
*given int arr[]=[2,3,6,7,9] and [1,4,8,10]
*and k=4
*so we need to merge these 2 sorted arrays-hypothetically and find the lement at the 4th index
*so using the logic we used before so 4 elements on the left and 5 elements on the right
*but in earlier approach we wre if n is even than n/2 and n/2 or if n is odd then greater number of elementson the l;eft and less on the right
*but here k and n-k
*class Solution {
public:
    double kthelements(vector<int>& nums1, vector<int>& nums2,inyt n1,int n2,k) {
        
        if(n1>n2)
        {
            return findMedianSortedArrays(nums2,nums1,n1,n2);
        }
        int left=k;
        int n=(n1+n2);
        int low=0;
        int high=n1-1;
        while(low<=high)
        {
            int mid1=(low+high)/2;
            int mid2=left-mid1;
            if(mid1<n1)
            {
                int r1=nums1[mid1];
            }
            if(mid2<n2)
            {
              int r2=nums2[mid2kth];
            }
            if(mid1-1>=0)
            {
                int l1=nums1[mid1-1];
                
            }
            if(mid2-1>=0)
            {
                int l2=nums2[mid2-1];
            }
            if(l1<r2 && l2<r1)
            {
                
                
                    return max(l1,l2);
                
            }
            if(l1>r2)
            {
                high=mid-1;
            }else
            {
                low=mid+1;
            }
        }
        return 0;
                            
        
        
    }
};

but it will give the error
*so we are saying we can take elements from 0 to 6 
*here the high must be min(k,n1),so we need to take at max 2 so no need to iterate from 0 to 6
*low= max(0,k-n2)
*
*
-----------------------------------------------------------------------------------------------------------------------------------------------------------

rows wth maximum number o 1s
*binry search on 2 d matrix
*we will be gven an matrix of n*n
*every row is sorted
*mat=0 0  1 1 1 
     0 0  0 0 0
     0 1  1 1 1
     0 0  0 0 0
     0 1  1 1 1

*we have to return the rows with maximumnumber of 1s
*in case we ave multiple rows with aximum nuber of rows we have to return the ros withminimum idex
*so first of allwe couted the ones from wach rows and stored tir index corresponding tocount
*then we find the one with maximum cout and return their corresponding index
*here 2 and 4 are the rows which have the maximum number of 1s
*so here the basic intuition will be 
for(int i=0i<n;i++)
{
int cnt=0;
for(int j=0;j<m;j++)
{
if(arr[i][j]==1)
{
cnt++;
}
}
if(cnt>maxcnt)
{
maxcount=cnt;
index=i;
}
}
return index;
*so here time complexity will be o(n*m)
*and we need to optimize it and we are also guven every row is sorted
*we cant optimize the rows traversal but can optimize the column traversal in row so we can optimize hows the 1s are stored
*so we need in inner traversal the first one we can easily count the no of 1s by m-i
*so we need to figure out the first occurrence of 1
*then m-ans will give the total count
*class Solution {
  public:
  int lower_bound(vector<int>arr,int one,int size)
  {int ans=0;
      int low=0;
      int high=arr.size();
      while(low<=high)
      {
          int mid=(low+high)/2;
          if(arr[mid]>=one)
          {
              ans=mid;
              high=mid-1;
          }else
          {
              low=mid+1;
          }
      }
      return ans;
  }
    int rowWithMax1s(vector<vector<int> > &arr) {
        // code here
        int index=-1;
        int max_cnt=-1;
        for(int i=0;i<arr.size();i++)
        {
           int cnt=arr[0].size()-lower_bound(arr[i],1,arr[0].size());
           if(cnt>max_cnt)
           {
               max_cnt=cnt;
               index=i;
           }
        }
        return index;
    }
------------------------------------------------------------------------------------------------------------------------------------------------------------
search in 2 d matrix
*mat[][]=[3 4 7 9
         12 13 16 18
         20 21 23 29]
*we are given the sorted matrix
*so we aare given the target=23 we need to return if target present in matrix then true otherwise false
*so he naive approach will be to linearly traverse in the matrix and find
*for(int i=0.i<n;i++)
{
for(int j=0;j<m;j++)
{
if(arr[i][j]==target)
{
return true;
}

}
}
*so another optimal approach will be we can reduce the column traversal as every row is alos sorted
*so ine every row make check if target lies between the arr[i][low] and arr[i][high] if not move to next
*(else
       do binary search(arr[i],target)
*so time complexity will be o(n)+o(logm)


for (int i = 0; i < n; i++) {
    if (target >= mat[i][0] && target <= mat[i][m - 1]) {
        int low = 0, high = m - 1;
        while (low <= high) {
            int mid = (low + high) / 2;
            if (mat[i][mid] == target) return true;
            else if (mat[i][mid] < target) low = mid + 1;
            else high = mid - 1;
        }
    }
}
return false;
*Here time complexiry will b o(n)+logm for one row
*now the optimal solution will be as we know the matrix is sorted
*if we can flatten the matrix
*then apply binary search time complexity will be 0(n*m) to flatten then 0*(logn)
*we should take care of the flatteing of matrix time
*so hypothetically if we flatten a matrix then the the 5 index will be 1 ,1 and the size of matrix is n* m that is 3*4 and at 1,1 we can compare and move the indexes
*so 1,1 will be 5/m and 5%n
*int low=0;
int high=n*m-1
whoile(low<=high)
{
int mid=low+high/2;
int rown=mid/m;where m is columns 
int rown=mid%m;
if(arr[rowm][rown]===target)
{
return true;
}
else(target>arr[rown][coln])
{
low=mid+1;
}else
{
high=mid-1;
}
}

Here time complexiy ill be : O(log(n * m))
-------------------------------------------------------------------------------------------
serach in te sorted atrix=2
*w aregven array wih size as n*m
*we have to find if the target lies in the matrix r not and if it lies then find the index
*note that each row is sorted from left to right nd every column from top to bottom
*[1 4 7 11 15]
 [2 5 8 12 19]
 [3 6 9 16 22]
 [10 13 14 17 22]
 [18 21 2 26 30]
*so here brute force will be to do traversal
for(int i=0;i<n;i++)
{for(int j=0;j<m;j++)
{
if(arr[i][j]==target)
{
return {i,j}
}
}
}
*another solution to this problem will be to do binary serach in every row 
so
for(int i=0;i<n;i++)
{
int r=binary_search(arrr[i],target)
{
if(r!=-1)
{
return {r,i}
}
}
}
*hence time complexity will be o(n*logn)
*target=14
*so here intuition will be take row=0;
col=4;
and check if(arr[row][col]==target]
no 
arr[row][col]>target
col--
again checke
arr[row][col]<target
row++
*so the code will be while(rows<n && col>==0)
{
if(arr[row][col]==target)
{
return{row,col}
}
if(arr[row][col]>target)
{
col--;
}else
{
row++;
}
}

class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int row=0;
        int col=matrix[0].size()-1;
        while(row<matrix.size()&&col>=0)
        {
            if(matrix[row][col]==target)
            {
                return true;
            }if(matrix[row][col]>target)
            {
                col--;
            }else{
                row++;
            }
        }
        return false;
        
        
    }
};

ime Complexity: O(n + m)
-----------------------------------------------------------------------------------------------------------------------------------------------------------
*find the peak element-2
*we are given that the 
*4 2 5 1 4 5
 2 9 3 2 3 2
 1 7 6 0 1 3
 3 6 2 3 7 2
*peak element is one which is greater from all sides
*so the brute force solution will be for(int i=0;i<n;i++)
{
for(int j=0;j<mj++)
{
if(arr[i][j]>arr[i-1][j]**>arr[arr[i][j-1]**arr[i+1][j]**arr[i][j+1])
return {i,j};
}
}
*so time complexity will be o(n*m*4)
*the problem says the outer parts must be considred as element as -1
*so he matrix can contains many peak element we have to return the index of any peak element
*so we can just optimize that the largest element in ana array will be peak but it will again atke the 0(n*n)
*but here main thing si that we dont want o iterate over all elements want ti skip soem so the binar search comes into play
*in the last peak elememt video is the one if a[mid] is >a[mid-1] and a[mid+1]
*if my a[mid+1] >a[mid] measn for sure the peak elements will be towards the right so low=mid+1and if 
*ad if arr[mid]<arr[mid+1] so for sure the elment wll lies on the left part means high=mid-1
*so here take low=0 and high=5 tat is arr[0].size()
*now the mid is 4 in the col 4 which is probabbaility that the element is peak element so the highest element in the column as the highest priority of being the peak element
*so see max=6 so 6 is not but greater from all he elemnst 
*so the 6 is not the peak element as 7>6 that is left greater than the mx so high=mid-1
*so question is why we are takinh as max as max verticall alignenmet se max is greater the upper aNd samller left with right and left so for the binary search we are applying
*int low=0;
int high=m-1;
maxelem()
{
for(int i=0;i<n;i++)
{if(a[i][mid]<max)
{
max=a[i][mid];
row=i;
}
}
return i;
}
whilelow<=high)
{
int mid=low+high/2;
int rowmax=maxelem(mat,n,m,mid);
if(arr[[row][mid]>arr[rowmax][mid-1] && arr[[row][mid+1])
{
retrun {row,mid}
}
if(arr[rowmax][mid]<arr[rowmax][mid-1])
{
high=mid-1;
}else{
low=mid+1;
}
}




class Solution {
public:
    int maxele(vector<vector<int>>& mat,int col){
        int maxi=INT_MIN;
        int rowind=0;
        for(int i=0;i<mat.size();i++){
            if(mat[i][col]>maxi)
            {
                maxi=mat[i][col];
                rowind=i;
            }
        }
        return rowind;
    }
    vector<int> findPeakGrid(vector<vector<int>>& mat) {
        int low=0;
        int high=mat[0].size();
        while(low<=high){
            int mid=(low+high)/2;
            int rowmax=maxele(mat,mid);
            int left=mid-1>=0?mat[rowmax][mid-1]:-1;
                int right=mid+1<mat[0].size()?mat[rowmax][mid+1]:-1;
            if(mat[rowmax][mid]>left && mat[rowmax][mid]>right){
                return {rowmax,mid};
            }else if(mat[rowmax][mid]<left){
                high=mid-1;
            }else
                                                                                   {
                                                                                    low=mid+1;   
                                                                                   }
                
        }
    return {-1,-1};
        
        
    }
};
------------------------------------------------------------------------------------------------------------------------------------------------------------
we are given matrix of size n*m
*where n is odd and m is also odd
*so the matrix is row wise sorted
*int arr[]=[1 5 7 9 11]
           [2 3 4 5 10]
           [9 10 12 14 16]
*so the brute force solution will be put every element in arra
*then sort it
*then the mid will be arr[n*m]/2;
*so time complexity will be o(n*m)
*so in order to reduce the time complexity
*when we used to perform the bs on answers then we needs to first find search space so the element will lie between 1 and max element in array
*so here no of elements <=median has to be greater then the 7 and 7 is the no of elemnt towraed left of median
*



















------------------------------------------------------------------------------------------------------------------------------------------------------------
























*so take exampleas as(())()here first ( there is ) so (()) is valid and next to it() isaso valid parenthesis
*what is decomposition for eery( there must be ) and for very ( in beween there ms be )
*so from eachdecomposition we needto remove the outermost parenthesis
*so we need to first decompose teh string then remove outrmost parentheses
*and return the final string
*so let take example as ((()))(()())
*lets take the first approach using the stack
*so if he stack is empty than push into stack but dont add itin the ans
*and if the if not empty than the push to stacja nd add it to ans
*now if we encounter the ) then pop from stack and then add to ans
*so at teh end of decomposition stack became empty
*so here we have used the 0(n) tiem nd the 0(
*we are already given the parenthesis which is already balanced we need to remove the outemost parenthesis
*so (()())
*after removing outer ()()
*so keep the cnt when first you ses the outermost as ( so else cnt--
*so where cnt==0 that is outemost
*if(cnt>0)
{

if(arr[i]=='(')
{
temp.push(arr[i])
}
cnt++;
else
{
cnt--;
temp.push(arr[i]);

}
*first convert string to char array using the 
vector<char>chararr(s.begin(),s.end());
*class Solution {
public:
    string removeOuterParentheses(string s) {
        int cnt=0;
        vector<char>history;
        vector<char>chararr(s.begin(),s.end());
        for(int i=0;i<chararr.size();i++){
            if(chararr[i]=='(')
            {if(cnt>0)
            {
                history.push_back(chararr[i]);
            }
                cnt++;
            }else{
                cnt--;
                if(cnt>0)
            {
                history.push_back(chararr[i]);
            }
            }
            
        }
        return std::string(history.begin(), history.end());



vector<char> chararr(s.begin(), s.end()); → O(n)

Converts the string s into a character array (size = n)

for (i = 0 to n) → O(n)

Loop through all characters once

history.push_back(...) → O(1) amortized per push

Total pushes in worst case: n

string(history.begin(), history.end()) → O(n)

Convert vector of characters back into a string

✅ Total Time Complexity: O(n)
-----------------------------------------------------------------------------------------------------------------------------------------------------------
*so are given the string as "hello world!"
*lets take the example as " the sky is blue "
*here this string has the leading an dthe trailing spaces
*so here first issue is with the removal of leading space so we need to remove that for the character wise traversal is mus
*" the sky is blue "
*so the if(s[i]==" " i++) else
temp=temp+s[i]
*again space and temp.size()!=0 then again ans=temp and remove temp 
*but if ans.szie()!==0 then ans=temp+ans
*
while(i<n)
{
temp=""
while(i<n&&s[i]===" ")
{
i++;
}
while(i<n &&s[i]!=" ")
{
temp=temp+s[i];
i++;
}
if(temp.size()!=0)
{
if(ans.size()==0)
{
ans=temp;
}else
{
ans=temp=" "+ans;
}
}
}




#include<bits/stdc++.h>
class Solution {
public:
    string reverseWords(string s) {
        string result="";
        int i=0;
        int n=s.length();
        while(i<n){
            string temp="";
        while(i<n&&s[i]==' '){
            i++;
        }
        
        while(i<n&&s[i]!=' ')
        {
            temp=temp+s[i];
            i++;
        }
            if(temp.size()>0)
            {
                if(result.size()==0)
                {
                    result=temp;
                }else
                {
                    result=temp+" "+result;
                }
            }
       
        }
        return result;
        
    }
};

------------------------------------------------------------------------------------------------------------------------------------------------------------
*#include <iostream>
#include<bits/stdc++.h>
#include<string.h>
using namespace std;

int main() {
    char string[20];
    cin>>string;
    int flag=0;
    int len=strlen(string);
    for(int i=0;i<len;i++)
    {
        if(string[i]!=string[len-1-i])
        {
            flag=1;
            break;
        }
    }
    if(flag)
    {
        cout<<string<<"string is not palindrome";
    }else
    {
        cout<<string<<"is palindrome";
    }

    // Write C++ code here
    std::cout << "Welcome to Code 360 Online Compiler!!";
    
    return 0;
}
------------------------------------------------------------------------------------------------------------------------------------------------------------
we are given the number in a string
*so lets take number as "1234"
*so its substring are 1,12,123,1234,2,23,234,3,34
*we need to take the odd and among odd then largest
*then ts time comlexitycan be  and o(n*n*n) and o(n*n)
*so is easy trick will be take the traverse from back an as soon you got odd number till that string is the largest odd number
*as till 123 is the largest odd number
*
   int n=num.size();
        int i=0;

        for(i=n-1; i>=0; i--){
            if(num[i]%2!=0) break;
            else if(i==0 and num[i]%2==0)  return "";
        }
        return num.substr(0,i+1);

*note num.substr(0,i+1)here i is the index and the i+1 is the len
------------------------------------------------------------------------------------------------------------------------------------------------------------
*we are given the array of string as array[]]

*we are given an array of a strings as ["flower","flow","flight]
*so the thing is we need to find the longest common prefix strings
*so here that common prefix string is fl
*so we need to have access of all elemen particular index at same time with reference to some I amd that index iteration ison the minlem strings
*here take the tsring strmin="flow"
*for(int i=0;i<minlen;i++)
{
for(int j=0;j<str.size();j++)
{
if(arr[j][i]!=strmin[i]){
return strmin.substr(0,count);
}
count++;
}
}
return strmin.substr(0,count)
*

class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
       
        string minstr="";
        int minlen=INT_MAX;
        for(int i=0;i<strs.size();i++)
        {
            
            if(strs[i].size()<minlen)
            {
                minlen=strs[i].size();
                minstr=strs[i];
            }
        }
        int cnt=0;
        for(int i=0;i<minlen;i++)
        {
            for(int j=0;j<strs.size();j++)
            {
                if(strs[j][i]!=minstr[i]){
                    
                    return minstr.substr(0,cnt);
                    
                }
                
            }
            cnt++;
        }
        return minstr.substr(0,cnt);
        
    }
};
-----------------------------------------------------------------------------------------------------------------------------------------------------------

we are given 2 strings 
*str1=aab str2=XXY
*isomorphic strings are those whose characters occurenec are same
*for strings to be isomprhic their size must be equal
*for that we need to acess each sring character and map to their index which means index->occurenec
*so a->0,1
*b->2
*x->0,1
*y=>2
*so map <char,vector<int>>
*then iterate over the strings 1 and check if the mpp[str[i]]!=mpp[str2[i]] return false else return true
*
*class Solution {
public:
    bool isIsomorphic(string s, string t) {
        map<char,vector<int>>mpp1;
         map<char,vector<int>>mpp2;
        if(s.size()!=t.size())
        {
            return true;
        }
        for(int i=0;i<s.size();i++)
        {
            mpp1[s[i]].push_back(i);
        }
        for(int i=0;i<t.size();i++)
        {
            mpp2[t[i]].push_back(i);
        }
        for(int i=0;i<t.size();i++){
            if(mpp1[s[i]]!=mpp2[t[i]]){
                return false;
            }
        }
        return true;
        
        
    }
};
------------------------------------------------------------------------------------------------------------------------------------------------------------
*we are given 2 strings s and goal
*and we have t return true when performoing some shfts on s s becomes goal
*and condition that s can become the goal only and only s can become goal if the leftmost character can be shift to he rightmost
*and to do this shfts we ave the stk library as queue
*sothe first solution to the problem is the  we can make use of the goal is made id the s is shifyed and after shifting the goal the s will be attached and initial take k=goal.szE()-1 and as sson as the goal bcomes s then k will be at that number of shifts from s goal was achieved
*consider string s="bcgefm" and goal="efmbcg"
*so first insert the both into q
*then perform shifts o the gaols
*so  queue<char>q1,q2;
        for(int i=0;i<s.size();i++)
        {
            q1.push(s[i]);
        }
        for(int i=0;i<goal.size();i++)
        {
            q2.push(goal[i]);
        }
        int k=goal.size()-1;
        while(k!=0)
        {
            char c=q2.front();
            q2.pop();
            q2.push(c);
            if(q1==q2)
            {
                return true;
            }
            k--;
            
            
        }
        return false;
*here the number of roations is k
*here due to queue time complexity will be o(n)
-----------------------------------------------------------------------------------------------------------------------------------------------------------
anagam of strings
*naagram of string is the string whhch have the same characters as first strings but their orders are different

*the programee takes 2 strings 
*then check the length f 2 strings
*then sorted these 2 string and find if equal if eqyal then true ele return false
*#include <iostream>
using namespace std;
#include<bits/stdc++.h>
bool anagram(string &s1,string &s2)
{
    if(s1.size()!=s2.size())
    {
        return false;
    }
    sort(s1.begin(),s1.end());
    sort(s2.begin(),s2.end());
    for(int i=0;i<s1.size();i++)
    {
        if(s1[i]!=s2[i])
        {
            return false;
        }
    }
    return true;

}
int main() {
    // Write C++ code here
    string s1;
    string s2;
    cin>>s1;
    cin>>s2;
    cout<<anagram(s1,s2);

    std::cout << "Welcome to Code 360 Online Compiler!!";
    
    return 0;
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------
*given the string s
*we nedd to find the frequency of charasters and sort it in descending orders
*string s=tree
*then resultant stringwill be eetr or eert both will be answer
*so first map each character with frequency now want that sorting should be basis on yhe frequenecy but such no alho on sorting o use priprty queue
*priority_queue mei according to the first value the max element ill be at the top
*pq(2,1)
*pq(3,4)
(then ans will be 3,4 then 2,1
*so in pq insert frequency than character
*ghan at top wll be pair with maximum frequenecy tha pop
*then traverse the prioity queue an then append to the string
*class Solution {
public:
    string frequencySort(string s) {
        unordered_map<char,int>mpp;
        string ans="";
        priority_queue<pair<int,char>>pp;
        for(int i=0;i<s.size();i++)
        {
            mpp[s[i]]++;
        }
        for(auto it:mpp)
        {
            pp.push({it.second,it.first});
            
        }
        while(!pp.empty())
        {
            auto temp=pp.top();
            int freq=temp.first;
            char c=temp.second;
            ans=ans+string(freq,c);
            pp.pop();
            
        }
        return ans;
    }
};
*note:string is function that return string with arg aas the frequency and the chaacters
------------------------------------------------------------------------------------------------------------------------------------------------------------
*string(history.begin(),string.end())where history is he vector of characters
*and then the string(freq,char) to convert to string with char ch at frequency freq
------------------------------------------------------------------------------------------------------------------------------------------------------------
*maximum nesting depth of parenthesis
* nesting depth of parenthesis is the maximum number of nested parenethesis
*ex=(1+(2*3)+((8)/4))+1
*we will take 2 varibales as curr =0 amd max=0
*as soon as we counters ( then increase curr++ and check if its greater than max ifits greater than max=curre
*and as oon as we encounter ) than cnt-- and check with the curr
*#include<bits/stdc++.h>
class Solution {
public:
    int maxDepth(string s) {
        int curr=0;
        int maxi=0;
        for(int i=0;i<s.size();i++)
        {
            if(s[i]=='('){
                curr++;
                maxi=max(maxi,curr);
            }else if(s[i]==')'){
                curr--;
            }
        }
        return maxi;
        
    }
};
*
*
------------------------------------------------------------------------------------------------------------------------------------------------------------
roman number to integer and vice versa
*so basically we are given value of the symbols as I=1
V=5 
X=10
L=50
C=100
D=500
M=1000
*so if we given XV= we need to add the value of the X and V that is 10+5 =15
*rules says if there are consecutive characers and if value of first character is less tha nex than the value of first character will be -
*so basically there is changes in the value of each character too depending on the check
*#include <iostream>
using namespace std;
#include<bits/stdc++.h>
int calculate(char &r){
    if(r=='I'){
        return 1;
    }else if(r=='V'){
        return 5;
    }else if(r=='X'){
        return 10;
    }else if(r=='L'){
        return 50;
    }else if(r=='C'){
        return 100;
    }else if(r=='D'){
        return 500;
    }else if(r=='M'){
        return 1000;
    }
}

int main() {
    // Write C++ code here
    std::cout << "Welcome to Code 360 Online Compiler!!";
    string s;
    cin>>s;
    int ans=0;
    for(int i=0;i<s.size();i++)
    {
        if(i<s.size()-1)
        {
            int v1=calculate(s[i]);
            int v2=calculate(s[i+1]);
            if(v1>=v2)
            {
ans=ans+v1;
            }else{
                ans=ans-v1;
            }
        }else{
            ans=ans+calculate(s[i]);
        }
    }
    cout<<ans;
    return 0;
}
------------------------------------------------------------------------------------------------------------------------------------------------------------
implement atoi 
so bascally we will be ien the strings
*as s="324" we need to convert it into the integer format only if possible
*
*so basically we will iteration on string and from each character - the '0'
*we het integerand if it ies between0 and 9 than ony w can convert i inointeger
*and initial result=0 then set to the iteger value tha  for nextiteration 
tesult=result*10+intvalue
*class Solution {
public:
    int myAtoi(string s) {
        int result=0;
        for(int i=0;i<s.size();i++)
        {
            if(0<s[i]-'0'<9){
                result=result*10+s[i]-'0';
            }
        }
        return result;
        
    }
};
-----------------------------------------------------------------------------------------------------------------------------------------------------------
*Feature	vector	set
Header	<vector>	<set>
Underlying Structure	Dynamic Array	Balanced Binary Search Tree (Red-Black Tree)
Order of Elements	Maintains insertion order	Sorted automatically (ascending by default)
Duplicates	✅ Allows duplicates	❌ No duplicates allowed
Access by Index	✅ O(1) access using index (vec[i])	❌ No index-based access
Insertion Time	O(1) (amortized at end), O(n) at middle	O(log n)
Search Time	O(n) (linear search) or O(log n) (binary search if sorted)	O(log n) using set.find()
Memory Usage	Less (contiguous block)	More (node-based structure)
Use Case	When order matters and duplicates are allowed	When you need sorted unique elements
};----------------------------------------------------------------------------------------------------------------------------------------------------------
*count the number of substring with that have exactly k distinct characters
*we will be given the string
*we need the susbstring
*with exacty k distinct chacaters
*we need to store the count
*so here the naie time complexity will be o(n*n*n)
*#include <iostream>
#include <unordered_map>
using namespace std;

int countKDistinctBrute(const string& s, int k) {
    int count = 0;
    int n = s.length();

    for (int i = 0; i < n; ++i) {
        for (int j = i; j < n; ++j) {
            unordered_map<char, int> freq;
            for (int m = i; m <= j; ++m) {
                freq[s[m]]++;
            }
            if (freq.size() == k) {
                count++;
            }
        }
    }

    return count;
}

then the better will be #include <iostream>
#include <unordered_map>
using namespace std;

int countKDistinctBetter(const string& s, int k) {
    int count = 0;
    int n = s.length();

    for (int i = 0; i < n; ++i) {
        unordered_map<char, int> freq;
        for (int j = i; j < n; ++j) {
            freq[s[j]]++;
            if (freq.size() == k) {
                count++;
            } else if (freq.size() > k) {
                break;
            }
        }
    }

    return count;
}



then he optimal will be #include <iostream>
#include <unordered_map>
using namespace std;

int atMostKDistinct(const string& s, int k) {
    int count = 0;
    int left = 0;
    unordered_map<char, int> freq;

    for (int right = 0; right < s.length(); ++right) {
        freq[s[right]]++;

        while (freq.size() > k) {
            freq[s[left]]--;
            if (freq[s[left]] == 0) {
                freq.erase(s[left]);
            }
            left++;
        }

        count += (right - left + 1);
    }

    return count;
}

int countKDistinctOptimal(const string& s, int k) {
    return atMostKDistinct(s, k) - atMostKDistinct(s, k - 1);
}
As we are usig the unordered map here time complexity will be the 0(n)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Longest palindromic substring




-----------------------------------------------------------------------------------------------------------------------------------------------------------
*int arr[4]={1,2,3,4}
*so her size is fix 
*if we want to add 6 we all elements are atcntigous locations
so we cant say that the next location is ree or not so the as the arry size are fix
*
*so n arraywe cant add more siz or decrease more size here comes the linkedlist
*in linkedlst sze can be increased and decreased and elements are ot stored at the contiguous locations
*as in array in memory location w have the data 
*here but in memory location we have teh data and the pointer
*so here we have the memory location as m1,m2
*so here head=m1
*usually the head of the linked list is the head
*here m1 contains the next and the pointer which points to the next memory location
*here the last memory location next pointer points to null
*here the last pointer will be called as the tail
*so anyone how do you add new element so at random memory location store thye data and then tail->next=new memoy location
*it is mostly used in the stacks and queues and in daily life in browsers and then the move tonext link then to next then to previous in browsers
*int x=2 than int *y=&xhere y is the pointer to the memory location which store the data as 2 as this y pointer data type is int 
*now in linked list we have the data and the pointer to the next locationso here memory location does not have the data type so we defined our predefined type
*struct Node
{
int data;
Node *next
Node(data,next1){
data=data;
next1=next1
}
}
*now Node node=Node(2,nullptr)//here this is just data type now to have the memory location
Node *y=&node
*so instead of doing these 2 points we can do is Node * y=new Node(2,nullptr) it will automatically assign the memoryloaction to the y
*#include <iostream>
using namespace std;
#include<bits/stdc++.h>
struct Node{
    int data;
    Node* next;
    Node(int datae,Node*nexte)
    {
        data=datae;
        next=nexte;
    }
};
int main() {
    // Write C++ code here
    std::cout << "Welcome to Code 360 Online Compiler!!";
    int arr[5]={1,2,3,4};
    Node *y=new Node(2,nullptr);
    cout<<y;
    
    return 0;
}
*so here to print the data cout<<y->data
*not here plz in the conductor specify the correct parameters of the constructors
*not that the implementation of the costructotrs can be differenetNode(int datae,Node*nexte)
    {
        data=datae;
        next=nulltr;
    }
*so here Node *y=new Node(2);
*in structwe dont get teh oop concepts
*now we say that whats the memory location depending on the system if the 32 bits then data taes the 4bytes and pointer takes 4 bytes
*if 64 bi if data then 4 bytes aand if pointer than takes 8bytes
*int arr[]={1,2,3,4}
*so first head=m1
*now we need the mover to iterate through creating ll list
*mver->next=temp where twmp is the created node
*mover =temp




using namespace std;
#include<bits/stdc++.h>
struct Node{
    int data;
    Node* next;
    Node(int datae)
    {
        data=datae;
        next=nullptr;
    }
};
Node * convertll(vector<int>& arr){
    Node *head=new Node(arr[0]);
    Node * mover=head;
    for(int i=1;i<5;i++){
        Node *temp=new Node(arr[i]);
        mover->next=temp;
        mover=temp;
    }
    return head;
}
int main() {
    // Write C++ code here
    std::cout << "Welcome to Code 360 Online Compiler!!";
    vector<int>arr={1,2,3,4};
    Node *head=convertll(arr);
    cout<<head->data;

   
    
    return 0;
}

*note that the always take tthe vector for the linked listas you take the array than there might be many error
*now for traversing the linkedlist
*Node *temp=head;
while(temp!=null)
{
cout<<temp->data;
temp=temp->next;
}
*now to fid he lenth of ll then 
*int cnt=0;
*while(temp!=null)
{
cout<<temp->data;
temp=temp->next;
cnt+;
}
*
------------------------------------------------------------------------------------------------------------------------------------------------------------
*insertion and deleteion in the linkedlist
*delete the head of linked list
*1->2->3->4
*so first thing is head=m1(1,next)
*so first thing we need to do is move head=head->next than delete the memory location containing m1
*so for trhat store the head
*Node * deletehead(Node *head)
{
if(head==null)
{
return head;
}
Node *temp=head;
head=head->next;
free(temp)or delete temp;
return head

}
*but in java it has the garbage collector,we need not manyllat free the memory location
*note:there is always the edge case that if (head==null)return head
*#include<iostream>
using namespace std;
#include<bits/stdc++.h>
struct Node{
    int data;
    Node* next;
    Node(int datae)
    {
        data=datae;
        next=nullptr;
    }
};
Node * convertll(vector<int>& arr){
    Node *head=new Node(arr[0]);
    Node * mover=head;
    for(int i=1;i<4;i++){
        Node *temp=new Node(arr[i]);
        mover->next=temp;
        mover=temp;
    }
    return head;
}
void print(Node *head)
{
    Node *temp=head;
    while(temp){
        cout<<temp->data<<" ";
        temp=temp->next;
    }
}
Node * deletehead(Node * head)
{
    if(head==NULL)
    {
        return head;
    }
    Node *temp=head;
    head=head->next;
    delete temp;
    return head;
}
int main() {
    // Write C++ code here
    
    vector<int>arr={1,2,3,4};
    Node *head=convertll(arr);
   
    print(head);
    head=deletehead(head);
    print(head);

   
    
    return 0;
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------
*delete the tail of the linkedlist
*suppose we have the 1->2->3->4
*now to want delte 4 we need the duty that its previous ->next=null
*so we need to stop at second last and how we identify is secondlast is temp->next->next=null
*so for that there must be 2 elemenst in the linkedlist
*so in case if the linkedlist contains the 1 element or head==null return null
*Node * deletetail(Node *head)
{
if(head==NULL||head->next==Null)
{

}
Node *temp=head;
while(temp>nex->nex!=null)
{
}
free(temp->net);
temp->next=null;
}
note:here the thing is theat here free the temp->next first
*
------------------------------------------------------------------------------------------------------------------------------------------------------------
we have te linked list as 1->2->3->4
*delete the kth elemenet from linked liust
*here comes 2 edge cases 
*first if k==1 then we ned to remove head
*so if(head==null)return head
if(k==1)
{
Node *temp=head;
head=head->next;
free(temp)\
return head;
}
*s here first case of head
int cnt=0;
Node *temp=head;
Node *prev=NULL;
while(temp!=null){\//itrateto reach element at k 

cnt++;
if(cnt==k)
{
prev->next=prev->next->next;
free(temp);
break;
}
prev=temp;
temp=temp->next;
}
return head;


s here the time complexity will be o(n) where n is the number of elekmebts in an array
*----------------------------------------------------------------------------------------------------------------------------------------------------------
*delte the node with the val as val
so if(head==null)return head
if(head->data==val)
{
Node *temp=head;
head=head->next;
free(temp)\
return head;
}
Node *temp=head;
Node *prev=NULL;
while(temp!=null){\//itrateto reach element at k 

if(temp->data==val)
{
prev->next=prev->next->next;
free(temp);
break;
}
prev=temp;
temp=temp->next;
}
return head;
------------------------------------------------------------------------------------------------------------------------------------------------------------
Insert the lement at the beginning of linked list
*suppose linked list is 2->3->4->5
*we need to add 1 at the beginning 
*so libke  list will be 1->2->3->4
*so newnode->next=head;
*head=newnode
*so here we have 2 ways depending on the constructor(data)
{
data=data;
next=null
}
Node * insertnode(head,val);
{
Node *temp=new Node(val);
temp->next=head;
return temp;
}


and depending on another 
constructor(data,next)
*{
data=data;
next=next
}
Node * insertnode(head,val);
{
Node *temp=new Node(val,head);
return temp;
}
------------------------------------------------------------------------------------------------------------------------------------------------------------
*Insrt atthe tail
*so here the first edge case will be if head==null return new Node(2,null)
*so here we nee t stop at he last eemnts so while(temp->next!=NULL)
{
temp=temp->next;
}
*thne temp->next=new Node(2,NULL)
*so Node* insertatatail(Node *head)
{
if(head===Null)
{
return new Node(2,NULL)
}
}
Node *temp=head;
while(temp->nexT!=NULL){
temp=temp->next;
}
temp->next=new Node(2,Null)
*
------------------------------------------------------------------------------------------------------------------------------------------------------------
insert at the kth element aand k can be from 1 to N+1 where n is length of the ll
*now first edge case is if linkedlist does not exist then the if(head==NULL) and k==1
*return new Node(val) else return null
*then another case if linked list exist and then k==1
*than if(k==1) than the return new Node(val,head)
*tak example as 1->2->3->4
*we need to insert at the k=3 than we nee t stand at k=2
*i cnt=0;
*while(temp!=NULL)
{
cnt++;
if(cnt=k-1)
{
standing at the 2 posand
*frst need to make right bond easible so the newnode->next=temp->next;
temp->next=newnode
return head;
}
temp=tep->next;

}
Node * insertatkth(Node *head,val,k)
{
if(head==NULL)
{
if(k==1){
return neW Node(val,NULL)
}
}
if(k==1)
{
retrun new Node(val,head)
}
int cnt=0;
Node*tep=head
while(temp!=NULL
{
cnt++;
if(cnt==k-1)
{
Node *newnode=new Node(val,NULL);
newnode->next=temp->next;
temp->next=newnode

}
}
*so here cases arise that if head null and k==1
*if head exist and k==1
*if head exits and k is not equal to 1
----------------------------------------------------------------------------------------------------------------------------------------------------------we we need to insert the elements before some value so the edge case arise\*
insertnode beforeval(Node *head,int el,int val)
{
if(head==NULL)
{
return null;
}
if(head->data==val)
{
return new Node(el,head)
}
while(temp->next!=NULL)
{
if(temp->next->data==val)
{
Node  *x=new Node(el,NULL);
x->next=temp->next;
temp->next=x;
return head
}
temp=temp->next
}
{
}
}
*
------------------------------------------------------------------------------------------------------------------------------------------------------------
dleting the node of a liked list
*You are given the node to be deleted node. You will not be given access to the first node of head
*and each node is uniqe
*and this node is no the last nde in the linkedlist
*here careful obseratio is that 1->2->3->4 then the 
*deleting 3 will moe 4 to eft 
*so node->val-next->va
*noe->next=node->next->next
*class Solution {
public:
    void deleteNode(ListNode* node) {
        node->val=node->next->val;
        node->next=node->next->next;
        
    }
};
*
------------------------------------------------------------------------------------------------------------------------------------------------------------
*as in the singly list we were movig forward only we were not movong backwards so in dobly we can move backwards too
*son in the data structure added will be the 
*struct Node{
int data;
Node *next;
Node*prev
}
*Node(data,next,prev)
{
data=data;
next=next;
prev=prev
}
Node(data)
{
data=data;
next=null;
prev=null
}

*so now he node representation will be node* temp=new node(1,null,bull)
*now t mke dll from array
Node * makedll(arr)
{
Node *head=new Node(arr[0],NULL,NULL);
we ned the moer as wwll as the prev solets make the mover and the prev as the same
Node *prev=head;


}
using namespace std;
#include<bits/stdc++.h>
struct Node{
    int data;
    Node *next;
    Node *prev;
    Node(int datae,Node *nexte,Node *preve){
        data=datae;
        next=nexte;
        prev=preve;
    }
    Node(int datae){
        data=datae;
        next=NULL;
        prev=NULL;
    }
};
Node * createdll(vector<int>arr){
    Node *head=new Node(arr[0]);
    Node *prev=head;
    for(int i=1;i<4;i++){
        Node * temp=new Node(arr[i],NULL,prev);
        prev->next=temp;
        prev=temp;

    }
    return head;
}
int main() {
    // Write C++ code here
    std::cout << "Welcome to Code 360 Online Compiler!!";
    vector<int>arr{1,2,3,4};
    Node * temp=new Node(1,NULL,NULL);
    cout<<temp->data;
    Node *head=createdll(arr);
    cout<<head->data;
    
    return 0;
}
*
-----------------------------------------------------------------------------------------------------------------------------------------------------------


Specially  case first for the deletion is:heas and head->next==Null

 
*deletion in dll
*delete the head
*sofirst edge case is can we delete if head===NULL
*then return head
*2nd case can be ifdll has only one element then delete theat
*if more than so first thing you will do is Node *temp=head;
*head=head->next
*now adjust its next node and prev node so 
*head->prev=null
*now head->next=Null
*free(temp)
*Node  * deleteheadofdll(Node * head)
{
    if(head==NULL)
    {
        return head;	
    }
    if(head->next==NULL){
        return NULL;
    }\
    Node*temp=head;
    head=head->next;
    head->prev=NULL;
    temp->next=NULL;
    free(temp);
    return head;
}




and hole programe is still 
#include <iostream>
using namespace std;
#include<bits/stdc++.h>
struct Node{
    int data;
    Node *next;
    Node *prev;
    Node(int datae,Node *nexte,Node *preve){
        data=datae;
        next=nexte;
        prev=preve;
    }
    Node(int datae){
        data=datae;
        next=NULL;
        prev=NULL;
    }
};
Node * createdll(vector<int>arr){
    Node *head=new Node(arr[0]);
    Node *prev=head;
    for(int i=1;i<4;i++){
        Node * temp=new Node(arr[i],NULL,prev);
        prev->next=temp;
        prev=temp;

    }
    return head;
}
Node  * deleteheadofdll(Node * head)
{
    if(head==NULL)
    {
        return head;
    }
    if(head->next==NULL){
        return NULL;
    }\
    Node*temp=head;
    head=head->next;
    head->prev=NULL;
    temp->next=NULL;
    free(temp);
    return head;
}
int main() {
    // Write C++ code here
    std::cout << "Welcome to Code 360 Online Compiler!!";
    vector<int>arr{1,2,3,4};
    Node * temp=new Node(1,NULL,NULL);
    cout<<temp->data;
    Node *head=createdll(arr);
    cout<<head->data;
     head=deleteheadofdll(head);
    cout<<head->data;
    
    return 0;
}

*important point in singell hereege cas was if (head==NULL) return head but here 2 edge cases so if(head==Null||head->next==NULL)
{
return NULL
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------s
*dlete the tail of linked ,ist
*here also edge cases are same if (haed==Nill||head->next=Null)
{
retrn NULL
}
*so 1->2->3->4
*so ere th we ill move here till the tail
*here we moved till last as from last w can getone prev but in single we will stop one before the tail
*so here temp=head
*while(temp->next!=NULL)
{
temp=temp->next
}
*so what we will do is no 
tail=temp->prv;

temp>prev=Null but before take its prev whch will become tail
tail->next=Null;
free(temp)
Note :here so the thing is of th tail weset p the connectina as -> then <-



and the whole code is #include<bits/stdc++.h>
struct Node{
    int data;
    Node *next;
    Node *prev;
    Node(int datae,Node *nexte,Node *preve){
        data=datae;
        next=nexte;
        prev=preve;
    }
    Node(int datae){
        data=datae;
        next=NULL;
        prev=NULL;
    }
};
Node * createdll(vector<int>arr){
    Node *head=new Node(arr[0]);
    Node *prev=head;
    for(int i=1;i<4;i++){
        Node * temp=new Node(arr[i],NULL,prev);
        prev->next=temp;
        prev=temp;

    }
    return head;
}
Node  * deleteheadofdll(Node * head)
{
    if(head==NULL)
    {
        return head;
    }
    if(head->next==NULL){
        return NULL;
    }\
    Node*temp=head;
    head=head->next;
    head->prev=NULL;
    temp->next=NULL;
    free(temp);
    return head;
}
Node * deletetail(Node * head){
    Node * temp=head;
    while(temp->next!=NULL){
        temp=temp->next;
    }
    Node *newtail=temp->prev;
    temp->prev=NULL;
    newtail->next=NULL;
    free(temp);
    return head;
}
int main() {
    // Write C++ code here
    std::cout << "Welcome to Code 360 Online Compiler!!";
    vector<int>arr{1,2,3,4};
    Node * temp=new Node(1,NULL,NULL);
    cout<<temp->data;
    Node *head=createdll(arr);
    cout<<head->data;
     head=deleteheadofdll(head);
    cout<<head->data;


    head=deletetail(head);
    cout<<head->data;
    
    return 0;
}

Note:only dfferenec we here iterated till the last s prev hold is possible
-----------------------------------------------------------------------------------------------------------------------------------------------------------
*delete the kth element from the linked list
*now th edge case will be if (k==1)
*this s same as deleting the haed of the linkedlist
*and i k==n
*so our main motive will be to go to that node
*while(temp!=NULL)
{
cnt++;
if(cnt==k)
{
break;//no need of prev as we can get next nd prev from this
}
}
now here tak previous=temp->prev
forward=temp->next

note:scenarios are that if cnt==1 and then next is null and prev is also null 
*so if(previous==Null 
&&forward===Null)
{
free(temp);
}

now case arises if the prev is null measn you are at the head
*dlete head and if tail is null than delete tail
*if not any case than previous->next=foward;
forward->prev=previous;
temp->next=NULL;
temp->prev=NULL;
free(temp)
------------------------------------------------------------------------------------------------------------------------------------------------------------
*insert the element before  head
*so first is creating the node 
Node *newnode=new Node(val,head,NULL)//tis node next will be head and prev will be null now the 
*head->prev=newnode;
head=newnode
------------------------------------------------------------------------------------------------------------------------------------------------------------
*now insert the element before the tail
*note :in last we iterate like while(temp->next!-null)
*temp=tem->next;
*now tail=taemp;
prev=tail->prev;
Node *newnode=new Node(val,prev,tail);
tail->prev=newnode;
prev->next=newnode
*this case is for the scenaios when we have the linkedlist with more than 1 element if one element
*now insert before head will work
* 
------------------------------------------------------------------------------------------------------------------------------------------------------------
*we have the linkedlist as 1->2->3->4->5
*here n=5
*we have to return the node which is the middle of the linkedlist
*so here we need to return the 3  as n/2=3
*conside r1->2->3->4->5->6
*so here the n is 6 thne here the middle is between the 3 and 4 in that case return the node with data as 4
*so here middle will be n/2+1
*now the thing is that first we need to find the length of ll 
*then find middle=cnt/2+1
*then while(temp!=null)
{
middle--;
if(midle==0)
{
return temp;}
}

*now here the time complexity will be o(n)+o(n/2)
*one for traversing and dfind middlethen frommiddle returning the head
*so here the slow and fast pointer will point both to the head
*move slow by 1 and fast by 2
*and and we will move both simulataneously
*as soo as fast reaches the tail than at that point slow will be the middle of ll in case of the odd number ll
*note that the in case of the fast reaches the null after tail slow will point ti the mid
*so intuition is 2 person one moving with speed x covering the distance d
*p2 with speed x/2 will cover distance x/2
*so slow=head;
fast=head;
while(fast!=NULL&&fast->next!=NULL)
{
slow=slow->next;
fast=fast->next->next;
}
return slow;




class Solution {
public:
    ListNode* middleNode(ListNode* head) {
       ListNode * slow=head;
        ListNode * fast=head;
        while(fast!=NULL&&fast->next!=NULL){
            slow=slow->next;
            fast=fast->next->next;
        }
        return slow;
        
    }
};
*
*
------------------------------------------------------------------------------------------------------------------------------------------------------------
*reverse a ll 
*consider the linked list as 1->3->2->5
*after reversing the ll will be 5->2->3->1
*so first intuition will be store the element as we traverse in linkedlist
*so store it in the stack
*now again stand ath the head,so here instead of 1 5 must be there which is at top of stack
*so head-val=stack.top();
head=head->next
*so we are reversing the linkedlist in terms of data
*Node *tem=head;
stack<int>st;
while(temp!=null)
{
st.push(temp->data);
temp=tem->next;
}
Node *start=head;
while(start!=NULL)
{start->data=st.top();
st.pop();
start=start->next;

}
*so here time complexity iwll be o(2*n)
*and space complexity will be o(n) as we are doin onplace


Reason as stack push takes o(1) and space complexity ill be 0(N)
*so we need to reduce the space complexity which we can reduce if we reverse by liks
*so now 5 will be new head pointing to the prev
*basicall conside 2-> now will become<-2
*so any temp->next=prev
*but then want to iterate to next node for theat store before changing the link node *front=temp->next then temp=front
*so before moving prsesrve prev=temp too
*Node *temp=head;
Node *prev=NULL;
while(temp!=NULL)
{
Node *fornt=temp->next;
temp->next=prev;
prev=temp;
temp=front;
}
return prev
------------------------------------------------------------------------------------------------------------------------------------------------------------
detect a loop in ll
*we will be a given the head of ll 1->2->3->4->5->6->7->8->9
                                         |                  |
                                         ------------------
*we hav o return tre if there is loop in ll
*so definition of ll in linkedlist is there is minimum one node trough which itraversed come back gain and traverse again
*so here th nodes visited more than once are 3,4,5,6,7,8,9
*so i ned to have the count that this node is viste before too
*so we will use the hashing 
*so map<Node,int>s
*ifmpp.find(node)===mpp.end()
*then mpp[nod]++;
ese
if found return true
*so here he code will be Node *temp=head;
map<Node,int>
while(temp!=NULL)
{
if(mpp.find(temp)!=mpp.end())
{
return true
}mpp[temp]++;
temp=temp->next;
}


bu here time complexity will be 0(n*logn)n for traversing ll and logn for map function and space complexity 0(n)
*so here the coderwill say optimize it
*
*now next intuition will be through the slow nad fast pointere  such so if (slow===fats)
{
return true
}
*so here stop cndtion will be while(fast->next!=NULL and fast!=NULL)
{
}
because if tis condition fail it mea its liner lnked list
*


*so suppose the distance between fast and slow is  then again fast mooves thn distance reduced to d-1 and at som epoint to 0 then at that time slow===fats and loop
*class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode *slow=head;
        ListNode * fast=head;
        while(fast!=NULL&&fast->next!=NULL){
            slow=slow->next;
            fast=fast->next->next;
            if(fast==slow){
                return true;
            }
        }
        return false;
    }
};
------------------------------------------------------------------------------------------------------------------------------------------------------------
*finding the starting node in the loop of the linkedlist
*1->2->3->4->5->6->7->8->9
                                         |                  |
                                         ------------------
*this linkedlist might have the loop or might ot have the loop if it ha loop,we need to return he starting point of the loop
*so if does not have the loop then retentor null
*so here also the basic intuition will be hashing which says map<Node,int>
while(temp!=NULL)
{
if(mpp.find(temp)!=mpp.end())
{
return temp
}mpp[temp]++;
temp=temp->next;
}


else it means it is the liner linkedlist return null
*now first thing will be todetect the loop i loop
*theh again take fast point at the colloding and another point at head and move by one step 
*if they again collide means which is the startinh point
*so now the code will be 
*Node *slow=head;
Node * fast=head;
while(fast!=NULL&&fast->next!=NULL)
{
slow=slow->next;
fast=fast->next->next;
if(slow==fast)\
{
slow=head;
while(slow!=fast)
{
slow=slow->next;
fast=fast->next;
}
return slow;
}

}
return null
*now 2 question comes in mind
*how do u know they will collide
*and if they collide then its the starting points
*so its ans is suppose slow and fast are at head
*slow move by slow=slow+3
*then fast will be move to fast=fast+6
*so here from head to starting is l1
*then from starting to th fast is also l1
*suppose distance between fast is alow is d
*then as we move the fast move sin anticlockwise direction 
*and slow move by 1
*so the tthen d reduce to d-1
*now slow an fast collide
*
*so fast must have travelled as 2d
*and slow as d
*so the kength of the lopp is l1+d
*so now take the reverse thing is distance between the starting point and collidibg pint is ds
*then between the colliding to the starting will be l1
*so they will collide
*
------------------------------------------------------------------------------------------------------------------------------------------------------------


*check if ll is palindrome or not
*a palindrome is a ll whose reverse is same as the ll
*consider the ll as 1->2->3->2->1
*o now brute force will be iterate and put all the data in stack
*now  again iterate and tak out st.top() am see if temp->data===st.pop() else
return false
*o here time complexity will be o(n)+o(n)
*and space complexity ill be o(n)
*bool isPalindrome(Node* head) {
    stack<int> st;
    Node* temp = head;

    // Push all elements to stack
    while (temp != nullptr) {
        st.push(temp->data);
        temp = temp->next;
    }

    // Reset temp to head again
    temp = head;

    // Compare stack top with linked list
    while (temp != nullptr) {
        if (temp->data != st.top())
            return false;
        st.pop();
        temp = temp->next;
    }

    return true;
}
so here time complexity will be o(2*n) nd space of 0(n)
*so now question is we ned to compare first half nodes  with the second halflp 8y6
*but problem is its singly linked list we cant move back
*lets take the 1->2->3->3->2->1
*we need to compare the first half with econd half as in above even linked lis
*but while comparing how we will move back in second half as its sigle linked list
*so to solve this problem lets reverse the second half by findin its mid
*and mid can be find b tortoise algo
*but in case of even we used to find the first m1 whie in tortoes we used to find the second m2 that is now condition of fast will be whie(fast->next->nex!=NULL)
*so the second half will start from the slow->next
*reverse(slow->next)
*this will return the newhead
*then check the iteration as newhaed will get exhausted first so while(newhead!=NULL)
{
if(firsthead->data!=secondhead->data)
{
reverse(newhead0;
retrun false;
}
}


*so here time complexity will be o(n) and space complexity will be o(1)
*/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
ListNode* reverse(ListNode* head)
{
    ListNode* prev=NULL;
    ListNode* temp=head;
    while(temp!=NULL)
    {
        ListNode* front=temp->next;
        temp->next=prev;
        prev=temp;
        temp=front;
    }
    return prev;

}
    bool isPalindrome(ListNode* head) {
        ListNode* fast=head;
        ListNode* slow=head;
        while(fast->next!=NULL&& fast->next->next!=NULL)
        {
            fast=fast->next->next;
            slow=slow->next;
        }
        ListNode* newhead=reverse(slow->next);
        ListNode* backhead=newhead;
        ListNode* fronthead=head;
        while(backhead!=NULL)
        {
            if(fronthead->val!=backhead->val){
                reverse(newhead);
                return false;
            }
            backhead=backhead->next;
            fronthead=fronthead->next;
            
        }
        reverse(newhead);
                return true;
        
    }
};
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*consider the linkedlist as 1->3->4->2->5->6---again
*so this question is segregate odd and even nodes
*so here odd index(1) nodes are 1,4,5 
*and even placed nodes are 3,2
*1->4->5->3->2->6
*so here the thing is we need to maeke the linked list of this
*so here basic intuition will be take temp and jump by 2 and store the data
*now in the second iteration iterate by taking temp as the head->next
*and store the data
*note that through any jump we get at last then after that we cant jump
*so after having segregated nodes in another created linked list we need to store then in place of the original node
*nOTE:that in case of odd linked list when temp is at the last node there temp!=NULL&&temp->next!=NULL become true and we left that last node
*so for the odd placed nodes while(temp!=NULL&&temp->next!=NULL)
{
temp=temp->next->next;
}
*in case of the odd linked list the last will be left so add that
*if(temp)
*temp.add(temp);
*then same process by taking the temp=head-->next
*finally iterate over the ll and put the arr data back in linked list
#include <vector>

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(NULL) {}
};

Node* segregateOddEvenUsingData(Node* head) {
    if (!head || !head->next) return head;

    std::vector<int> oddValues;
    std::vector<int> evenValues;

    Node* temp = head;
    int pos = 1;

    while (temp) {
        if (pos % 2 == 1) {
            oddValues.push_back(temp->data);
        } else {
            evenValues.push_back(temp->data);
        }
        temp = temp->next;
        pos++;
    }

    // Rewrite the values back into the list
    temp = head;
    for (int val : oddValues) {
        temp->data = val;
        temp = temp->next;
    }
    for (int val : evenValues) {
        temp->data = val;
        temp = temp->next;
    }

    return head;
}

*so here time complexity will be o(n) +o(n) and space of 0(n)


More optimized code
*so first step is changing link for odd nodes
*changing links for the even nodes
*so iterate ovet the odd and at same time iterate over the even
*and then the last condition till on the even as always even will be after odd
*odd->next=evenhead
*ListNode* oddEvenList(ListNode* head) {
        if(head==NULL||head->next==NULL){
            return head;
        }
        ListNode * odd=head;
        ListNode * even=head->next;
        ListNode *evenhead=even;
        while(even!=NULL&&even->next!=NULL){
            odd->next=odd->next->next;
            even->next=even->next->next;
            odd=odd->next;
            even=even->next;
        }
        odd->next=evenhead;
        return head;
        
    }
};
----------------------------------------------------------------------------------------------------------------------------------------------------
Merge 2 linked lists
*Brute

Approach:

Traverse both lists and store values in a vector or array.

Sort the array.

Create a new linked list from the sorted values.


Time to traverse list1 and push values: O(N)

Time to traverse list2 and push values: O(M)

Total time for this step = O(N + M)

➡️ Answer: Time taken to store values in array/vector is O(N + M)
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(NULL) {}
};

ListNode* mergeBrute(ListNode* l1, ListNode* l2) {
    vector<int> vals;

    while (l1) {
        vals.push_back(l1->val);
        l1 = l1->next;
    }
    while (l2) {
        vals.push_back(l2->val);
        l2 = l2->next;
    }

    sort(vals.begin(), vals.end());

    ListNode* dummy = new ListNode(-1);
    ListNode* curr = dummy;

    for (int v : vals) {
        curr->next = new ListNode(v);
        curr = curr->next;
    }

    return dummy->next;
}

Better
*ListNode* mergeBetter(ListNode* l1, ListNode* l2) {
    ListNode* dummy = new ListNode(-1);here dummy poiter
    ListNode* tail = dummy;

    while (l1 && l2) {
        if (l1->val < l2->val) {
            tail->next = new ListNode(l1->val);
            l1 = l1->next;
        } else {
            tail->next = new ListNode(l2->val);
            l2 = l2->next;
        }
        tail = tail->next;
    }

    while (l1) {
        tail->next = new ListNode(l1->val);
        l1 = l1->next;
        tail = tail->next;
    }

    while (l2) {
        tail->next = new ListNode(l2->val);
        l2 = l2->next;
        tail = tail->next;
    }

    return dummy->next;
}
so here time complexity will be o(n+m)  as each node s visited once and space complexity ill be o(n+m) as everyvalue new node is created
*and same space complexity 0(n+m) nodes created



Optimal
*Now here the thing is Listnode dummy(-1) Created on stack, not a pointer
*dummy is an object of type ListNode, not a pointer.
*ListNode* current = &dummy;  // current stores address of dummy ✅
*ListNode* mergeOptimal(ListNode* l1, ListNode* l2) {
    ListNode dummy(-1);             // just one dummy node on stack
    ListNode* current = &dummy;     // pointer to build the merged list

    while (l1 && l2) {
        if (l1->val < l2->val) {
            current->next = l1;     // reuse node from l1
            l1 = l1->next;
        } else {
            current->next = l2;     // reuse node from l2
            l2 = l2->next;
        }
        current = current->next;
    }

    current->next = l1 ? l1 : l2;   // attach remaining part
    return dummy.next;
}
f you were reusing original nodes (without new), space would be:

O(1) auxiliary space, just pointers rearranged

But you’d lose the original lists' structure

Note:It does not create any new nodes (unlike new ListNode(...) in brute/better versions).

It simply rearranges the next pointers of the already existing nodes from l1 and l2.


---------------------------------------------------------------------------------------------------------------------------------------------------
remove the nth node from the end
*1->2->3->4
*here n=2
*but in te singly linked list we cant traverse back so need to terat from the front
*Note:ere we need to tand at not at the node which is to be deleted we need to reach one node before
*so we need to stand one before the eleted node
*til length-2+1 is same as delet the node at the legth-2+1 pos
*now edge case if the length is also same as the count means delete the head of ll
*now in the case above we are tring to reach at the node which neds to be deleted and is lenght-2+1
*second is we want to reach node before the lenghth-2,one node before the deleted node

*so reaching one before deleted node is goal and that before node is at int cntlength-k
while(temp!=NULL)
{
cnt--;
if(cnt==-0)
{
break;
}
}
if(length==k)
{
Node *newnode=head;
head=head->next;
free(newne);
return head
}
Node deltednode=temp->next;
temp->next=temp->next-next;
free (deletnode)/this free in c++


now here time complexity will be o(n)for traversing to alculate the length and 0(length-k) for the reaching before node and space complexity ill be o(1)
*now the thing is that
*we want access of prevnode which we want but for that the length must be there 
*so we want previous node but without the length 
*so first take fast=haead and move till the k
*now take the slow=head anow slow and fast will move till the length by one
 step and slow will be the prev node
*now cae 
*arise that if the k=5 then the if fast==Null,return head->next;



class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *fast=head;
        for(int i=0;i<n;i++){
            fast=fast->next;
        }
        if(fast==NULL){
            return head->next;
        }
        ListNode *slow=head;
        
        while(fast->next!=NULL){
            fast=fast->next;
            slow=slow->next;
        }
        
      
            ListNode * delte=slow->next;
            slow->next=slow->next->next;
            delete delte;
            return head;
        
        
    }
};
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
*delete the middle node of ll
*consider the ll as the as 1->2->3->4->5
so for even case here as in tortoise in even we hav the second mid but here the middle will also be second middle
*now deleting 3 will be efficient if we reach one before the node
*so let it be the case of eve or odd the before node from md  will e floor of n/2
*o here edge cases will be if the head===NULL or head->next==NULL
*return NULL


So bruter forec will be take the calculate length then do length/2;
take cnt=length/2;
iterate than cnt-- at he node whwre cont==0 break and temp->mext=temp->next->next;
free(temp->next);



Note:here but i want slow must must one node before the mid nde so ere the code changes for the fast
*so here re according to tortoise we need slow one before the miidle
*so here slide change is 
skip one slow 
slow=head;
fast=head;
fast=fast->next->next;



while(fast->next!=NULL&&fast!=NULL)
{
slow=slw->next;
fast=fast->next->next;
}
Node * deete=slow->next;
slow->next=slow->next->next;
free(delte);

class Solution {
public:
    ListNode* deleteMiddle(ListNode* head) {
        if(head==NULL||head->next==NULL){
            return NULL;
        }
        ListNode * slow=head;
        ListNode *fast=head;
        fast=fast->next->next;
        while(fast!=NULL&&fast->next!=NULL){
            slow=slow->next;
            fast=fast->next->next;
        
        }
        ListNode *delte=slow->next;
        slow->next=slow->next->next;
        delete delte;
        return head;
        
    }
};
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
sort ll
*consider the ll as 3->4->2->1->5
*we will be given the integers and we need to sort the integers
*so sort then 1->2->3->4->5
*once done we need to return the head of the ll
*so here the exreemnaive solution will be while doing traversal store all elementsin  array
*so code will be temp=head;
while(temp!=NULL)
{
v.push_back(temp->data);
rtemp=temp->next;

}
sort(arr,arr+n);
int i=0;
while(temp!=NULL)
{
temp>data=arr[i];
i++;
}
a insertion in vector taje o(1) so here the time complexity wll be o(n)+o(n*logn) and space complexty will be 0(n)

*so now we dont want we should take extra space 
*lets implement merge sort here
*in arr mergesort(arr,low,high)
{
if(low>=high)
{
return ;
}
int mid=low+high/2;
mergesort(arr,low,mid);
mergesort(arr,mid+1,high);
merge(arr,low,mid,high);
}
*so here the edge case will be mergesort(head){
if(head==NULL||head->next==NULL)
{
return head;
}
node mid=findmiddle(head);//but maek a change here that the here slow should point to first mid1 not the second mid2
node firstll=mergesort(head);
node second ll=mergesort(slow->next);
merge(firstll,secondll);

}
merge(fisrthead,secondhead)
{
node *temp=new node(-1);
while(firstnode!=NULL&&secondhead!=

}














-------#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(NULL) {}
};

// Function to find the middle node
Node* getMiddle(Node* head) {
    if (!head || !head->next) return head;

    Node* slow = head;
    Node* fast = head->next->next; // To split at middle

    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow;
}

// Merge two sorted lists
Node* merge(Node* left, Node* right) {
    if (!left) return right;
    if (!right) return left;

    Node* result = NULL;
    if (left->data < right->data) {
        result = left;
        result->next = merge(left->next, right);
    } else {
        result = right;
        result->next = merge(left, right->next);
    }
    return result;
}

// Merge sort function
Node* mergeSort(Node* head) {
    if (!head || !head->next) return head;

    Node* mid = getMiddle(head);
    Node* rightHead = mid->next;
    mid->next = NULL; // Split list into two halves

    Node* left = mergeSort(head);
    Node* right = mergeSort(rightHead);

    return merge(left, right);
}

// Helper to print list
void printList(Node* head) {
    while (head) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

// Example usage
int main() {
    Node* head = new Node(4);
    head->next = new Node(2);
    head->next->next = new Node(1);
    head->next->next->next = new Node(3);

    cout << "Original: ";
    printList(head);

    head = mergeSort(head);

    cout << "Sorted: ";
    printList(head);

    return 0;
}
so ere rge time complexity will 0(nlogn) but here the we are not using space complexity of 0(n) we are not creating the node using new node we are just resuing the node of the linkedlist
-----------------------------------------------------------------------------------------------------------------------------------------------------
sortthe ll containing 0s and 1s an 2s
*initially w have the lnked list as the 1->0->1->2->0->2->1
*tansform this ll i sorte orders such that irst 0s and hen 1s and 2s
*0->0>1->1->1->1->2
*so the brute force solution will be 
*so here brute fore solution will be take three variable cnt0=0,cnt1=0,ct2=0 then iterate while(temp!=NULL)
{}
*if temp->data==0 then cnt++ else if temp->data==1 thenct1++ else cnt2++;
*then make the new 
*so the code will be 
*tmp=head;
while(temp!=null)
{
i(temp->data==0)
{
cnt0++;
}else if(cnt1->data===1)
{
cnt1++;}else{
cnt2++;
}}

temp=head
while(temp!=NULL)
{
if(cnt0)
{temp->data=0;cnt--;
}
if(cnt1)
{
temp->data=1;
cnt1--;
}
if(cnt2)
{
temp->data=2;
cnt2--;
}

}
*here time complexity will be o(2*n)
*and space complexity will be o(1)
*so we need to do it in one pass
*so we can do this only once  if we have the separate the ll containing 0s 1s and 2s
*so these dummy nodes first zeohead ,onehead ,secondhead containing first nodes as -1
*so then traverse then ll and if(temp->data==0)
{
temp->next=tem->data;
temp=node
}
*now the zeroll tail will point to one head of only one head has the ones
*  Node* segregate(Node* head) {
        Node *zerohead=new Node(-1);
         Node *onehead=new Node(-1);
          Node *twohead=new Node(-1);
          Node *zero=zerohead;
          Node *one=onehead;
          Node *two=twohead;
          Node *temp=head;
          while(temp!=NULL){
              if(temp->data==0){
                  zero->next=temp;
                  zero=temp;
              }else if(temp->data==1){
                  one->next=temp;
                  one=temp;
              }else{
                  two->next=temp;
                  two=temp;
              }
              temp=temp->next;
          }
          zero->next=onehead->next?onehead->next:twohead->next;
          one->next=twohead->next;
          two->next=NULL;
          return zerohead->next;
        

        // Add code here
    }
*here zero one two for iterating and making and in last connecting the link if one next is possible and need not to chech two->next
------------------------------------------------------------------------------------------------------------------------------------------------------------
*find the intersection point of the y ll
*we will be given the 2 ll
*and we will be given the head of the ll
*and we need to find the first intersection point of the common nodes between them 
*so weneed a node that is alos in the ll 1 and alos in the linked list 2
*so we can start with naive solution as the we can store all the nodes of first the one ll
*map<node,int>
*then iterate over the second ll and if you find that then the mp.find(nod)!=mpp.end()
*return node
*so here the code naive will be 
*node temp=head1;
while(temp!=NULL)
{mpp[temp]++;
temp=tem->next;
}
temp2=head2;
while(tem2!=NULL)
{
if(mpp.find(temp)!=npp.end())
{
return temp2;
}
}
return NULL
*so here time complexity will be0(n(logn)+o(m*logm)
Note:here mpp is map and find takes the logm
*
*consider the 2 ll as 3->1->4->6->2
*and another ll as 1->2->4->5->4->6->2
*we cant traverse simulatenously as one linked list ong one is shorter
*
*so we can do the intraversal comparison if and only from the longer ll we move 2 step inside as the diffrenec between longer and shorter ll length is 2
*another solution we can figure out is while(temp!=NULL)
{
length++;
temp1=temp->next;
}
while(temp2!=NULL)
{
length2++;
temp2=temp2->next;
}
thenmake function that takes the smallest head,longest haead and diiference of 2
*if(l1<l2)
{
collisonhead(head1,head2,length2-lngth1)
else
{
collisonhead(head2,head1,length1-lngth2)

}
*
}Note here head2 is greater and head1 is smaller
*
*incloosionhead()
{
while(d)
{
head2=head2->next;
d--;
}
while(temp1!=temp2)
{
temp1=temp1->next;
temp2-temp2->next;
}
return t1
}
so here time complexity will be o(n1+2(n2))
*so now traverse both
*so basically we need to meet at some points 
*so iterate both simultaneously and if ne reach the tail ve  ti otger head
*same with other
*Node*t1=head1;
Node *t2=head2;
while(t1!=t2)iterate krte raho
{
t1=t1->next;
t2=t2->next;i
if(t1==t2)
{
return t1;
}/here it return case  colliding  as well as colliding
if(t1==NULL) t1=head2;
if(t2==NULL)
{
t2=head1;
}

}
*
------------------------------------------------------------------------------------------------------------------------------------------------------------
So we will be given a number in terms of linkedlist
*1->5->9
*so here if i add 1 
*so the number is 160
*we need to return the 160 in terms of linkedlist
*So the brute force to this is we need to iterate backwards
*so we cant iterate back in sinhly so we will reverse the linked list
*so fater revrseal it will be 9->5->1
*and now the lets have the carry =1 as we need to add 
*add carry to the temp->data
*if value>=9
*so the 0 will be stored in temp data
*and update the carry to 1
*if the value<=9
*store the temp data 
*and update the carry as 0
*Note:ant any point if the carry is 0 break out
*finally revrse
*Note :suppose 9->9->9 in this case result will be 1000
*so if in case temp is null and caryy is not equal to 0 then reverse the linke list and make new node with carry and newnode next=head
*class Solution {
public:
    ListNode *addOne(ListNode *head) {
        int carry=1;
        ListNode * temp=head;
        ListNode * prev1=reverse(head);
        while(temp!=NULL)
        {
            temp->data=temp->data+carry;
            if(temp->data<=9)
            {
                carry=0;
                break
            }else
            {
                temp->data=0;
                carry=1;
            }
        }
        if(carry)
        {
            ListNode * newnode=new ListNode (1);
            ListNode *prev2=reverse(prev1);
            newnode->next=prev2;
            return newnode;
        }
        ListNode *prev3=reverse(prev1);
        return prev3;




    }
so  e time complexity will be o(3*n)


So usig recursion
*/*
Definition of singly linked list:
struct ListNode
{
    int val;
    ListNode *next;
    ListNode()
    {
        val = 0;
        next = NULL;
    }
    ListNode(int data1)
    {
        val = data1;
        next = NULL;
    }
    ListNode(int data1, ListNode *next1)
    {
        val = data1;
        next = next1;
    }
};
*/

class Solution {
public:
    // Helper function to perform the recursive addition
    int helper(ListNode *temp) {
        if (temp == NULL) {
            return 1; // carry = 1 for the last digit (adding one)
        }

        int carry = helper(temp->next);
        temp->val += carry;

        if (temp->val < 10) {
            return 0; // no more carry
        } else {
            temp->val = 0;
            return 1; // carry over to previous node
        }
    }

    // Main function to add one to the number
    ListNode *addOne(ListNode *head) {
        int carry = helper(head);
        if (carry == 1) {
            ListNode *newnode = new ListNode(1); // create new head node if there's carry
            newnode->next = head;
            return newnode;
        } else {
            return head;
        }
    }
};


------------------------------------------------------------------------------------------------------------------------------------------------------------
Add 2 numbers in aliked list
*we are given 2 numbers and thos 2 numbesr are in reverse order
*2->4->6->null,numbers is 642
*3->8->7->null number is 387
*so basially the result of 642 and 783 is 1425
*now we need to make the ll and putit in reverse order
*now hen we sum we startfrom the unit place and sowe are given we just need to add and mve the carry
*we will take the 2 temp variables temp1 and temp2 nw traverse and take some dummy nde which store -1 and curr node pointing to dummy node
*if sum <10now the sum is stored in curr-->next then curr=0
* if greater than 10 then curr->next=sum%10 and carry=1

*so step is traversal than sum of temp1->data+temp2->data+carry
*if sum<10 than current->next=sum carry=0;else current->next=sum%10 and carry=1
*at last when out of while loop than currr->next=carry;
*and then return dummynode->next
*/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode * temp1=l1;
         ListNode * temp2=l2;
         ListNode * dummynode=new ListNode(-1);
        ListNode * curr=dummynode;
        int carry=0;
        int sum=0;
        while(temp1!=NULL||temp2!=NULL){
            sum=carry;
            if(temp1){
                sum=sum+temp1->val;
                
            }
            if(temp2){
                sum=sum+temp2->val;
                
            }
            ListNode *newnode=new ListNode(sum%10);
            carry=sum/10;
            curr->next=newnode;
            curr=newnode;
            if(temp1){
                temp1=temp1->next;
            }
            if(temp2){
                temp2=temp2->next;
                
            }
            
            
            
        }
        if(carry){
            ListNode *newnode=new ListNode(carry);
            curr->next=newnode;
            
        }
        return dummynode->next;
        
        
    }
};
note:here i have added this this while bcz if one exhaust still contunir
*and for iterating iterate when next is not null
so sum is carry then add if node exist than ext nide sum and then make new node and adjust pointer and update th ecarry

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*
Delete all the occurrence of the given key in the dll
*10->4->10->10->6->10
*now after the dleteion new linked list will be 4->6
*so basically we will traverse the linked list and iftemp->data==key
*we need to dlete that 
*and in also that if its head than we need to move the head
*head=head->next//rocess for makig the new ll
*now the netnode  temp->next
*and prev=Null
*now nextnode->prev=prevnode
*prevnode->next=nextnode
*free temp
*now temp=nextnode
*
 void deleteAllOccurOfX(struct Node** head_ref, int x) {
        // Write your code here
      Node* temp = *head_ref;

        while (temp != NULL) {
            if (temp->data == x) {
                // If the node to delete is the head
                if (temp == *head_ref) {
                    *head_ref = temp->next;
                    if (*head_ref != NULL) {
                        (*head_ref)->prev = NULL;
                    }
                } else {
                    // Update pointers for deletion
                    if (temp->prev) {
                        temp->prev->next = temp->next;
                    }
                    if (temp->next) {
                        temp->next->prev = temp->prev;
                    }
                }
                // Move to the next node and delete the current one
                Node* toDelete = temp;
                temp = temp->next;
                delete toDelete;
            } else {
                // Move to the next node if no deletion
                temp = temp->next;
            }
        }
    }
};
-----------------------------------------------------------------------------------------------------------------------------------------------------------

*Finding pairs with the given sum  the dll which is sorted
*so we will be given the linked list which is sorted and will be given its head
*1->2->3->4->5
*so sum is 5
*so pairs can be 1,4
*2,3
*so here the take first tmp1=head
*
*while(temp!=Null &&temp->next!=null)
{
temp2=temp2->next;
while(temp2!=null)
{
if(temp1->data+temp2->data;
ans.push_bac()
}
}
*for more optimizations we can write while(temp2!=null&&temp1->data+temp2->data<=sum)
{
if(temp1->data+temp2->data;
ans.push_bac()
}

*so time complexity willbe o(n*n)
*so here again we will take 2 pounter left and right
*so here again take leftleft=head
*snd right=tail;
*while(left->val<=right->val)
{
if(left->val_right->val==sum)
{
ds.push_ back()
left=left->next;
right=ight->prev;
}
if(
left->val_right->val<sum)
{
left=left->next;
}else
{
right=right->prev;
}

}
and on gfg
*class Solution
{
public:
Node * findtail(Node *head) 
{
    Node * temp=head;
    while(temp->next!=NULL)
    {
        temp=temp->next;
        
    }
    return temp;
}

    vector<pair<int, int>> findPairsWithGivenSum(Node *head, int target)
    {
        // code here
        vector<pair<int, int>>ans;
        
        Node *lptr=head;
        Node *rptr=findtail(head);
        while(lptr->data<rptr->data)
        {
            if(lptr->data+rptr->data==target)
            {
                ans.push_back({lptr->data,rptr->data});
                lptr=lptr->next;
                rptr=rptr->prev;
                
            }else if(lptr->data+rptr->data<target)
            {
                lptr=lptr->next;
                
            }else
            {
                rptr=rptr->prev;
            }
        }
        return ans;
        
        
    }
};
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*Remove duplicates from the sorted ll
*consider the 1->1->1->2->3->3->4
*so basically what happens is that the while(temp!=NULL&&temp->next!=NULL)
{
tem2=temp->next;
while(tem2!=Null&&tem2->data==temp->data)
{
temp2=tmp2->next;
}
temp->next=temp2;
here make the check 
temp2->prev=temp;
temp=temp2;
}
so here net time complexity will be as outer loop goes 4 and inner 3 hence total is 7
*
class Solution
{
public:

    Node * removeDuplicates(struct Node *head)
    {
        // Your code here
        Node *temp=head;
        while(temp!=NULL&&temp->next!=NULL)
        {
            Node * temp2=temp->next;
            while(temp2!=NULL && temp2->data==temp->data)
            {
                Node *duplicate=temp2;
                temp2=temp2->next;
                free(duplicate);
            }
            temp->next=temp2;
            if(temp2)
            {
                temp2->prev=temp;
            }
            temp=temp2;
        }
        return temp;
    }
};
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Reverse nodes in the gk group
*we are given the 1->2->3->4->5->6->7->8->9->10
*wenee to reverse in the sizof of group 3
*3->2->1>6>5->4->9->8->7->10
*so bascally we have the groups ossize 3 as 3
*from reversing the first grup we will get the updated head
*so what we will do when reversing a linked list we reverse the linkelst nt apart so we need o make the grou a linkelist
*so we will take temp=headand another point which will reach the tail of the linked list of the group1
*so reverse it than newhead returned=kthnode
*and tail=temp
*now the head will also get updated as head=kthnode
*now i want to got second group one cant go so first when we were iterating and breaking down the link store the next
*so take temp=head
*while(temp!=NULL)
{
Node *kth=findnextnode(temp,k)
if(kthnode==Null)
{
break;
}
Node *nextn=kth->nexr;

kth->next=null;
reverse(temp)
if(temp==head)
{
head=kth
}
else
{
prevnode->next=kthnode
}
prev=temp;
temp=nextnode

}
*we want nextnode iterating over the temp
Node *nextnode=findnextnode(temp,k)
*
Node *iterate=temp;
while(k--)
{
itearte=itearte->nex
}
return iterate





lass Solution {
public:
ListNode* reverse(ListNode* head)
{
ListNode*temp=head;
ListNode* prev=NULL;
while(temp!=NULL)
{
    ListNode* front=temp->next;
    temp->next=prev;
    prev=temp;
    temp=front;
}

return prev;
}
ListNode* findkthnode(ListNode* head, int k)
{k=k-1;
    while(k>0)
    {
k--;
head=head->next;
    }
    return head;
}
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* temp=head;
        ListNode* prev=NULL;
        while(temp!=NULL)
        {
            ListNode* kthnode=findkthnode(temp,k);
            if(kthnode==NULL)
            {
                break;
            }
            ListNode* nextnode=kthnode->next;
            kthnode->next=NULL;
            reverse(temp);
            if(temp==head)
            {
                head=kthnode;
            }else
            {
                prev->next=kthnode;
            }
            prev=temp;
            temp=nextnode;

        }
        return head;
        
    }
};
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Rotate a linked list
*1->2->3->4->5
*so if i roate it 1 time then last elemnt will come to the first position
*5->1->2->3->4
*and one more time then the 4->5->1->2->3
*so after the final rotation tail->next=prev
*and then we need the 3 rd node which is 5-2=3
*but after getting the 3 rd node then store its next
*then temp->next=NULL
*so this case if the value of k is small
*if the value of the k is large
*if k==lenth,we will be again back to original configurations
*or if its the multiple of length it will come to original configurations
*/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:

 ListNode* findkth(ListNode* head, int k) 
 {
int cnt=1;
while(head!=NULL)
{if(cnt==k)
{
    return head;
}
    head=head->next;
    cnt++;
}
return head;

 }
    ListNode* rotateRight(ListNode* head, int k) {
      if (head == NULL || head->next == NULL || k == 0) {
            return head;
        }

        // Step 1: Calculate the length of the linked list.
        ListNode* temp = head;
        int len = 1;  // Start with 1 since we are counting the head node.
        while (temp->next != NULL) {
            len++;
            temp = temp->next;
        }

        // Step 2: Create a circular linked list.
        temp->next = head;

        // Step 3: Find the effective number of rotations.
        k = k % len;  // In case k is larger than the list length.
        int rotatePoint = len - k;  // Position to break the loop.

        // Step 4: Find the new head and break the loop.
        ListNode* kth = findkth(head, rotatePoint);  // Find the k-th node.
        ListNode* newHead = kth->next;  // The next node becomes the new head.
        kth->next = NULL;  // Break the circular reference.

        return newHead;
        


        
    }

};
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------


stack is the data structure that store the data and its type can be any
*it follows the lastin firfst ot data structure measn the elment that is put at last will be pop out
*queuet is also the data structure that allows fifo
*in the queue data structure the the lement at first wll be pop out
*so here in the queue the top we will see from the frot side
*so firstof we will implement stack using the array and to implement array w need the size
*so here we must know the size of array means size of an stack we cant make the array as dynamic
*so lets implement stack using array
*int arr[10];
*lets tae top=-1 //this is used for the iteration aover and we will use tgeh array
*and if anyone says push(4)
*so top++ then arr[top]=4
*then pop() thus top--
*then asked top() then check if top==-1 then means no element in stack elsearr[top] will be the top element
*stack impl{
int arr[10],int top=-1;
push(x)
{
top++;
if(top>=10)
{
stack is full
}
arr[top]=x;
}
int top()
{
if(top==-1
{
stack is empty
}else
{
 return arr[top]
}

}


pop()
{
if(top==-1)
{
do no do top--
}else
{
top--;
}


}
size()

{
return arr[top]
}
}



oid MyStack ::push(int x) {
    
    top++;
    if(top>=1000)
    {
        printf("stack is full");
    }else
    {
        arr[top]=x;
    }
    // Your Code
}

// Function to remove an item from top of the stack.
int MyStack ::pop() {
    int el;
    if(top==-1)
    {
        return -1;
    }else
    {
         el=arr[top];
        top--;
    }
    return el;
    // Your Code
}

*now the implementation of the queue using the array
*int aueue[4]
*and here we will be usinh that start and the end =-1
*and then currsize=0;
*push(4) we will see that the currsize is 0 an we have the capacity of 4
*and if start and end ==-1 then the start++ and end++ and arr[end]=4 and then currsize++;
*then again push(5) then see cuursize,size then check if(start==-1 and end==-1) if not then end++ then arr[end]=x;
*then top()  return arr[start]
*here if at any point my end>=size then end=0 and arr[end]=x


*then pop()
*now here again we will check if we have elements to pop out thus currsize<size
*then start ++;then currsize--
*now here also at any point if(start>=size)
{
start=0;
}
*



queue impl
{
push(x)
{
if(currsize==size)
{
empty
}
if(currsize==0)
{
start=0;
end=0;
}else
{
end=(end+1)%size;
}


then arr[end]=x;
currsize++;



}





pop()
{
if(currsize==0)
{
measn it also empty
}means we need to destroy
int el=queue[start]
if(currsize==1)
{
start=-1;
end=-1

}
else
{
start=start+1;
currsize--
}


return el;
}
}




-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
recursion series
*when a function calls itself f()
{
f()
}
*take an example as main()
{
f()
}
void f()
{
print(1);
f();
}
*on output we will se 1 1 1.....infinite
*s this is the infinite recursion
*so what happens due to the infinite recursion is the stack overflow in which function call at some line wait for next function to be excuted due to which this function call is not completed yet
*this is called the segmentation fault when any function call at some line wait for next to be complete and stack over each other
*now the condition which we use to stpop the unction call is called the base condition
*so i want value till 3 if no further function call just stop the execution there and retun
*due to this stopaage allo other function the stack space also gets terminated
*---------------------------------------------------------------------------------------------------------------------------------------------------------------------
*print name neha n times usin recursion
*so take input n form user
*something which will make the base condition
*then print it
*increase it for next fundtional call
*f(int i,n)
{
if(i>n)
{
return;
}
print(i);
f(i+1,n)
}


main()
{
cin>>n;
f(1,n);
}
*here time complexity will be o(n) and space complexity is not any ds but internal memory space of stack amd that also o(n)
*print from n to 1
*so f(i)
{
if(i<1)
{
return;
}
print(i);
f(i-1);

}

main()
{
cin>>n;
f(n);
}


----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*so now again the question print from 1 to n but this time using the backtracking
*means now f(i+1,n) but now not allowed now f(i-1,n);
* for that f(n,n)
*base condition also changed if(i<1)
{
reurn 
}
*and now the print come after f(i-1,n)
*so now point comes even after taking the n,n we can linraly print the 1,2,3
note:*so here backtracking first base case met than the first print of just before function calls executed
*
----------------------------------------------------------------------------------------------------------------------------------------------------------------------



Stacks and queues
*stack follows the lifo and it supports push,pop,top,size
*and to  implement stack using the array
*consider array as without index and baed on the index everything works
*we need sizr so take in size
*then takes the top=-1
*then the if operation is push(x) then top++ and arra[top]=x
*if pop then top--
*and if someone ask the check if top==-1 stack is empty else than return arr[top]
*if someone says the size thn top+1
*#include <iostream>
using namespace std;

class Stack {
private:
    int arr[10];  // Fixed size array
    int top;      // Index of the top element

public:
    Stack() {
        top = -1;  // Stack is initially empty
    }

    // Push operation
    void push(int value) {
        if (top >= 9) {
            cout << "Stack Overflow! Cannot push " << value << endl;
            return;
        }
        arr[++top] = value;
        cout << value << " pushed into stack." << endl;
    }

    // Pop operation
    void pop() {
        if (top < 0) {
            cout << "Stack Underflow! Nothing to pop." << endl;
            return;
        }
        cout << arr[top--] << " popped from stack." << endl;
    }

    // Peek operation
    int peek() {
        if (top < 0) {
            cout << "Stack is empty." << endl;
            return -1;
        }
        return arr[top];
    }

    // Check if the stack is empty
    bool isEmpty() {
        return top == -1;
    }

    // Check if the stack is full
    bool isFull() {
        return top == 9;
    }

    // Size of the stack
    int size() {
        return top + 1;
    }
};

int main() {
    Stack s;

    // Try pushing more than 10 elements
    for (int i = 1; i <= 11; ++i) {
        s.push(i * 10);
    }

    cout << "Top element is: " << s.peek() << endl;

    // Pop all elements
    while (!s.isEmpty()) {
        s.pop();
    }

    // Try popping from empty stack
    s.pop();

    return 0;
}
*Note:✅ Use Stack s; when:
You don’t need dynamic memory.

The object’s lifetime is well scoped (like inside main() or a function).

It's simpler and safer (no new/delete).


*Implement the queue using the array
*as inlast stack we can compute size by the top here we dont than the we cmoute isze by the push operation
*if push then start++,end++ and arr[start]=x;currsize++
*again push check the size of the size of rray and if the start and end both nt poining to -1 than only end++ and arr[end]=x
*and if we are asked about the top then the arr[start]
*if pop gaian check if something to pop then the start++ and cnt--
*if at any time any push we asked and the end reaches the last then the end=(end+1)%size
*and if one element and asked pop simply put start and end to -1
*


#include <iostream>
using namespace std;

class Queue {
private:
    int arr[10];
    int size;
    int currSize;
    int start;
    int end;

public:
    Queue() {
        size = 10;
        currSize = 0;
        start = -1;
        end = -1;
    }

    // Push operation (enqueue)
    void push(int x) {
        if (currSize == size) {
            cout << "Queue Overflow! Cannot insert " << x << endl;
            return;
        }

        if (start == -1) {
            // First element
            start = 0;
            end = 0;
        } else {
            end = (end + 1) % size;
        }

        arr[end] = x;
        currSize++;

        cout << x << " enqueued. Start = " << start << ", End = " << end << endl;
    }

    // Pop operation (dequeue)
    void pop() {
        if (currSize == 0) {
            cout << "Queue Underflow! Nothing to pop." << endl;
            return;
        }

        cout << arr[start] << " dequeued." << endl;

        if (currSize == 1) {
            // Only one element
            start = -1;
            end = -1;
        } else {
            start = (start + 1) % size;
        }

        currSize--;
    }

    // Peek front element
    int front() {
        if (currSize == 0) {
            cout << "Queue is empty." << endl;
            return -1;
        }
        return arr[start];
    }

    // Check if queue is empty
    bool isEmpty() {
        return currSize == 0;
    }

    // Get size of the queue
    int getSize() {
        return currSize;
    }
};

int main() {
    Queue q;

    q.push(10);
    q.push(20);
    q.push(30);
    q.push(40);

    cout << "Front element: " << q.front() << endl;

    q.pop();
    q.pop();

    q.push(50);
    q.push(60);
    q.push(70);
    q.push(80);
    q.push(90);
    q.push(100);
    q.push(110);  // Will wrap around
    q.push(120);  // Should cause overflow

    cout << "Final front: " << q.front() << endl;
    cout << "Current size: " << q.getSize() << endl;

    return 0;
}

Implement stack using the linkelist
*so when asked to push(2) make node and its nxt poiying to top and top=newnode
*and top() will give top-.datra
*when asked to pop than temp=top and then top=top->next delete temp
*#include <iostream>
using namespace std;

// Node definition
class Node {
public:
    int data;
    Node* next;

    Node(int value) {
        data = value;
        next = nullptr;
    }
};

// Stack class using Linked List
class Stack {
private:
    Node* top;  // Pointer to the top of the stack

public:
    // Constructor
    Stack() {
        top = nullptr;
    }

    // Push operation
    void push(int value) {
        Node* newNode = new Node(value);
        newNode->next = top;
        top = newNode;
        cout << value << " pushed to stack." << endl;
    }

    // Pop operation
    void pop() {
        if (top == nullptr) {
            cout << "Stack Underflow! Nothing to pop." << endl;
            return;
        }
        Node* temp = top;
        cout << top->data << " popped from stack." << endl;
        top = top->next;
        delete temp;
    }

    // Peek operation
    int peek() {
        if (top == nullptr) {
            cout << "Stack is empty." << endl;
            return -1;
        }
        return top->data;
    }

    // Check if stack is empty
    bool isEmpty() {
        return top == nullptr;
    }

    // Destructor to free all memory
    ~Stack() {
        while (top != nullptr) {
            Node* temp = top;
            top = top->next;
            delete temp;
        }
    }
};

// Test the stack
int main() {
    Stack s;

    s.push(10);
    s.push(20);
    s.push(30);

    cout << "Top element is: " << s.peek() << endl;

    s.pop();
    s.pop();
    s.pop();
    s.pop();  // Underflow case

    return 0;
}
*Implement the queue using the linked list
*firs the size=0;then start=NULL=end
*if push operation than check if the strat an end to NUll then make he strat an end point to new node
*else endnode->next=newnode
*end=newnode
*if asked to pop tae temp=starr
*start=start->next
*free temp
*if again pop and start->next==NULL than start abd end should be NULL
*#include <iostream>
using namespace std;

// Node class for Linked List
class Node {
public:
    int data;
    Node* next;

    Node(int value) {
        data = value;
        next = nullptr;
    }
};

// Queue class using Linked List
class Queue {
private:
    Node* front;  // Points to the front node
    Node* rear;   // Points to the last node

public:
    // Constructor
    Queue() {
        front = rear = nullptr;
    }

    // Enqueue operation (push at rear)
    void enqueue(int value) {
        Node* newNode = new Node(value);

        if (rear == nullptr) {
            // Queue is empty
            front = rear = newNode;
        } else {
            rear->next = newNode;
            rear = newNode;
        }

        cout << value << " enqueued." << endl;
    }

    // Dequeue operation (remove from front)
    void dequeue() {
        if (front == nullptr) {
            cout << "Queue Underflow! Nothing to dequeue." << endl;
            return;
        }

        Node* temp = front;
        cout << front->data << " dequeued." << endl;
        front = front->next;

        if (front == nullptr) {
            // Queue becomes empty
            rear = nullptr;
        }

        delete temp;
    }

    // Peek operation (get front value)
    int peek() {
        if (front == nullptr) {
            cout << "Queue is empty." << endl;
            return -1;
        }
        return front->data;
    }

    // Check if queue is empty
    bool isEmpty() {
        return front == nullptr;
    }

    // Destructor to free memory
    ~Queue() {
        while (front != nullptr) {
            Node* temp = front;
            front = front->next;
            delete temp;
        }
    }
};

// Test the Queue
int main() {
    Queue q;

    q.enqueue(10);
    q.enqueue(20);
    q.enqueue(30);

    cout << "Front element: " << q.peek() << endl;

    q.dequeue();
    q.dequeue();
    q.dequeue();
    q.dequeue();  // Underflow case

    return 0;
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*Implement stack using the queue
*we will keep structure same just that the ordering we will do 
*Note here we will use the st::queye and here rhe front and back works
*#include <iostream>
#include <queue>
using namespace std;

class Stack {
private:
    queue<int> q;

public:
    // Push element onto stack
    void push(int x) {
        q.push(x);
        int size = q.size();
        // Rotate the queue to make the last added element the front
        for (int i = 0; i < size - 1; i++) {
            q.push(q.front());
            q.pop();
        }
    }

    // Removes the element on top of the stack
    void pop() {
        if (q.empty()) {
            cout << "Stack Underflow\n";
            return;
        }
        q.pop();
    }

    // Get the top element
    int top() {
        if (q.empty()) {
            cout << "Stack is empty\n";
            return -1;
        }
        return q.front();
    }

    // Check if the stack is empty
    bool empty() {
        return q.empty();
    }

    // Get the size of the stack
    int size() {
        return q.size();
    }
};

// Sample usage
int main() {
    Stack st;
    st.push(10);
    st.push(20);
    st.push(30);

    cout << "Top: " << st.top() << endl; // 30
    st.pop();
    cout << "Top after pop: " << st.top() << endl; // 20

    cout << "Is empty: " << (st.empty() ? "Yes" : "No") << endl;
    cout << "Size: " << st.size() << endl;

    return 0;
}
Note stack hetre arrangement in queue is 1->2->3 and in order of pushing from left to right
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Implement queue usingthe stack
*So first thing will be the while pushing in stack first we will make 2 stacks
*than the before pushing shit all elements from s1 to s2
*then push in s1
*then all elements fro s2 to s1
*classs queue{
stack<int>s1,stack<int>s2
push(x)
{
while(s1.size())
{
s2.push(s1.top());
s1.pop()
}

}
s1.push(x);
while(s1.size())
{
s1.puhs(s2.top());
s2.pop();
}
}


top()
{
so (s1.empty())
{
return "empty"
}
else
{
return s1.top()
}
}
Note:So here the time complexity will be push will be takig time ofo(n) as push takes 1 but we are iterating frirst from s1 then from s2
Note:So here the space complexity will be 0(n) as the elements that any stack can store is 0(n)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Balanced prnetheis
*given the strig and it conatisn only backets
*now we have to check if he string is valid parenthesis or not
*every opening bracket must have the same closing type brackets
*everyclosingbracket must have the opening parenthesis of same tpype
*and it must have the sam order as well
*string s=()[{}()]
*so iam looking for that for every) there must be some opening befor and must be of same type
*and i am looking for attest last 
*sothe datastructure we willse will be stack
*so store the ( backet and whenever you find the closonh of sme then pp it fom stack
*class Solution {
public:
    bool isValid(string s) {
        stack<char>st;
        for(int i=0;i<s.size();i++)
        {
            if(s[i]=='('||s[i]=='['|| s[i]=='{')
            {
                st.push(s[i]);
            }else{
                if(st.empty())
                {
                    return false;
                }
                char ch=st.top();
                st.pop();
                if((s[i]==')'&&ch=='(')||(s[i]=='}'&&ch=='{')||(s[i]==']'&&ch=='['))
                {

                }else
                {
                    return false;
                }
            }
        }
         if(st.empty()) return true;
        else return false;
        
    }
};
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Min stack
*the inbuilt stack does not support getMin operation
*we have 12,15,10 in stack in this order
*and if i said getmin means minimum of all the values
*so the brute forec will be going throught stack and find minimum and it will take the time complexity of 0(n)
*so what now for more better approach will be the if in  pair we can store the elment and secod will be the min from all values
*Note:so pushing any elemnets check the top element minimu and current minimum will be the top minimum
*class st{
stack<pair<int,int>>st;
push(x)
{
if(st.empty())
{
st.push({x,x});
}
}
else
{
mini=min(x,st.top().second;
st.push(val,mini)
}
getmin(){
st.top().second
}


}
S here time complexity will be the o(1) and space complexity will be the o(2*n) one for stack and one for pair


*Now we need to store the pair i stack as its increasing the spacve complexity
*take as ittaion we insert 12 and then min=12 
*then 15 push hence min=12
*then 10 then min=10 
*then pop then 10 pop
*now get min is still 10 now the its hould be 12
Note:So here to solve the problem whenever we need to update the minimum
*then then val to push in stack is 2*val-prevminimum
*and then repca minimum to 10 or then val
*whenever we modify then top will be the minimum
*Note:we check we modufy or not if val>min not modifed else modified
*

stack
push(x
{
if(st.empty)
{
mini=x;
st.push(x);
}else
{
if(min>x)
{
st.push(2*x-mini);
mini=x
}else
{
st.push(x);
}
}

pop()
{
if(st.empty()
{
return;
}

int op=st.top();
t.pop();
if(op>mini
}else
{
mini=2*mini-op
}
}

top()
{
if(mini>st.top())
{
return mini
}
else
{
return st.top();
}
}

getmin(){
return mini}
class MinStack {
    int mini=INT_MAX;
    stack<int>st;
public:

    MinStack() {
        
    }
    
    void push(int val) {
        if(st.empty())
        {
            st.push(val);
            mini=val;
        }else if(mini>val)
        {
            st.push(2*val-mini);
            mini=val;
        }else
        {
 st.push(val);
        }
        
    }
    
    void pop() {
        int worldtop=st.top();
        st.pop();
        if(worldtop<mini)
        {
            mini=2*mini-worldtop;
        }
        
    }
    
    int top() {
        if(st.top()<mini)
        {
            return mini;
        }else
        {
            return st.top();
        }
        
    }
    
    int getMin() {
        return mini;
        
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */



----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Priority of operators
* power,* /,+ -
*when he operators  in between operandsthen its called infix expression
*when the operators are before the operands ,its prefix expression
*when the opeartors are afters the operands then its postfix expression
1.Infix to postfix expression
*take the int i=0 for looping
*take stack st
*if its operands add ans as we want prefix expression
*ans if its  operands than push into stack if and at ny int if a[i]>st.top() an wala rishtedarr n stack is greater then push in stack

*else pop if ts stck op is precedence graetet then the a[i]
*
*and f its ( then also push in stack
*if ) than pop till the ( found
*Initialize an empty stack for operators and an empty list for output.
Scan the infix expression from left to right.
For each token:
Operand (A-Z, 0-9): Add to output.
Left Parenthesis (: Push to stack.
Right Parenthesis ): Pop from stack to output until ( is found.
Operator (+, -, *, /, ^):
While the stack is not empty and the top of the stack has higher or equal precedence, pop to output.
Push the current operator to the stack.
After scanning, pop all remaining operators from the stack to output.
#include<bits/stdc++.h>

using namespace std;

//Function to return precedence of operators
int prec(char c) {
  if (c == '^')
    return 3;
  else if (c == '/' || c == '*')
    return 2;
  else if (c == '+' || c == '-')
    return 1;
  else
    return -1;
}

// The main function to convert infix expression
//to postfix expression
void infixToPostfix(string s) {

  stack < char > st; //For stack operations, we are using C++ built in stack
  string result;

  for (int i = 0; i < s.length(); i++) {
    char c = s[i];

    // If the scanned character is
    // an operand, add it to output string.
    if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9'))
      result += c;

    // If the scanned character is an
    // ‘(‘, push it to the stack.
    else if (c == '(')
      st.push('(');

    // If the scanned character is an ‘)’,
    // pop and to output string from the stack
    // until an ‘(‘ is encountered.
    else if (c == ')') {
      while (st.top() != '(') {
        result += st.top();
        st.pop();
      }
      st.pop();
    }

    //If an operator is scanned
    else {
      while (!st.empty() && prec(s[i]) <= prec(st.top())) {
        result += st.top();
        st.pop();
      }
      st.push(c);
    }
  }

  // Pop all the remaining elements from the stack
  while (!st.empty()) {
    result += st.top();
    st.pop();
  }

  cout << "Prefix expression: " << result << endl;
}

int main() {
  string exp = "(p+q)*(m-n)";
  cout << "Infix expression: " << exp << endl;
  infixToPostfix(exp);
  return 0;
}
Output:

Infix expression: (p+q)*(m-n)

Prefix expression: pq+mn-*

Time Complexity: O(N)

Space Complexity: O(N) for using the stack
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
Infix to prefix
*So there we will foloow the 3 steps that are
*first reberse the infic 
*then do infix to postfix converson under some controlled condition
*them again reverse 
*#include <iostream>
#include <stack>
#include <string>
#include <algorithm>

using namespace std;

// Function to check if character is an operator
bool isOperator(char c) {
    return (c == '+' || c == '-' || c == '*' || c == '/' || c == '^');
}

// Function to get precedence of operators
int getPrecedence(char op) {
    if (op == '^')
        return 3;
    else if (op == '*' || op == '/')
        return 2;
    else if (op == '+' || op == '-')
        return 1;
    else
        return -1;
}

// Function to reverse a string
string reverseString(string str) {
    reverse(str.begin(), str.end());
    return str;
}

// Function to convert infix to postfix with special condition for '^'
string infixToPostfixSpecial(string infix) {
    stack<char> s;
    string postfix = "";
    
    for (int i = 0; i < infix.length(); i++) {
        char c = infix[i];
        
        // If character is operand, add to output
        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9')) {
            postfix += c;
        }
        // If character is '(', push to stack (considering reversed input, treat as ')')
        else if (c == '(') {
            s.push(c);
        }
        // If character is ')', pop until '(' is found
        else if (c == ')') {
            while (!s.empty() && s.top() != '(') {
                postfix += s.top();
                s.pop();
            }
           
                s.pop(); // Remove '('
        }
        // If character is operator
        else if (isOperator(c)) {
            // Special condition for '^': pop if precedence is greater than or equal
            while (!s.empty()  && 
                   (c == '^' ? getPrecedence(s.top()) >= getPrecedence(c) : 
                               getPrecedence(s.top()) > getPrecedence(c))) {
                postfix += s.top();
                s.pop();
            }
            s.push(c);
        }
    }
    
    // Pop remaining operators from stack
    while (!s.empty()) {
        postfix += s.top();
        s.pop();
    }
    
    return postfix;
}

// Main function to perform the three-step conversion
string convertInfixToPostfix(string infix) {
    // Step 1: Reverse the infix expression
    string reversedInfix = reverseString(infix);
    
    // Adjust parentheses for reversed expression
    for (int i = 0; i < reversedInfix.length(); i++) {
        if (reversedInfix[i] == '(')
            reversedInfix[i] = ')';
        else if (reversedInfix[i] == ')')
            reversedInfix[i] = '(';
    }
    
    // Step 2: Convert reversed infix to postfix with special '^' condition
    string postfix = infixToPostfixSpecial(reversedInfix);
    
    // Step 3: Reverse the result to get final postfix
    string finalPostfix = reverseString(postfix);
    
    return finalPostfix;
}

int main() {
    string infix;
    cout << "Enter infix expression: ";
    getline(cin, infix);
    
    string postfix = convertInfixToPostfix(infix);
    cout << "Postfix expression: " << postfix << endl;
    
    return 0;
}

Here time complexity wil be o(3*n)
and space complexity wil be o(n)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
Convert the postfix to infix conversion
*Here note we will be taking stack to store the operands not the result string
*so if operand than push in stack
*if operand take the 2 operands already in stack amd pu the operator in between
*and surround them with backet and again put it in the stack
*class postfixtoinfix
{
stack<string>st;
for(int i=0;i<s;i++)
{
if operand
st.push(s[i]);
else
{
t1=st.top();
st.pop();
t2=st.top();
st.pop();
ans=(+t1+s[i]+t2+);
st.push(ans)'
}
}
return st.top();
time complexity will be the 0(n) and space complexity will be 0(n)


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Convert the thne prefix to infix
*jyst same as converting the postfix to infix but here we will iterate from the back
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Postfix to prefix
*so iterate form first if the operand then push
*if the operator than the operand than t1 t2 and push without parenthesis
*posttopref(string s)
{
stack<int>s;
forint i=0;i<s.length;i++)
{
if operand st.push(S[i]);
else
{
ans=s[i}+t1+t2;
s.push(ans)

}
}
}
time complexity will be the 0(n) and space complexity will be 0(n)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
prefix to postfix
*sameiterate fom back
*then if operator than the t1+t2+s[i]
*no brackets
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Monotonic stack
*when we store elemnts in stack in some order than its called the monotonic stack
*int arr[]={6,0,8,1,3}
*now for each element in an array we need to tells its next greater elements
*so ans will be [8,8,-1,3,-1]
*here the bruet force will be using the vector
*so ime omplexity will e of 0(n*n) and the space complexity will be of 0(n) as use the temp rray
*so standing t ny ndex we should lok toward ight but rray traversing rat from left to right
*so rst optimization will be traverse from the back
*so take tack or that if stack empty then arr[i]=-1 and st.push(rr[i]);
*if st.top()>arr[i];
arr[i]=st.top();
st.push(arr[i])
*else p till we get ment greater en arr[i]
*Note:o we  storing always elements in the decreasing order and whenever distruption 


Next greater element
* vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        stack<int>st;
        vector<int>res;
        for(int i=0;i<nums2.size();i++)
        {
            if(st.empty())
            {
                res.push_back(-1);
            }
            while(!st.empty()&&st.top()<nums2[i])
            {
                st.pop();
            }
                res.push_back(st.top());
                st.push(nums2[i]);
            

        }
        return res;
        
        
    }


Note:here time complexity ill be the 0(n) max as inner one will not mmve for the n times
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Next greater element 2
*So here little changes forany element if not dund reate o right then find s in the circula direction
*sobrute force will be fro i to -1
*for j=i+1->n
*then the k=0 toi-1 if notfound in j
*so tanding non any index the cicular aary is +n to that index butindex after last position is hypothetical%n
*so now beeter solution will be 
*for(int i=0;i<i<n;i++)
*then from j=i+1 to i+n-1
fid ind=i%n if a[inde]>a[i]
*ten temp.push_back[a[indx]
break;




here time complexity wll be o(n*n)
*So here 
for(int i=2*n-1;i>=0;i--)
{
while(!st.empty() and st.top<=arr[i%n)
st.pop()
}
if(st.empty()
{
if i<n
temp.push_back(-1)
temp.push(st.top()
st.push(arr[i%n)


class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        vector<int>temp;
        stack<int>st;
        for(int i=2*nums.size()-1;i>=0;i--)
        {
            while(!st.empty()&&st.top()<=nums[i%nums.size()])
            {
                st.pop();
            }
            if(i<nums.size())
            {
                temp.push_back(st.empty()?-1:st.top());
            }
            st.push(nums[i%nums.size()]);
        }
        return temp;
        
    }
};
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
Trappig rainwater
*where are given ana rrayof building
*so basically each indexwe are given height of building
*and as rain happes water get accumulate
*
*Note:when water get accumulated->sppos a uilding there is taller building to left and taller uidingto he righ
*Now t calculate the water on allbuildings i will go to each bulding teraceand see how much watter accumulated and sum up
*So question how we figure out hommuch wateraccuuated on the terrace top so check left max and right mx and take min of these tan the subtract height o thet element from teht target
*So here brute orce solution willbe 
for(inti=0;i<n;i++)
{
leftmax=suffix[i]
rightmax=suffix[i]
if(arr[i]>let max an arr[i]>rightmax)
{
water=min(leftmax,rightmax)-ar[i];
total=total+water

}
}
*
vecor<int>prefix;
prefix[0]=nus[0]
for(in i=1;i<n;i++)
{
prefix[i]=ma(prefix[i-1],nums[i]);

}
vector<in>suffix;
sufix[0]=nums[n-1];
for(in i=n-1;i>=0;i--)
{
suffix[i]=max(prefix[i+1],nums[i]);

}

here time complexity ill be o(n) and space compelexity ill be o(n)

Using stack and queue lter s we needs one left max or rightmax but min
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Sum or subarray minimum
inta rr[]=[3,1,2,4]
*Now here we want that foe ach subarray find the minimunand then sum
*So here brute will take o(n*n*n)
*and better o(n*n)
*and best solution will be finding th econtribution ofeach elements frpm array in the  from the subarray
*and then sum up by in many subabry contribution*elemenst in which it contributed as min
*consider the arrya s [1,4,6,7,3,7,8,1
*so for 3 find next smaller elemnst index
*thne nextsamller[i]will return index-arr[i]
*and prefix samller wlement then total=total+4*3*3
*








-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Sliding window nad 2 pinter problesm
Longest substring without repeating numbers
*so the extreme naive solution will be making use of the hash and if any at ny points hash[s[]i==2 then break at that point otherwise the has[s[i]]++;
*for(int i=0;i<n;i++)
{
int hash[126];
for(int j=i;j<n;j++)
{
if(hash[s[i]==2)
{
break;
}else
{
has[s[i]++;
len=j-i+1;
maxlen=max(maxlen,len);
}
}
so whenever the problem with longest substring comes always think of the sliding window on 2 pointer algo
*this take time complexity of the o(n*n)
*so we will move to the sliding window and the 2 pointer approach
*so here we will use 2 ponter and ithen see if right pointing elemnt exist in the hash or not
*if not thehn put in hash and then update length as r-l+1;
and maxlen calculate
* if found then the 
*update l to the mpp[s[i]+1; one more where was found
*and then the update the element in the index
*then len
*them maxlen
*Note:make sure considering substring for l to r we need to consider that the wher find in map there value>=l
*            // Update the max length
*  map<char, int> hash;
        int l = 0, r = 0;
        int maxlen = 0;

        while (r < s.size()) {
            // If the character is seen and its last index is >= left, move left
            if (hash.find(s[r]) != hash.end() && hash[s[r]] >= l) {
                l = hash[s[r]] + 1;
            }

            // Update the latest index of the current character
            hash[s[r]] = r;

            // Update the max length
            maxlen = max(maxlen, r - l + 1);

            r++;
        }

        return maxlen;
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
LRU cache
*Implement lru cacahe
*so we wil be given the capacity suppose the capity is 4
*put(2,6)
*put(4,7)
*put(8,11)
*put(7,10)
now the lr is 2,6
*now suppose one says get 2 than its value is 6
*so put again 2,6 as it recently used
*now capacity is 4 
*put 5,6 no you cant so we will delete the lru
*that is 4,7
*now someone tell 5,7 then put get it at top then roemove value 6 nd place 7
*Note:so we will use the dll and map
*so we have in dll 2 node one head with and one tail and tail->prev=head and head->next=prev  
*and map storing key and value as node
*so first capacity=4;
*then the mpp.find(key) if not then insert the key and value as one node after the head node
*Note:and if get then find in map if yres then return th node->val and and before tail node remove and add after the head
*
listnode{
int key,int val,node *next,node *prev
}
class lrucacahe{
int capacity.map<int,node *>mpp,node *tail,node*head;
lrucache(capacity)
{
capacity=capacity;
tail->prev=head;
head->next=tail



1.get(key)
{
if(mpp.find(key!=mpp.end())
{
Node *node=mpp[key];
deleteode(node);
insertafterhead(head);
return node->value
}else
{
return-1

}



}


2.put(key,value)
{
if(mpp.find(key!=mpp.end())
{
Node *node=mpp[key];
mpp->value=value;
deleteode(node);
insertafterhead(head);



}
else{
if(mpp.size()==capacity)
{Node *node=tail->prev;
deleteode(node);
mpp.remove(node.key);
}
mpp[key,ne node(key,value);
inserafterathad()


}
}
}


class LRUCache {
public:
public:
    class Node {
    public:
        int key;
        int value;
        Node *next;
        Node *prev;
        Node(int key, int value) {
            this->key = key;
            this->value = value;
            next = nullptr;
            prev = nullptr;
        }
    };
int capacity;
Node *head=new Node(-1,-1);
Node * tail=new Node(-1,-1);
map<int,Node *>mpp;
    LRUCache(int capacity) {
        this->capacity=capacity;
        head->next=tail;
        tail->prev=head;

        
    }
    void deletethisnode(Node *n)
    {
        Node *previ=n->prev;
        Node *forward=n->next;
        previ->next=forward;
        forward->prev=previ;
        
    }
    void insertafterhead(Node *n)
    {
        Node *forward=head->next;
        n->next=forward;
        forward->prev=n;
        head->next=n;
        n->prev=head;

    }
    
    int get(int key) {
        if(mpp.find(key)!=mpp.end())
        {
            Node *n=mpp[key];
            
            deletethisnode(n);
            insertafterhead(n);
            return n->value;

        }else
        {
            return -1;
        }
        
    }
    
    void put(int key, int value) {
         if(mpp.find(key)!=mpp.end())
         {
              Node *n=mpp[key];
              n->value=value;
            
            deletethisnode(n);
            insertafterhead(n);

         }else if(mpp.size()==capacity)
         {
            Node *last=tail->prev;
            deletethisnode(last);
            mpp.erase(last->key);
           

         }
         insertafterhead(new Node(key,value));
         mpp[key]=head->next;
         

        
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
-----------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Funtion to cloe a linkedist 
There are two main scenarios:

Simple Linked List (just data + next) → Easy copy.

Linked List with Random Pointers (each node has next + random) → Tricky cloning.

I’ll give you both.

✅ Case 1: Clone a Simple Singly Linked List
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

// Function to print linked list
void printList(Node* head) {
    while (head) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

// Function to clone linked list
Node* cloneList(Node* head) {
    if (!head) return nullptr;

    Node* newHead = new Node(head->data);
    Node* currOld = head->next;
    Node* currNew = newHead;

    while (currOld) {
        currNew->next = new Node(currOld->data);
        currOld = currOld->next;
        currNew = currNew->next;
    }
    return newHead;
}

int main() {
    // Create original list: 10 -> 20 -> 30
    Node* head = new Node(10);
    head->next = new Node(20);
    head->next->next = new Node(30);

    cout << "Original List: ";
    printList(head);

    Node* cloned = cloneList(head);

    cout << "Cloned List:   ";
    printList(cloned);
}


✅ Output:
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------


