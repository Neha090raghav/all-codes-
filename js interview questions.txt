`spring boot
java
design patterns
lld





typescript
css
java script and react--question linkedin and ss
cosing question for ereact
mongo db




node js


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
JavaScript Promise
*JavaScript Promises make handling asynchronous operations like API calls, file loading, or time delays easier.
*Think of a Promise as a placeholder for a value that will be available in the future. It can be in one of three states
*Pending: The task is in the initial state.
*Fulfilled: The task was completed successfully, and the result is available.
8Rejected: The task failed, and an error is provided.
let checkEven = new Promise((resolve, reject) => {
    let number = 4;
    if (number % 2 === 0) resolve("The number is even!");
    else reject("The number is odd!");
});
checkEven
    .then((message) => console.log(message)) // On success
    .catch((error) => console.error(error)); // On failure
*here resolve make promse as fuldille and retrn he esult
*reject(error): Marks the promise as rejected with an error.


1. Promise.all() Method
Waits for all promises to resolve and returns their results as an array. If any promise is rejected, it immediately rejects.


Promise.all([
    Promise.resolve("Task 1 completed"),
    Promise.resolve("Task 2 completed"),
    Promise.reject("Task 3 failed")
])
    .then((results) => console.log(results))
    .catch((error) => console.error(error));

here error eill be taks 3 failed 

Promise.all([
    Promise.resolve("Task 1 completed"),
    Promise.resolve("Task 2 completed"),
    Promise.resolve("Task 3 completed") // changed from reject to resolve
])
    .then((results) => console.log(results))
    .catch((error) => console.error(error));
and resukt is ["Task 1 completed", "Task 2 completed", "Task 3 completed"]





2.2. Promise.allSettled() Method
Waits for all promises to settle (fulfilled or rejected) Method and returns an array of their outcomes.
Promise.allSettled([
    Promise.resolve("Task 1 completed"),
    Promise.reject("Task 2 failed"),
    Promise.resolve("Task 3 completed")
])
    .then((results) => console.log(results));

Note:When you use Promise.allSettled, it waits for all promises to settle, regardless of whether they resolve or reject.

It returns an array of objects, each describing the outcome of each promise with:

status: "fulfilled" or "rejected"

value: if fulfilled

reason: if rejected
[
  { status: "fulfilled", value: "Task 1 completed" },
  { status: "rejected", reason: "Task 2 failed" },
  { status: "fulfilled", value: "Task 3 completed" }
]

3. Promise.race() Method
Promise.race() Method resolves or rejects as soon as the first promise settles.
Promise.race([
    new Promise((resolve) =>
        setTimeout(() =>
            resolve("Task 1 finished"), 1000)),
    new Promise((resolve) =>
        setTimeout(() =>
            resolve("Task 2 finished"), 500)),
]).then((result) =>
    console.log(result));

4. Promise.any() Method
Promise.any() Method resolves with the first fulfilled promise. If all are rejected, it rejects with an AggregateError.
Promise.any([
    Promise.reject("Task 1 failed"),
    Promise.resolve("Task 2 completed"),
    Promise.resolve("Task 3 completed")
])
    .then((result) => console.log(result))
    .catch((error) => console.error(error));
5. Promise.resolve() Method
Promise.resolve() Method returns a promise that resolves with the given value.




Promise.resolve("Immediate success")
    .then((value) => console.log(value));



Imortant questions
for (var i = 0; i < 5; i++) {
  setTimeout(() => console.log(i), 100);
}
*Why?
var is function-scoped, not block-scoped. So there's only one i variable shared across all iterations.

When the setTimeout callbacks execute (after 100ms), the loop has already completed, and i is now 5.

All callbacks refer to the same i, which has the final value 5.
--------------------------------------------------------------------------------------------------------------------------------------------------
*In JavaScript, "use strict" is a directive that enables strict mode
*which was first introduced in ECMAScript 5 (ES5) to assist in the writing of safer and more error-free code.
*"Use strict" is used to indicate that the code should be executed in strict mode, applying a stricter set of rules for JavaScript coding.

Why to use Strict Mode?
1.Avoids Accidental Global Variables: In normal JavaScript, if you assign a value to a variable that has not been declared, it creates a global variable.
*Strict mode throws an error instead, preventing such accidental global variables.
*"use strict";
x = 10; // Throws an error because 'x' is not declared


2.Eliminates Silent Errors
*some operations fail silently (e.g., assigning a value to a non-writable property).
*Strict mode makes these operations throw errors, helping developers catch bugs early.
*"use strict";
Object.defineProperty(this, "PI", { value: 3.14159, writable: false });
PI = 3.14; // Throws an errors

3.Disallows Duplicates in Function Parameters
In strict mode, using the same name for multiple parameters in a function is not allowed, which prevents confusion.

4.Prevents this from Defaulting to the Global Object
* when the function is called without anobject
* In normal JavaScript functions, this defaults to the global object (window in browsers)
*Strict mode changes this behavior by setting this to undefined in such cases, improving security and preventing unintended side effects.
"use strict";
function showThis() {

    // Logs 'undefined' instead of the global object
    console.log(this); 
}
showThis();

5.In non-strict mode, deleting an undeletable property has no effect, while strict mode throws an error.
"use strict";
delete Object.prototype; // Throws an error in strict mode\\



How to use "use strict" Mode?
*Strict mode can be enabled in two main ways: for the entire script or for individual functions.

1.Global Strict Mode:Place "use strict"; at the top of your JavaScript file to apply strict mode globally across the entire script.
2.Local Strict Mode (Per Function): To enable strict mode for a specific function, add "use strict"; inside the function definition.



Limitations and Compatibility Considerations
Strict mode is generally compatible with modern JavaScript, but there are some points to keep in mind:
*Not Retroactive: Adding "use strict"; does not affect previously executed code.
*Module Scripts: In ES6 modules, strict mode is enabled by default, and you do not need to add "use strict";

When Not to Use Strict Mode?
In certain cases, enabling strict mode may not be appropriate:
*Working with Third-Party Code: If you're using third-party libraries that were not built with strict mode in mind, enabling strict mode may introduce errors.
*Quick Prototyping: For rapid prototyping, enabling strict mode might slow you down by enforcing rules.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
How to addd js in html document
*Inline JavaScript
You can write JavaScript code directly inside the HTML element using the onclick, onmouseover, or other event handler attributes.
<html>
<head></head>
<body>
    <h2>
        Adding JavaScript in HTML Document
    </h2>
    <button onclick="alert('Button Clicked!')">
        Click Here
    </button>
</body>
</html>
*Internal JavaScript
You can write JavaScript code inside the <script> tag within the HTML file.
 is commonly placed inside the <head> or <body> section of the HTML document.
inside the head section <html>
<head>
    <script>
        function myFun() {
            document.getElementById("demo")
                .innerHTML = "Content changed!";
        }
    </script>
</head>
<body>
    <h2>
        Add JavaScript Code
        inside Head Section
    </h2>
    <h3 id="demo" style="color:green;">
        GeeksforGeeks
    </h3>
    <button type="button" onclick="myFun()">
        Click Here
    </button>
</body>
</html>


*External JavaScript (Using External File)
For larger projects or when reusing scripts across multiple HTML files, you can place your JavaScript code in an external .js file
This file is then linked to your HTML document using the src attribute within a <script> tag.
<html>
<head>
    <script src="script.js"></script>
</head>
<body>
    <h2>
        External JavaScript
    </h2>
    <h3 id="demo" style="color:green;">
        GeeksforGeeks
    </h3>
    <button type="button" onclick="myFun()">
        Click Here
    </button>
</body>
</html>

Advantages of External JavaScript
*Faster Page Load Times: Cached external JavaScript files don’t need to be reloaded every time the page is visited, which can speed up loading times.cached measn stored for re access
*Code Reusability: One external JavaScript file can be linked to multiple HTML files, reducing redundancy and making updates easier.
*


By default, JavaScript blocks the rendering of the HTML page until it is fully loaded, but using async or defer can help improve load times.
To improve the page performance if the script is large we can load it asynchronously or defer
1.async Attribute
The async attribute loads the script asynchronously, meaning the script will be downloaded and executed as soon as it is available, without blocking the page.

<script src="script.js" async></script>

2.The defer attribute delays the execution of the script until the entire HTML document has been parsed. This is particularly useful for scripts that manipulate the DOM.
<script src="script.js" defer></script>
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
In JavaScript, variables are declared using the keywords var, let, or const.
1. var Keyword
*It has a function-scoped or globally-scoped behaviour.
*reassigning of variable is allowed
*redeclaring of variable is allowed in same scope

2.The let keyword is introduced in ES6, has block scope and cannot be re-declared in the same scope.
2.The const keyword declares variables that cannot be reassigned. It’s block-scoped as well.
const n = 100;
// n = 200; This will throw an error
console.log(n)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

*Variable Shadowing in JavaScript
Variable shadowing occurs when a variable declared within a certain scope (e.g., a function or block) has the same name as a variable in an outer scope. The inner variable overrides the outer variable within its scope.
let n = 10; // Global scope

function gfg() {
    let n = 20;  // Shadows the global 'n' inside this function
    console.log(n);  // Output: 20
}

gfg();
console.log(n);  // Output: 10 (global 'n' remains unchanged)

Output
20
10
The inner n shadows the outer n in its scope.
The outer n is still accessible outside the function.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Variable Scope in JavaScript
*Scope determines the accessibility of variables in your code.
*1. Global Scope
*Variables declared outside any function or block are globally scoped.
*While var, let, and const can all have global scope when declared outside a function 
var is added to the window object in browsers.
let and const do not attach to the window object, making them safer for modern usage.

2. Function Scope
*Variables declared inside a function are accessible only within that function. This applies to var, let, and const:
function test() {
    var localVar = "I am local";
    let localLet = "I am also local";
    const localConst = "I am local too";
}
console.log(localVar); // Error: not defined

3.3. Block Scope
Variables declared with let or const inside a block (e.g., inside {}) are block-scoped, meaning they cannot be accessed outside the block. 
{
    let blockVar = "I am block-scoped";
    const blockConst = "I am block-scoped too";
}
console.log(blockVar); // Error: not defined
however, is not block-scoped and will leak outside the block because it ignores
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

.
*Interesting Facts about Variables in JavaScript:
1. let or const are preferred over var: Initially, all the variables in JavaScript were written using the var keyword but in ES6 the keywords let and const were introduced. The main issue with var is, scoping.
2.var Can be accessed outside block if within the function
function example() {
  if (true) {
    var message = "Hello";
  }
  console.log(message); // ✅ Outputs: Hello
}
example();
Even though message is declared inside the if block, it's accessible outside the block but still within the function. This is because var ignores block scope.


function example() {
  if (true) {
    let message = "Hello";
  }
  console.log(message); // ❌ ReferenceError: message is not defined
}


3. var can be redeclared in the same scope, but let and const cannot be

var x = 10;
var x = 20; // Allowed

let y = 30;
let y = 40; // SyntaxError

const z = 50;
const z = 60; // SyntaxError

4.const ob = { a: 10 };
ob.a = 20; // Allowed

const arr = [10, 20, 30]
arr[2] = 40
console.log(arr)  // Allowed

/* TypeError in the below lines
obj = { b: 30 }; 
arr = [50, 100] */
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
js data types
Primitive Data Type
1.Number
*The Number data type in JavaScript includes both integers and floating-point numbers. Special values like Infinity, -Infinity, and NaN represent infinite values and computational errors, respectively.
let n1 = 2;
console.log(n1)

let n2 = 1.3;
console.log(n2)

let n3 = Infinity;
console.log(n3)

let n4 = 'something here too' / 2;
console.log(n4)
2
1.3
Infinity
NaN


2.String
A String in JavaScript is a series of characters that are surrounded by quotes. There are three types of quotes in JavaScript, which are.
let s1 = "Hello There";
console.log(s1); 

let s2 = 'Single quotes work fine';
console.log(s2); 

let s3 = `can embed ${s1}`;
console.log(s3);

There’s no difference between ‘single’ and “double” quotes in JavaScript. 


3.Boolean
The boolean type has only two values i.e. true and false.
let b1 = true;
console.log(b1);  

let b2 = false;
console.log(b2);

4.Null
It forms a separate type of its own which contains only the null value.
let age = null;
console.log(age)

5.Undefined
A variable that has been declared but not initialized with a value.
automatically assigned the undefined value.let a;
console.log(a);

6.Symbols
Symbols, introduced in ES6, are unique and immutable primitive values used as identifiers for object properties. 
 They help create unique keys in objects, preventing conflicts with other properties

let s1 = Symbol("Geeks");
let s2 = Symbol("Geeks");
console.log(s1 == s2);


Non-Primitive Data Types
The data types that are derived from primitive data types are known as non-primitive data types.

1.objects
2.Array
3.Functions
4.Date
5.Regular Expression

Interesting Facts about Data Types
1. Dynamically Typed:
JavaScript Variables are not bound to a specific data type.
Mainly data type is stored with value (not with variable name) and is decided & checked at run time.
let x = 42;   
console.log(x)

x = "hello";  
console.log(x)

x = [1, 2, 3]
console.log(x)

2. Everything is an Object (Sort of): In JavaScript, Functions are objects, arrays are objects, and even primitive values can behave like objects temporarily when you try to access properties on them.
3.NaN is not equal to itself:
NaN Stands for “Not-a-Number”
NaN is technically of type number.
It is used to represent a computational error.
console.log(typeof NaN);
console.log(NaN === NaN);

3.4. A Symbol is Never Equal to Another One : Symbol is a unique and immutable data type often used for creating private properties and methods. Symbols are never equal to any other Symbol.
let s1 = Symbol("abc");
let s2 = Symbol("abc");
console.log(s1 === s2);


4.. A character is also a string. There is no separate type for characters. A single character is also a string.
let s1 = "gfg";   // String
let s2 = 'g';    // Character

console.log(typeof s1); 
console.log(typeof s2);
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
=== checks for strict equality (both type and value).
== checks value.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Type Conversion and Type Coercion in JavaScript

*Type Conversion:
Type Conversion is the process in JavaScript in which the data type of the variables is converted from one type to another type manually.
also called explicit type conversion

Performed manually by the programmer means Uses built-in JavaScript methods like Number(), String(), and Boolean().
1. String to Number
We can convert a string into numbers using the Number() function, parseInt(), and parseFloat() methods.
let s = "123";
let n = Number(s);  // Converts string to number
console.log(n);

2.2. Number to String
We can convert a number into a string using String() function or we can concate it with an empty string("").
let n = 123;
let s = String(n);  //Converts number to string
console.log(s);

3.Boolean to Number
We can convert a boolean into a number using Number(), so true becomes 1 and false becomes 0.
let bool = true;
let n = Number(bool);  //Converts boolean to number
console.log(n);

4. Boolean to String
We can convert boolean into string using String() or by contacting it with empty string.
let bool = true;
let s = String(bool);  //Converts boolean to string
console.log(s);


Type coercion

Type coercion is the automatic conversion of one data type to another by JavaScript during operations.
This is also known as implicit type casting.
Performed automatically by JavaScript.
Can lead to unexpected results if not handled properly.

Examples of Type Coercion:
1.1. String + Number

JavaScript will automatically or implicitly convert the number to a string if there is the string present in the arithmetic operation.
let n = 5;
let s = "5";
let res = n + s;  // JavaScript converts num to string
console.log(res); 
console.log(typeof(res))


2.Boolean + Number

JavaScript converts the boolean value into a number, true becomes 1 and false becomes 0, when we perform the arithematic operations.
let bool = true;
let n = 10;
let res = bool + n;  // JavaScript converts boolean to number
console.log(res);


3.Comparison of Different Types
JavaScript convert the two value of data type into the common type when we compare there values.
let s = "10";
let n = 10;
console.log(s == n);  // true, JavaScript converts str to number

4.Boolean Context
Javascript converts non-boolean value into the boolean value when the value is in the if statement.
let s = "";
if (s) {
    console.log("This won't print");  // Empty string is falsy
} else {
    console.log("This will print");  // Empty string is coerced to false
}


Note:Use === instead of == to prevent unintended type coercion in comparisons.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------
scope

Lexical Scope (Closures)

Lexical scope means a function can access variables from its outer scope even after the outer function has finished execution.
function outer() {
    let outerVar = "I'm in the outer scope!";
    function inner() {
        console.log(outerVar); // Accessing parent's scope
    }
    inner();
}
outer();
as here outer function execution stop here still the inner function is able to access variable of the outer scop

Different cases of scope

1.let globalLet = "This is a global variable";
fun{
    let localLet = "This is a local variable";
     // This is a global variable
    console.log(globalLet);
    
    // This is a local variable
    console.log(localLet);   
}
Output
This is a global variable
This is a local variable
Global Variables: Inside a function, global variables (declared outside) are accessible.
Local Variables: Local variables (declared inside the function) are also accessible within that function.

2.let globalLet = "This is a global variable"

function fun() {
    let localLet = "This is a local variable"

}
fun();
console.log(globalLet);
console.log(localLet);//reference error locallet nt defined

Global Variable: globalLet is accessible outside the function since it’s declared in the global scope.
Local Variable: localLet is not accessible outside the function, causing an error, as it’s scoped only within the function.

Note:Word of caution: Whenever you are declaring variables, always use the prefix let. If you don’t use the let keyword, then the variables are by default created in the global scope. For instance, in the above example.


3.let globalLet = "This is a global variable";;

function fun() {
    localLet = "This is a local variable";
}

fun();
console.log(globalLet); // This is a global variable
console.log(localLet); // This is a local variable

Output
This is a global variable
This is a local variable
Global Variable: globalLet remains accessible as it is declared in the global scope.
Implicit Global Variable: Without the let keyword, localLet is treated as a global variable, even though it was intended to be local to the function.


4.let globalLet = "This is a global variable"

function fun() {
    let globalLet = "This is a local variable"
}
fun();
console.log(globalLet); // This is a global variable


5.let globalLet = "This is a global variable";

function fun() {
    let globalLet = "This is a local variable";
    console.log(globalLet);
}
fun();
Output
This is a local variable
Local Variable Preference: Inside the function, JavaScript first looks for globalLet in the local scope, finds it, and logs the local variable.
Scope Search: If globalLet weren’t declared locally, JavaScript would search for it in the global scope.

6.What if we want to access the global variable instead of the local one here? 
let globalLet = "This is a global variable";

function fun() {
    let globalLet = "This is a local variable";
    console.log(window.globalLet); // This is a global variable
}
fun();


----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Browser Console
*Console in JavaScript

The console object provides access to the browser’s debugging console (or terminal in Node.js)


*Commonly Used console Methods

1. console.log()
The console.log() function logs general information to the console.
console.log("Hello, World!");

2.console.error()
The console .error() function in JavaScript Logs error messages to the console
 Typically displayed in red
console.error("This is an error message.");

3. console .warn()
The console. warn() function Logs warnings on to the console to warn the user about certain scenarios, typically displayed in yellow.


--------------------------------------------------------------------------------------------------------------------------------------------------------------------
Functions and Events


1.Function declaration
:function sum(x, y) { 
    return x + y; 
}
console.log(sum(6, 9));
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




2.Function Expression:
*function are just made the part of expression so that they can be assigned to variable or passed as parameters or invoke immediately
*Function expressions can be named or anonymous.
*They are not hoisted, meaning they are accessible only after their definition.
*const greet = function(name) {
    return `Hello, ${name}!`;
};
console.log(greet("Ananya"));



Named vs Anonymous Function Expressions
*Anonymous Function Expression:
The function has no name 

typically assigned to a variable.
const sum = function(a, b) {
    return a + b;
};
console.log(sum(5, 3));


*Named Function Expression: The function is given a name
const factorial = function fact(n) {
    if (n === 0) return 1;
    return n * fact(n - 1);
};
console.log(factorial(5));


Use Cases of Function Expressions
*Function expressions are often assigned to variables for easy reuse
*They are commonly used as arguments in higher-order functions.
*Function expressions are ideal for event listeners.
*Function expressions can be immediately executed.
(function() {
    console.log("This is a self-invoking function!");
})();





note:diff between func declaratun and expression s that exp can be called after definition bt declaration can be called before the declaraton
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


3.Arrow Functions: A Variant of Function Expressions
*They are particularly useful for short, single-purpose functions.
*const arrowFunc = (param1, param2) => param1 + param2;
console.log(arrowFunc(5, 7));
*Key Features:

Implicit return for single-line functions.
No binding of this, making them unsuitable for methods requiring a this context.They inherit this from the surrounding context.
*Arrow functions do not have access to the arguments object, which is available in regular functions.

const arrowFunc = () => {
  console.log(arguments); // ReferenceError: arguments is not defined
};
arrowFunc(1, 2, 3);
function regularFunc() {
  console.log(arguments); // [Arguments] { '0': 1, '1': 2, '2': 3 }
}
regularFunc(1, 2, 3);
*In JavaScript, returning object literals within functions is concise: () => ({ key: value })

const getUser = () => ({ name: "Alice", age: 25 });
console.log(getUser()); // { name: 'Alice', age: 25 }
*Arrow functions can be made asynchronous by adding the async keyword before the parameter list.


Limitations of Arrow Functions
1.No prototype Property: Arrow functions do not have the prototype property, so they cannot be used as constructors
2.Cannot be Used with new: Since they lack a prototype, they cannot be used with the new keyword to create instances.
3.Cannot be Generators: Arrow functions cannot be used as generator functions (function*) because they do not support the yield keyword.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

4.mmediately Invoked Function Expressions (IIFE)
Immediately Invoked Function Expressions (IIFE) are JavaScript functions that are executed immediately after they are defined
*They are typically used to create a local scope for variables to prevent them from polluting the global scope.
*(function (){ 
// Function Logic Here. 
})();
*(function() {
	// IIFE code block
	var localVar = 'This is a local variable';
	console.log(localVar); // Output: This is a local variable
})();
*Explanation: The function is wrapped in parentheses (function() { ... }), followed by () to immediately invoke it.
*note:IIFEs are commonly used to create private scope in JavaScript,var counter = (function() {
	var count = 0;

	return {
		increment: function() {
			count++;
		},
		decrement: function() {
			count--;
		},
		getCount: function() {
			return count;
		}
	};
})();

// Increment the counter
counter.increment();
counter.increment();
counter.increment();

console.log(counter.getCount()); // Output: 3

// Trying to access the private count variable directly
console.log(counter.count); // Output: undefined (cannot access private variable)
var counter = (function() {
	var count = 0;

	return {
		increment: function() {
			count++;
		},
		decrement: function() {
			count--;
		},
		getCount: function() {
			return count;
		}
	};
})();

// Increment the counter
counter.increment();
counter.increment();
counter.increment();

console.log(counter.getCount()); // Output: 3 we are creating mthod that provide access

// Trying to access the private count variable directly
console.log(counter.count); // Output: undefined (cannot access private variable) we cant directly access






Use Cases Of IIFE
*To create closures in JavaScript.
*IIFE is used to create private and  public variables and methods.
*It is used to execute the async and await function.
*It is used to work with require function.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


What is closure?
Closure in JavaScript
*A closure is a function that allows access to variables from its outer function 
* even after the outer function has finished executing
Some of the features of the closures are mentioned
1.A closure allows a function to access variables from its outer (enclosing) function even after it has finished executing.
2.Global variables can be made private within a function using closures, ensuring they cannot be accessed or modified directly from outside.
3.Closures provide a way to encapsulate private data and create public methods to interact with it.
4.Closures help retain references to variables that would otherwise be lost after the execution of the outer function.


Lexical Scoping
*
Closures are based on lexical scoping, meaning that a function’s scope is determined by where the function is defined, not where it is executed.
*function outer() {
  let count = 0;

  function inner() {
    console.log(count);  // inner "remembers" count
  }

  return inner;
}

const closureFn = outer(); // outer runs, but returns inner
closureFn(); // logs: 0
Even though outer() has finished executing, inner() still has access to count because it was defined inside outer()
*The inner function doesn't care where it's eventually called — only where it was defined. That’s why closureFn() still remembers count.


Private Variables
*Closures allow a function to keep variables hidden and only accessible within that function
*This is often used when creating modules to protect certain data from being accessed or modified by other parts of the program.
*function counter() {
// Private variable
    let count = 0; 
    
    return function () {
     // Access and modify the private variable
        count++;
        return count;
    };
}

const increment = counter();
console.log(increment());
console.log(increment());
console.log(increment());


*IIFEs (Immediately Invoked Function Expressions) use closures to hide data inside the function

*IIFEs create a new scope, and any variables declared inside that scope are not accessible from the outside.
*This is useful when you want to encapsulate logic or protect data from being globally exposed.
*const counter = (function() {
  let count = 0; // private variable

  return {
    increment() {
      count++;
      return count;
    },
    decrement() {
      count--;
      return count;
    }
  };
})();

console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.count);       // undefined (cannot access `count` directly)

*Even though count is defined inside the IIFE, it remains accessible to the returned functions because of a closure, but hidden from the outside world.


Closure and setTimeout
Closures are helpful in asynchronous programming
*This is especially useful when you’re working with things like timers or server requests, where the function might not run immediately.
*function createTimers() {
    for (let i = 1; i <= 3; i++) {
        setTimeout(function () {
            console.log(`Timer ${i}`);
        }, i * 1000);
    }
}
createTimers();
Note:here each iyeartion new i will tehre and callback get correct i ,but if use var as its block scoped same i is called for each iteration and callback ghets 4


Closures with this keyword
*Closures can be confusing when using the this keyword because this depends on how and where a function is called, not where it is defined.
*


Benefits of Closures
*Data Encapsulation: Closures enable data hiding and abstraction.
*start management
*Callbacks and Event Listeners: Simplify asynchronous code.

Common Pitfalls
Memory Leaks: Excessive use of closures may retain unnecessary references to variables, causing memory issues.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






Function Currying in JavaScript
*Function currying is a technique to transform a function that takes multiple arguments into a series of functions that take one argument at a time.
*Currying relies on closures because each of the intermediate functions has access to the arguments passed previously.
// Normal Function
// function add(a, b) {
//     return a + b;
// }
// console.log(add(2, 3)); 

// Function Currying
function add(a) {
    return function(b) {
        return a + b;
    };
}

const addTwo = add(2);  // First function call with 2
console.log(addTwo(3));  // Output: 5


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

*Async and await
Async and Await in JavaScript is used to simplify handling asynchronous operations using promises
*By enabling asynchronous code to appear synchronous, they enhance code readability 
*
async function fetchData() {
  const response = await fetch("https://jsonplaceholder.typicode.com/posts/1");
  const data = await response.json();
  console.log(data);
}

fetchData();


*Async Function

*The async function allows us to write promise-based code as if it were synchronous.
*This ensures that the execution thread is not blocked
*Async functions always return a promise.
*If a value is returned that is not a promise, JavaScript automatically wraps it in a resolved promise.
*const getData = async () => {
    let data = "Hello World";
    return data;
}

getData().then(data => console.log(data));

Hello World




Await Keyword
*The await keyword is used to wait for a promise to resolve.
*It can only be used within an async block.

const getData = async () => {
    let y = await "Hello World";
    console.log(y);
}

console.log(1);
getData();
console.log(2);

1
2
Hello World


const getData = async () => {
    let y = "Hello World";
    console.log(y);
}

console.log(1);
getData();
console.log(2);

1

Hello World
2





---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Callback Functions
:What is a Callback Function?
*A callback function is a function that is passed as an argument to another function and executed later.
*function greet(name, callback) {
    console.log("Hello, " + name);
    callback();
}

function sayBye() {
    console.log("Goodbye!");
}

greet("Ajay", sayBye);

*JavaScript executes code line by line (synchronously), but sometimes we need to delay execution or wait for a task to complete before running the next function. 
*console.log("Start");

setTimeout(function () {
    console.log("Inside setTimeout");
}, 2000);

console.log("End");



Where Are Callbacks Used?
*1. Handling Asynchronous Operations
Callbacks are widely used in

API requests (fetching data)
Reading files (Node.js file system)
Event listeners (clicks, keyboard inputs)
Database queries (retrieving data)



2.When a function needs to execute different behaviors based on input, callbacks make the function flexible.
function calc(a, b, callback) {
    return callback(a, b);
}

function add(x, y) {
    return x + y;
}

function mul(x, y) {
    return x * y;
}

console.log(calc(5, 3, add));    
console.log(calc(5, 3, mul));

3.Callbacks in Event Listeners
JavaScript is event-driven, and callbacks handle user interactions like clicks and key presses.


document.getElementById("myButton").addEventListener("click", function () {
    console.log("Button clicked!");
});
4.Callbacks are useful when retrieving data from APIs.
function fetch(callback) {
    fetch("https://jsonplaceholder.typicode.com/todos/1")
        .then(response => response.json())
        .then(data => callback(data))
        .catch(error => console.error("Error:", error));
}

function handle(data) {
    console.log("Fetched Data:", data);
}

fetch(handle);




Problems with Callbacks
1.Although callbacks are useful, they have some drawbacks.
*When callbacks are nested deeply, the code becomes unreadable and hard to maintain.
getUser(userId, function(user) {
  getPosts(user.id, function(posts) {
    getComments(posts[0].id, function(comments) {
      sendEmail(user.email, function(status) {
        console.log("Email sent!");
      });
    });
  });
});
2.
Error handling can get messy when dealing with nested callbacks.


Alternatives to Callbacks
*Promises provide a better way to handle asynchronous tasks without deep nesting.
*async/await provides an even cleaner way to handle asynchronous code.


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Function Binding
*
* function binding refers to the process of associating a function with a specific context (this value).
*The bind() method creates a new function that, when called has key word bind to the value that we passed in the bind function
*every function runs with a specific value of this and a set of surrounding variables available to it, based on where and how it is called, not just where it is defined.

What is Execution Context?
*An execution context in JavaScript is the environment in which a piece of code is evaluated and executed
*t consists of:
*Variable Object (VO): Holds variables, function declarations, and function parameters.
*Scope Chain: Access to variables from outer contexts.
*this keyword: Refers to the object that is executing the current function.

const person = {
    name: 'GFG',
    greet: function() {
        console.log('Hello, ' + this.name);
    }
};
const greet = person.greet;
greet();
*ello, undefined
*When greet is called directly (without being bound to the person object), the value of this is not person anymore.
*Instead, it refers to the global object (in non-strict mode) or is undefined (in strict mode).
*Methods of Function Binding
1.1. bind() Method
*The bind() method is used to create a new function that, when called, has its this value set to a specified value, regardless of how the function is invoked.

const person = {
    name: 'GFG',
    greet: function() {
        console.log('Hello, ' + this.name);
    }
};
const greet = person.greet;
const boundGreet = greet.bind(person);
boundGreet();
Hello, GFG

2. call() Method:The call() method will ceate the function and invoke the function with the this keyword and this points to specified value and the pass  the arguments to function
const person = {
    name: 'GFG',
    greet: function(city) {
        console.log('Hello, ' + this.name + ' from ' + city);
    }
};
person.greet('Delhi');
const greet = person.greet;
greet.call(person, 'Noida');

3.apply mthod 
Similar to call(), the apply() method invokes a function and allows you to set the value of this, but the difference is that the arguments are passed as an array (or an array-like object).
const person = {
    name: 'GFG',
    greet: function(city, country) {
        console.log('Hello, ' + this.name + ' from ' + city + ', ' + country);
    }
};
person.greet('Delhi', 'India'); 
const greet = person.greet;
greet.apply(person, ['Noida', 'Delhi']);

Arrow Functions and this Binding:
*They do not have their own this context
*Instead, arrow functions inherit the this value from the surrounding lexical context.
*const person = {
    name: 'GFG',
    greet: function(city, country) {
        console.log('Hello, ' + this.name + ' from ' + city + ', ' + country);
    }
};
person.greet('Delhi', 'India'); 
const greet = person.greet;
greet.apply(person, ['Noida', 'Delhi']);
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*Hoisting 
*Hoisting refers to the behaviour where JavaScript during the compilation phase moves the declarations of variables, functions, and classes to the top of their scope 
*‘var’ variables are hoisted with undefined, while ‘let’ and ‘const’ are hoisted but remain in the Temporal Dead Zone until initialized.
*

Temporal Dead Zone (TDZ)
*it is the tiem period between entering the scops and the initizialtion of variable already declared in scops
*It refers to the period between the entering of a scope (such as a function or block) and the actual initialization of a variable declared with let or const.
*During this time, any reference to the variable before its initialization will throw a ReferenceError.
1. Variable Hoisting with var
console.log(a); // undefined
var a = 5;

When you use var to declare a variable, the declaration is hoisted to the top, but its value is not assigned until the code execution reaches the variable’s initialization. This results in the variable being assigned undefined during the hoisting phase.


2.Variable Hoisting with let and const
Unlike var, let and const are also hoisted, but they remain in a Temporal Dead Zone (TDZ) from the start of the block until their declaration is encountered. Accessing them before their declaration will throw a ReferenceError.
console.log(b); // ReferenceError: Cannot access 'b' before initialization
let b = 10;

3.Function Declaration Hoisting
Function declarations are hoisted with both their name and the function body. This means the function can be called before its definition in the code.
greet(); // "Hello, world!"
function greet() {
    console.log("Hello, world!");
}

4.Function Expression Hoisting
Function expressions are treated like variable declarations of let and const. The variable itself is hoisted, but the function expression is not assigned until the line of execution. This means calling the function before its assignment will result in an error
hello(); // TypeError: hello is not a function
var hello = function() {
    console.log("Hi!");
};

5.Hoisting with let and const in Functions
*Variables declared with let and const inside a function are hoisted to the top of the function’s scope, but they remain in the TDZ. This prevents access to them before they are initialized.
function test() {
    console.log(x); // ReferenceError: Cannot access 'x' before initialization
    let x = 50;
}
test();

6.Classes are hoisted, but they cannot be accessed before they are declared, resulting in a ReferenceError.
Although the class MyClass is hoisted, it cannot be accessed before its declaration due to the TDZ, which is why the code throws a ReferenceError.
const obj = new MyClass(); // ReferenceError
class MyClass {
    constructor() {
        this.name = "Example";
    }
}

6.Re-declaring Variables with var
With var, you can redeclare a variable within the same scope. This is a unique behavior compared to let and const.
var a = 10;
var a = 20; // No error
console.log(a); // 20


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
JavaScript Higher Order Functions
1.A higher-order function is a function that does one of the following:

Takes another function as an argument.
Returns another function as its result.

Higher-order functions help make your code more reusable and modular by allowing you to work with functions like any other value.
*function fun() {
    console.log("Hello, World!");
}
function fun2(action) {
    action();
    action();
}

fun2(fun);


Popular Higher Order Functions in JavaScript
1.The map() method is an ES5 feature that creates a new array  and each element of array are coming by applying a function to each element of the original array.
const a = [1, 2, 3, 4];

// Use map to create a new array with elements doubled
const b = a.map(x => x * 2);

console.log(b);


Syntax

arr.map((element, index, array) => { /* … */ })

Parameters 

element: It is a required parameter and holds the current element's value.
index: It is an optional parameter and it holds the index of the current element.
arr: It is an optional parameter and it holds the array.




2.filter 
The filter() method creates a new array containing elements that satisfy a specified condition. 


3.reduce
*The reduce function accumulates array elements into a single value based on a callback function.
const n = [1, 2, 3, 4, 5];
const sum = n.reduce((acc, curr) => acc + curr, 0);
console.log(sum);



4.The forEach function executes a provided function once for each array element.
5.find
6.every 
7.some

Advanced Techniques with Higher Order Functions
1.Function composition is the process of combining multiple functions to create a new function. The composed function applies multiple operations in sequence.
function add(x) {
    return x + 2;
}
function mul(x) {
    return x * 3;
}

function compose(f, g) {
    return function(x) {
        return f(g(x));
  };
}
var res = compose(add, mul)(4);
console.log(res);

2.Currying transforms a function that takes multiple arguments into a series of functions that each take one argument. This allows partial application of the function.

function mul(x) {
    return function(y) {
        return x * y;
  };
}
var mul = mul(2);
console.log(mul(5));

3.Memoization is a technique where function results are cached so that repeated calls with the same arguments return faster
*
function memoize(func) {
    var cache = {};
    return function (arg) {
        if (cache[arg]) {
            return cache[arg];
        } else {
            var res = func(arg);
            cache[arg] = res;
            return res;
        }
    };
}
function slow(num) {
    console.log("Computing...");
    return num * 2;
}

var fast = memoize(slow);
console.log(fast(5)); // Computing... 10
console.log(fast(5)); // 10 (cached)

Use case's of higher order functions
1. Passing Functions as Arguments
2.returning function as the argumnets
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
JavaScript Iterator
*Javascript Iterator is an object or pattern that allows us to traverse over a list or collection

*Iterators define the sequences and implement the iterator protocol
*on iterator protocol by using a next() method that contains the value and is done thet return objects
*The value contains the next value of the iterator sequence and the done is the boolean value true or false if the last value of the sequence has been consumed then it's true else false. 
*We can check its prototype and can see if it is having a method Symbol(Symbol.iterator) in its prototype objects
*Also, String, Map & Set are built-in iterables because their prototype objects all have a Symbol.iterator() method.
*<script>
    const array = ['a', 'b', 'c'];
    
    const it = array[Symbol.iterator]();
    
    // and on this iterator method we have ‘next’ method
    
    console.log(JSON.stringify(it.next()));
    //{ value: "a", done: false }
    
    console.log(JSON.stringify(it.next()));
    //{ value: "b", done: false }
    
    console.log(JSON.stringify(it.next()));
    //{ value: "c", done: false }
    
    console.log(JSON.stringify(it.next()));
    /* Actual it.next() will be { value: undefined,
    done: true } but here you will get
    {done: true} output because of JSON.stringify
    as it omits undefined values*/
</script>
*Using for.of loop, we can iterate over any entity (for eg: an object) which follows iterable protocol. The for.of loop is going to pull out the value that gets a return by calling the next() method each time.
*
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
generator function
*A generator function is a special type of function that can pause its execution at any point and resume later.
*They are defined using the function* syntax

*use the yield keyword to pause execution and return a value.
*function* generate() {
    yield 'Hello';
    yield 'World';
    return 'Done';
}

const generator = generate();

console.log(generator.next());
console.log(generator.next()); 
console.log(generator.next());
console.log(generator.next()); 


{ value: 'Hello', done: false }
{ value: 'World', done: false }
{ value: 'Done', done: true }
{ value: undefined, done: true }

*The next() method is used to resume execution and retrieve the next value.
*The done property indicates whether the generator has finished executing.

How Do Generators Work?
*Generators work by implementing the iterator protocol
*When a generator function is called, it does not execute its body immediately
* Instead, it returns a special iterator object called a generator object.
*This object can be used to control the execution of the generator.


1.Execution Control: The next() method resumes execution of the generator function until the next yield is encountered.
*It returns an object with two properties:
value: The yielded value.
done: A boolean indicating if the generator has completed execution.
2.State Preservation: Each call to next() resumes the function from where it was last paused, retaining the function’s state.
4.Termination: When the generator completes execution, the done property of the returned object becomes true.

function* example() {
    console.log("Step 1");
    yield 1;
    console.log("Step 2");
    yield 2;
    console.log("Step 3");
    return 3;
}

const gen = example();

console.log(gen.next());
console.log(gen.next());
console.log(gen.next());
Step 1
{ value: 1, done: false }
Step 2
{ value: 2, done: false }
Step 3
{ value: 3, done: true }

Use Cases for Generatorss
1.1. Custom Iterators
*Generators simplify the creation of custom iterators, making it easy to generate sequences of values.
*function* fibonacci(limit) {
    let [prev, current] = [0, 1];
    while (limit--) {
        yield current;
        [prev, current] = [current, prev + current];
    }
}
const fib = fibonacci(5);
console.log([...fib]);

here 5. Spread Operator [...fib]:
This fully consumes the generator.

Equivalent to repeatedly calling fib.next() until done.


..2. Asynchronous Programming

*Generators, in combination with libraries like co or with async/await syntax, help manage asynchronous flows
*function* asyncTask() {
    console.log('Task 1');
    yield new Promise(resolve =>
        setTimeout(() =>
            resolve('Task 2'), 1000));
    console.log('Task 3');
}\
const task = asyncTask();
task.next().value.then(console.log);
task.next();

3.3. Infinite Sequences
*function* infiniteSeq() {
    let i = 0;
    while (true) {
        yield i++;
    }
}
const sequence = infiniteSeq();
console.log(sequence.next().value); 
console.log(sequence.next().value); 
console.log(sequence.next().value); 



Advantages of Generator Functions
*Customizable Iterators: Generators allow creating iterators without implementing the entire iterable protocol manually.
*Readable Asynchronous Code: Generators can make asynchronous workflows look synchronous, simplifying complex code.
*Lazy Evaluation: Values are computed only when needed, improving performance for large or infinite sequences.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
number +undefined gives the nan
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
JavaScript Events
*JavaScript Events are actions or occurrences that happen in the browser
*They can be triggered by various user interactions or by the browser itself.
lets see the on the user interaction <html>
<script>
    function myFun() {
        document.getElementById(
            "gfg").innerHTML = "GeeksforGeeks";
    }
</script>

<body>
    <button onclick="myFun()">Click me</button>
    <p id="gfg"></p>
</body>
</html>

Event Types
*JavaScript supports a variety of event types. Common categories include:
1.Mouse Events: click, dblclick, mousemove, mouseover, mouseout
2.Keyboard Events: keydown, keypress, keyup
3.Form Events: submit, change, focus, blur
4.Window Events: load, resize, scroll


1.click-onclick
*The HTML DOM onclick event occurs when the user clicks on an element. 

In HTML:
<element onclick="myScript">

<!DOCTYPE html>
<html>
<body>
 <button onclick="myFunction()">Click me</button>
 <p id="gfg"></p>

 <script>
  function myFunction() {
   document.getElementById(
    "gfg").innerHTML = "GeeksforGeeks";
  }
 </script>
</body>
</html>




In JavaScript:
object.onclick = function(){myScript};
<!DOCTYPE html>
<html>
<body>
 <p id="gfg">Click me.</p>
 <script>
  document.getElementById("gfg").onclick = function () {
   GFGfun()
  };

  function GFGfun() {
   document.getElementById(
    "gfg").innerHTML = "YOU CLICKED ME!";
  }
 </script>
</body>
</html>



In JavaScript, using the addEventListener() Method:
object.addEventListener("click", myScript);
<!DOCTYPE html>
<html>
<body>
 <p id="gfg">Click me.</p>
 <script>
  document.getElementById(
   "gfg").addEventListener("click", GFGfun);

  function GFGfun() {
   document.getElementById(
    "gfg").innerHTML = "YOU CLICKED ME!";
   document.getElementById(
    "gfg").style.color = 'red';
   document.getElementById(
    "gfg").style.background = 'cyan';
  }
 </script>
</body>
</html>



2.The onmouseover event attribute works when the mouse pointer moves over the specified element. 
*<element onmouseover = "script">
<!DOCTYPE html>
<html>

<head>
    <title>onmouseover event attribute</title>
    <style>
        body {
            text-align: center;
        }

        h1 {
            color: green;
        }
    </style>
</head>

<body>
    <h1>
        GeeksforGeeks
    </h1>
    <h2>
        onmouseover Event Attribute
    </h2>
    <p onmouseover="geeks()">
        Computer science portal
    </p>
    <script type="text/javascript">
        function geeks() {
            alert("Mouse move over");
        } 
    </script>
</body>

</html>
3.onmouseout--Occurs when the mouse pointer leaves an element.
4.onkeydown	Fired when a key is pressed down.
5.onchange-The onchange event attribute works when the value of the element changes and select the new value from the List.
*When it triggers	When the element loses focus after its value has been changed.
Supported Tags:
<input type="checkbox">
 <input type="file">
 <input type="password">
 <input type="radio">
 <input type="range">
 <input type="search">
 <input type="text">
 <select> 
 <textarea>

<!DOCTYPE html>
<html>

<head>
    <title>onchange event attribute</title>
    <style>
        body {
            text-align: center;
        }

        h1 {
            color: green;
        }
    </style>
</head>

<body>
    <h1>
        GeeksforGeeks
    </h1>
    <h2>
        onchange Event Attribute
    </h2>
    <p>
        Choose Subject:
    </p>
    <select id="GFG" onchange="Geeks()">
        <option value="Data Structure">Data Structure
        <option value="Algorithm">Algorithm
        <option value="Computer Network">Computer Network
        <option value="Operating System">Operating System
        <option value="HTML">HTML
    </select>
    <p id="sudo"></p>

    <script>
        function Geeks() {
            let x = document.getElementById("GFG").value;
            document.getElementById("sudo").innerHTML =
                "Selected Subject: " + x;
        }
    </script>
</body>

</html>
*<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" 
          content="width=device-width, initial-scale=1.0">
    <title>onchange event attribute</title>
    <style>
        body {
            text-align: center;
        }

        h1 {
            color: green;
        }
    </style>
</head>

<body>
    <h1>
        GeeksforGeeks
    </h1>
    <h2>
        onchange Event Attribute
    </h2>
    <p>
        Select Options:
    </p>
    <label>
        <input type="checkbox" id="option1" 
               onchange="solve()"> Option 1
    </label>
    <script>
        function solve() {
            var selectedOptions = [];

            var option1 = document.getElementById("option1");
            if (option1.checked) {
                selectedOptions.push("Option 1");
            }
            console.log("Selected Options is:", selectedOptions);
        }
    </script>
</body>

</html>





6.onload:
The onload event attribute works when an object has been loaded.
*This attribute is mostly used within the <body> element to execute a script
*This attribute is used to check the visitor's browser type and browser version and load the proper version of the web page based on the information.
*n simple words, It activates when a webpage or an element has finished loading



7.The onsubmit event in HTML DOM occurs after the submission of a form. The form tag supports this event.
*In HTML: 
<element onsubmit="Script">
*In JavaScript: 
object.onsubmit = function(){myScript};
*In JavaScript, using the addEventListener() method:  
object.addEventListener("submit", myScript);
*<center>
    <h1 style="color:green">GeeksforGeeks</h1>
    <h2>HTML DOM onsubmit Event</h2>
    <form id="formID" action="#">
        Enter name:
        <input type="text" name="fname">
        <input type="submit" value="Submit">
    </form>
</center>

<script>
    document.getElementById("formID").onsubmit =
        function() {GFGfun()};
    
    function GFGfun() {
        alert("form submitted");
    }
</script>
*<center>
    <h1 style="color:green">GeeksforGeeks</h1>
    <h2>HTML DOM onsubmit Event</h2>
    <form id="formID" action="#">
        Enter name:
        <input type="text" name="fname">
        <input type="submit" value="Submit">
    </form>
</center>

<script>
    document.getElementById(
      "formID").addEventListener("submit", GFGfun);
    
    function GFGfun() {
        alert("form submitted");
    }
</script>



*onfocus event:The HTML DOM onfocus event occurs when an element gets focused.
*The onfocus event is mostly used with <input>, <select>, and <a>. 
*he onfocus event is the opposite of the onblur event. 
*Note: The onfocus event is different from the onfocusin event because the onfocus event does not bubble. 
*<center>
    <h1 style="color:green">
        GeeksforGeeks
    </h1>
    <h2>
        HTML DOM onfocus Event
    </h2>
    <br> Name:
    <input type="text" onfocus="geekfun(this)">
    <script>
        function geekfun(gfg) {
            gfg.style.background = "green";
        }
    </script>
</center>


*onblur :This attribute fires at that moment when the element loses focus
*This attribute is mostly used in the Form validation code
*
<!DOCTYPE html>
<html>

<head>
    <title>onblur attribute</title>
    <style>
        body {
            text-align: center;
        }

        h1 {
            color: green;
        }
    </style>
</head>

<body>
    <h1>GeeksforGeeks</h1>
    <h2>onblur attribute</h2>

    <!-- When leave the input box then the input box 
        value is converted into capital letter. -->
    Username: <input type="text" 
                     name="fname" 
                     id="GFG" 
                     onblur="Geeks()">
    <script>
        function Geeks() {
            let y = document.getElementById("GFG");
            y.value = y.value.toUpperCase();
        }
    </script>
</body>

</html>s
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*Event Propagation


*JavaScript events propagate in two phases:
1.What is Event propagation, capturing, bubbling ?
*Event Propagation determines in which order the elements receive the event.
*There are two ways to handle this event propagation order of HTML DOM is Event Bubbling and Event Capturing.


Bubbling:
*When an event happens on a component, it first runs the event handler on it, then on its parent component, then all the way up on other ancestors' components. 
*example:we have 3 div element and in all 3 we have addevelynlistnere and they are in hieravhy so wen event take sin 3 then call eventlistenre of 3 then 2 then of first
*<!DOCTYPE html>
<html>

<head>
    <style>
        #div1 {
            background-color: lightgreen;
            padding: 24px;
            border: 1px solid black;
        }

        #div2 {
            background-color: yellow;
            padding: 18px;
            border: 1px solid black;

        }

        #div3 {
            background-color: orange;
            border: 1px solid black;
        }
    </style>
</head>

<body>
    <h1 style="color: green">GeeksForGeeks</h1>
    <h3>What is Event propagation, capturing, bubbling?</h3>

    <div id="div1">
        Component 1
        <div id="div2">
            component 2
            <div id="div3">
                component 3
            </div>
        </div>
    </div>

    <!-- Javascript code for event bubbling -->
    <script>
        let div1 = document.querySelector("#div1");
        let div2 = document.querySelector("#div2");
        let div3 = document.querySelector("#div3");

        div1.addEventListener("click", function (event) {
            alert("Component 1 event clicked");
        });

        div2.addEventListener("click", function (event) {
            alert("Component 2 event clicked");
        });

        div3.addEventListener("click", function (event) {
            alert("Component 3 event clicked");
        });
    </script>
</body>

</html>



*Capturing
*It is the opposite of bubbling. The event handler is first on its parent component and then on the component where it was actually wanted to fire that event handler.
*<!DOCTYPE html>
<html>

<head>
    <style>
        #div1 {
            background-color: lightgreen;
            padding: 24px;
            border: 1px solid black;
        }

        #div2 {
            background-color: yellow;
            padding: 18px;
            border: 1px solid black;

        }

        #div3 {
            background-color: orange;
            border: 1px solid black;
        }
    </style>
</head>

<body>
    <h1 style="color: green">GeeksForGeeks</h1>
    <h3>What is Event propagation, capturing, bubbling?</h3>

    <div id="div1">
        Component 1
        <div id="div2">
            component 2
            <div id="div3">
                component 3
            </div>
        </div>
    </div>

    <!-- Javascript code for event capturing -->
    <script>
        let div1 = document.querySelector("#div1");
        let div2 = document.querySelector("#div2");
        let div3 = document.querySelector("#div3");

        div1.addEventListener("click", function (event) {
            alert("Component 1 event clicked");
        }, true);

        div2.addEventListener("click", function (event) {
            alert("Component 2 event clicked");
        }, true);

        div3.addEventListener("click", function (event) {
            alert("Component 3 event clicked");
        }, true);
    </script>
</body>

</html>



note:Setting true in addEventListener makes it capture events during the capturing phase.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*HTML DOM stopPropagation() Event Method
*The stopPropagation() method is used to stop the propagation of event calling
* Syntax:

event.stopPropagation()
*Return Value: It does not return any value.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
Phases of JavaScript Event
There are three different phases during the lifecycle of a JavaScript event.
1.capturing phase:Capturing Phase is when the event goes down to the target element
2.The target phase is when the event reaches the target element
3.Bubbling phase is when the event bubbles up from the element.

Bubbling phase is when the event bubbles up from the element.
<body id="bdy">
    <div id="container">
        <button id="btn">Click Me!</button>
    </div>
    <script type="text/javascript">
        document.getElementById('bdy')
            .addEventListener('click', function () {
            alert('Body!');
        })
        document.getElementById('container')
            .addEventListener('click', function () {
            alert('Div!');
        }, true)
        document.getElementById('btn')
            .addEventListener('click', function () {
            alert('Button!');
        })
    </script>
</body>
*here as button is clicked first it goes to parent  as true is false thn to the div as the true is et then run the eventliostener method and finally to the target that is button than again to the bubbing phase that is body 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Event Delegation in JavaScript
*Event Delegation is basically a pattern to handle events efficiently
*Instead of adding an event listener to each and every similar element, we can add an event listener to a parent element
*and and instead of creating the callback again and again we can take refernce of that callback
*and can aplly condition to select the target event using event.target
*without event delegation
const customUI = document.createElement('ul');

for (var i = 1; i <= 10; i++) {
    const newElement = document.createElement('li');
    newElement.textContent = "This is line " + i;
    newElement.addEventListener('click', () => {
        console.log('Responding')
    })
    customUI.appendChild(newElement);
}
*We are creating an <ul> element, attaching too many <li> elements, and attaching an event listener with a responding function to each paragraph as we create it.
*We are creating too many responding functions (that all actually do the exact same thing). We could extract this function and just reference the function instead of creating too many functions
*alternative:const customUI = document.createElement('ul');

function responding() {
    console.log('Responding')
}

for (var i = 1; i <= 10; i++) {
    const newElement = document.createElement('li');
    newElement.textContent = "This is line " + i;
    newElement.addEventListener('click', responding)
    customUI.appendChild(newElement);
}
*In the above approach, we still have too many event listeners pointing to the same function
*Now implementing the same functionalities using a single function and single callback functions
*const customUI = document.createElement('ul');

function responding() {
    console.log('Responding')
}

for (var i = 1; i <= 10; i++) {
    const newElement = document.createElement('li');
    newElement.textContent = "This is line " + i;
    customUI.appendChild(newElement);
}
customUI.addEventListener('click', responding)
*we have one eventlistener  and one callback functcion
*note:we have yet not implemented the event delegation here we have improved but yet we have lost the access to the li elements
* we will use a technique called event delegation. 
*The event object has a special property call .target which will help us in getting access to individual <li> elements with the help of phases.
*Steps:

any <li> element is clicked.
The event goes in the capturing phase.
It reaches the target (<li> in our case).
It switches to the bubbling phase.
When it hits the <ul> element, it runs the event listener.
Inside the listener function event.target is the element that was clicked.
Event.target provides us access to the <li> element that was clicked.
*The .nodeName property of the .target allows us to identify a specific node
*onst customUI = document.createElement('ul');

function responding(evt) {
    if (evt.target.nodeName === 'li')
        console.log('Responding')
}

for (var i = 1; i <= 10; i++) {
    const newElement = document.createElement('li');
    newElement.textContent = "This is line " + i;
    customUI.appendChild(newElement);
}

customUI.addEventListener('click', responding);
----------------------------------------------------------------------------------------------------------------------------------------------------------------------note:even are used in form validation adding the dynamic content
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------*What is An Event Loop in JavaScript?
*The event loop is an important concept in JavaScript that enables asynchronous
*Since JavaScript is single-threaded,without blocking the main thread.it uses the event loop to manage the execution of multiple tasks
*console.log("Start");

setTimeout(() => {
    console.log("setTimeout Callback");
}, 0);

Promise.resolve().then(() => {
    console.log("Promise Resolved");
});

console.log("End");
*here start first ,then the settimeout put the callback in callback queye saying it will not execute not
*then promise.resolve in the microstask queue saying it will be executed now
*microtask queye first tahn callback queue


How the Event Loop Works
*The event loop continuously checks whether the call stack is empty and if empty put callback from the callbackqueue or the microtask queue to the stack

1.*Call Stack: 
2.*Web APIs (or Background Tasks): These include setTimeout, setInterval, fetch, DOM events, and other non-blocking operations.
3.Callback Queue (Task Queue):When an asynchronous operation is completed, its callback is pushed into the task queue.
4.Microtask Queue: Promises and other microtasks go into the microtask queue, which is processed before the task queue.
5.Event Loop: It continuously checks the call stack and, if empty, moves tasks from the queue to the stack for execution.

why is event loop important:
*Since JavaScript is single-threaded,without blocking the main thread.it uses the event loop to manage the execution of multiple tasks
*Better Performance: Ensures UI updates and API calls do not freeze the page.
*Optimized Async Handling: Prioritizes microtasks over macrotasks for better responsiveness.


Common Issues Related to the Event Loop
1.Delayed Execution of setTimeout
*setTimeout doesn’t always run exactly after the specified time.
console.log("Start");
setTimeout(() => console.log("Inside setTimeout"), 1000);
for (let i = 0; i < 1e9; i++) {} // Long loop
console.log("End");


The blocking loop delays setTimeout execution because the Call Stack is busy so, this code will also lead to Time Limit Exceed Error or will freeze the Browser.

2.Microtasks run before setTimeout, even if set with 0ms delay.
setTimeout(() => console.log("setTimeout"), 0);
Promise.resolve().then(() => console.log("Promise"));
console.log("End");
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Event Bubbling in JavaScript
*Event Bubbling
Event Capturing
The event starts at the target element and propagates upward to the root of the DOM.

The event starts at the root of the DOM and propagates downward to the target element.

Event listeners are attached to handle events during the bubbling phase by default.

To handle events in the capturing phase, you must explicitly set the capture option to true in addEventListener.

Often used when you want parent elements to respond to events triggered on child elements (e.g., event delegation).

Useful when you want parent elements to handle the event before it reaches the target element.

Inner (child) elements execute their event listeners first, followed by outer (parent) elements as the event propagates upward.

Outer (parent) elements execute their event listeners first, followed by inner (child) elements as the event propagates downward.

Supported by all modern browsers and has been the default behavior for a long time.

Supported, but less commonly used as it requires the explicit capture option to be enabled.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

oops 
*The characteristics of an Object are called Properties in Object-Oriented Programming
*the actions are called methods

*Note: A Method in javascript is a property of an object whose value is a functions
*The object can be created in two ways in JavaScript:
*an object is an instance of class

Object Literal
Object Constructor
1.
using object literal 
// Defining object
let person = {
    first_name: 'Mukul',
    last_name: 'Latiyan',

    //method
    getFunction: function () {
        return (`The name of the person is 
          ${person.first_name} ${person.last_name}`)
    },
    //object within object
    phone_number: {
        mobile: '12345',
        landline: '6789'
    }
}
console.log(person.getFunction());
console.log(person.phone_number.landline);






2.using Using an Object Constructor.
*// Using a constructor
function person(first_name, last_name) {
    this.first_name = first_name;
    this.last_name = last_name;
}
// Creating new instances of person object
let person1 = new person('Mukul', 'Latiyan');
let person2 = new person('Rahul', 'Avasthi');

console.log(person1.first_name);
console.log(`${person2.first_name} ${person2.last_name}`);


3.JavaScript Object create() Method
*JavaScript object.create() method is used to create a new object with the specified prototype object and properties.
*Object.create(prototype[, propertiesObject])
*Parameters:
prototype: It is the prototype object from which a new object has to be created.
propertiesObject: It is an optional parameter. It specifies the enumerable properties to be added to the newly created object.
*Return Value:
Object.create() returns a new object with the specified prototype object and properties. 
*// Object.create() example a
// simple object with some properties
const coder = {
    isStudying: false,
    printIntroduction: function () {
        console.log(`My name is ${this.name}. Am I 
              studying?: ${this.isStudying}.`)
    }
}
// Object.create() method
const me = Object.create(coder);

// "name" is a property set on "me", but not on "coder"
me.name = 'Mukul';

// Inherited properties can be overwritten
me.isStudying = true;

me.printIntroduction();


*Unlike classical Object-Oriented languages like Java, C++, or C#, JavaScript did not originally have "classes".
*Instead, JavaScript is a prototype-based language, meaning:

*Every object in JavaScript has an internal link to another object called its prototype.
*Behavior (i.e., methods/properties) can be shared and inherited via this prototype chain.
*function Person(name) {
  this.name = name;
}

Person.prototype.sayHello = function () {
  console.log(`Hello, my name is ${this.name}`);
};

const p1 = new Person("Neha");
p1.sayHello(); // Output: Hello, my name is Neha
The sayHello method is attached to Person.prototype, so all instances share it.
 after introduction to es6 classes
*class Person {
  constructor(name) {
    this.name = name;
  }

  sayHello() {
    console.log(`Hello, my name is ${this.name}`);
  }
}
const p1 = new Person("Neha");
p1.sayHello(); // Same output
console.log(typeof Person); // function
console.log(Person.prototype.sayHello); // function sayHello


---------------------------------------------------------------------------------------------------------------------------------------------------------------------
JavaScript Object Constructors

const GFG = {
    subject : "programming",
    language : "JavaScript",
}
*Here, subject and language are the keys and programming and JavaScript are the values.
*A constructor function is a special type of function in JavaScript that is used to create and initialize objects.
*Constructors are used with the new keyword to create instances of a particular type (object).
*By using constructors, we can easily create multiple instances of the same type of object, 
*// Constructor function
function Person(name, age) {
    this.name = name;
    this.age = age;
    this.sayHello = function() {
        console.log(`My name is ${this.name} and I am ${this.age} years old.`);
    };
}

//Creating Instances with a Constructor
const p1 = new Person("Akash", 30);
const p2 = new Person("Anvesh", 25);

p1.sayHello();
p2.sayHello();
*The this keyword refers to the instance of the object being created




Adding Property to an Object
*The property can be added to the object by using dot(.) operator or square bracket.
*const GFG = {
    articles: 'computer science',
    quantity: 3000,
};
*GFG.subject: 'JavaScript';
*GFG['subject']: 'JavaScript';


note:Adding a property to Constructor: We cannot add a property to an existing constructor like adding a property to an object (see previous point)
* for adding a property we need to declare under the constructor.
*function GFG(a, b, c) {
    this.A = a;
    this.B = b;
    this.C = c;
    this.G = "GEEK";
}


Adding a Method to an Object
*We can add a new method to an existing object.

GFG.n = function () {
    return this.A + this.B;
};



Adding a Method to Constructor
*function GFG(a, b, c) {
    this.A = a;
    this.B = b;
    this.C = c;
    this.n = function () {
        return this.A + this.B;
    }
}



Instantiating an object constructor
*There are two ways to instantiate object constructor,
*const object_name = new Object(); // or  
const object_name = new Object("java", "JavaScript", "C#");

*In 1st method, the object is created by using new keyword like normal OOP languages, and "Java", "JavaScript", "C#" are the arguments, that are passed when the constructor is invoked.
* In 2nd method, the object is created by using curly braces "{ }".
*let gfg = new Object();

gfg.a = "JavaScript";
gfg.b = "GeeksforGeeks";

console.log("Subject: " + gfg.a);
console.log("Author: " + gfg.b );
*let gfg = { };

gfg['a'] = "JavaScript";
gfg['b']= "GeeksforGeeks";

console.log("Subject: " + gfg.a);
console.log("Author: " + gfg.b );
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*avaScript Classes
*avaScript classes (introduced in ES6) provide a structured way to create instance of object
*They support inheritance, encapsulation, and modularity
*class ClassName {
    constructor() {
        // Initialize properties here
    }
    // Define methods here
    methodName() {
        // Method code
    }
}
*The class keyword is used to declare a class.
*The constructor() method is a special method that is automatically called when an instance of the class is created.
*You can define methods inside the class to provide behaviour for objects created from the class.


Key Features of JavaScript Classes
*Encapsulation: Bundles data (properties) and behaviour (methods) together.
*Constructor Method: Initializes properties when an object is created.
*Inheritance: Allows one class to inherit properties and methods from another.


Creating a Simple Class
*class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    g() {
        console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
    }
}
let p1 = new Person("Pranjal", 20);
p1.g();
*The constructor is used to initialize the properties of the object when an instance is created.
*class Car {
    constructor(make, model, year) {
        this.make = make;
        this.model = model;
        this.year = year;
    }
    d() {
        console.log(`${this.year} ${this.make} ${this.model}`);
    }
}
let my = new Car("Toyota", "Corolla", 2021);
my.d();


*inheritance

class Car {
    constructor(make, model, year) {
        this.make = make;
        this.model = model;
        this.year = year;
    }
    di() {
        console.log(`${this.year} ${this.make} ${this.model}`);
    }
}
class ElectricCar extends Car {
    constructor(make, model, year, batteryLife) {
        super(make, model, year);
        this.batteryLife = batteryLife;
    }
    d() {
        console.log(`Battery life: ${this.batteryLife} hours`);
    }
}
let tesla = new ElectricCar("Tesla", "Model S", 2022, 24);
tesla.di()
tesla.d();
---------------------------------------------------------------------------------------------------------------------------------------------------
JavaScript Constructor Method
*In JavaScript, constructors can be defined in two main ways
*Function Constructor (Before ES6)
*Class Constructor (ES6 and Beyond)

1. Function Constructor Method (Before ES6)
*Before ES6, JavaScript used constructor functions to create and initialize objects.
*wth new keyword and constructor name we can creare mltipe istance of the particular type of  object
*function Car(make, model, year) {
    this.make = make;
    this.model = model;
    this.year = year;
    this.getCarInfo = function () {
        return `${this.year} ${this.make} ${this.model}`;
    };
}

let myCar = new Car('Toyota', 'Camry', 2020);
console.log(myCar.getCarInfo());
*here car is the constructor function
*this refers to the instance of the object being created



2. Class Constructor Method (ES6 and Beyond)
class Car {
    constructor(make, model, year) {
        this.make = make;
        this.model = model;
        this.year = year;
    }

    getCarInfo() {
        return `${this.year} ${this.make} ${this.model}`;
    }
}

let myCar = new Car('Honda', 'Civic', 2022);
console.log(myCar.getCarInfo());
*The Car class contains a special method called constructor(). This method is called automatically when a new instance of the class is created using the new keyword.
*The constructor() method initializes the properties (make, model, year) for the new object.






imppppp  How constructor works in JavaScript?
*A constructor is a special function used to create and initialize objects, defined using the function keyword or class syntax.
*wth new keyword we create the object and this refers to othe object which is the instance of class created
*with neInside the constructor, properties are assigned to the object using this, and can be set dynamically via constructor argumentsw person() we can create the multiple instance of class
*The constructor implicitly returns the newly created object, allowing access to its properties and methods.



new keyword in JavaScript
*The new keyword in JavaScript is used to create an object and set this for object  out of a constructor function of the class or the normal function
*//Object from a function
function prints(name,age)
{
    this.name=name
    this.age=age
}
const result=new prints('Pranjal',21)
console.log(result)
//Object from a class
class Person{
    constructor(name,age)
    {
        this.name=name
        this.age=age
    }
}
const result1=new Person('Saurabh',30)
console.log(result1)






Object.create() function in JavaScript

*here prototype means a copy of a object, function or class.
*Here in this scenario Object.create() is used to create a copy of a object
*and to ensure all its property and methods are copied without the use of the constructor function
*const obj={
    name:'Pranjal',
    age:21
}
const obj1=Object.create(obj)
obj1.class='10th'
console.log(obj1.name)



Object Factory Functions
*A factory function is a regular function that returns a new object hence without making use of the new
*making it a simple and reusable way to create multiple instances without using new.
*function createPerson(name, age) {
    return {
        name: name,
        age: age,
        greet: function() {
            console.log(`Hello, my name is ${this.name}`);
        }
    };
}

const person1 = createPerson("Pranjal", 30);
const person2 = createPerson("Vivekam", 25);

person1.greet(); 
person2.greet();

*A factory function generates and returns a new object every time it is called, making object creation simple and reusable
*Unlike constructor functions, factory functions do not require the new keyword, reducing the chances of errors related to this binding.
*Factory functions can include private variables and additional logic inside them, improving security and modularity in code design.
*Since they don’t rely on prototypes, factory functions offer a straightforward approach, making them easier to understand and modify.



Constructor with default values
*A constructor with default values allows you to specify default values for properties if no values are provided during object creation.
*This helps in ensuring that the object always has valid properties, even if some arguments are missing
*function Person(name = "Unknown", age = 0) {
    this.name = name;
    this.age = age;
}

const person1 = new Person("Pranjal", 30);
const person2 = new Person("Amar");  
const person3 = new Person();  

console.log(person1);  
console.log(person2); 
console.log(person3);


Constructor with method on protypes
*In JavaScript, you can add methods to the prototype of a constructor
*allowing all objects  created from that constructor can access to methods
*This helps in optimizing memory usage
*the method is not recreated for each object
function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.greet = function() {
    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
};

const person1 = new Person("Pranjal", 30);
const person2 = new Person("Amar", 25);

person1.greet();  
person2.greet();
*The greet() method is added to the prototype of Person. This means the method is shared across all instances of Person, saving memory.
*Instances like person1 and person2 are created using the new keyword hence They inherit the greet() method from the Person.prototype.
*resons:nstances like person1 and person2 are created using the new keyword. They inherit the greet() method from the Person.prototype.








Constructor with inheritance
*how inheritance in classes allows a child class to inherit both properties and methods from a parent class constructor
*The child class (two) inherits the name property from the parent class (one) using the super() keyword.
*class one{
    constructor(name)
    {
        this.name=name
    }
    greet()
    {
        return `Hello ${this.name}`
    }
}
class two extends one{
    constructor(name,age)
    {
        super(name)
        this.age=age
    }
    greet1(){
        return `Your age is ${this.age}`
    }
}
const person1=new one('Pranjal')
const person2=new two('Pranav',21)
console.log(person2.greet())
*The two class inherits the name property from the one class using super(name) in its constructor.
*super(name) calls the one class's constructor, initializing the name property in the two class.
*The two class adds its own age property, which is not present in the one class.
*When creating an instance of person2 (the two class), it inherits the name property from the one class and has its own age property.


Advantages of constructor:
*Reusable Code: Constructors allow creating multiple instances of objects with similar properties and methods, promoting code reuse.
*Encapsulation: They encapsulate the logic for setting up an object, keeping initialization clean and organized.
*inheritance
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
JavaScript this keyword
*It means that this always points to the object that called the method
*It means that this always points to the object that  owns the code currently being executed.
*This means that this in JavaScript doesn't have a fixed value Instead, its value depends on how the function is invoked, not where it is defined
*Function Call Type	Value of this
Called as a method (obj.fn())	The object before the dot (obj)
Called as a normal function (fn())	Global object (or undefined in strict mode)
Called with new keyword	A new object
Called using call / apply / bind	Whatever object is passed in
Arrow function	Lexically inherits this from surrounding scope


1.Using this in a Method

*In the context of an object method in JavaScript
*the this keyword refers to the object itself, allowing access to its properties and methods within the method's scope.
*It facilitates interaction with the object's data and behaviour, providing a way to access and manipulate its state.
*const person = {
    name: 'John',
    age: 30,
    greet() {
        console.log('Hello, my name is ' +
            this.name + ' and I am '
            + this.age +
            ' years old.');
    }
};

person.greet();



2.*Using this in a Function
In a JavaScript function, the behavior of the this keyword varies depending on how the function is invoked.

normal function call
*function greet() {
    console.log('Hello, my name is ' + this.name);
}
greet()//undefined  as here the this refers to global object and accessing any unknow properties will give undefined


using the object methods
const person = {
    name: 'Amit',
    sayHello: greet
};
const anotherPerson = {
    name: 'Jatin'
};

//Driver Code Starts
person.sayHello(); 




3.Using this alone(Global Context)
*When used alone in JavaScript, outside of any specific context,
*the behavior of the this keyword depends on whether the code is running in strict mode or not.
*console.log(this);
*{}


Implicit Binding

*when we call object method this refer to object calling object method 
*const person = {
    name: "Ram",
    age: 22,
    greet: function () {
        return `Hello ${this.name}, you are ${this.age} years old`
    }
}
console.log(person.greet());


*Explicit Binding
*when we explicity bind this kyword to any function
*using call aplly bind 
*then this keyword refrence changes to the object that we supplied
*function ageVerify() {
    if (this.age > 18) {
        console.log("Yes you can drive");
    } else {
        console.log("No you cannot drive");
    }
}

const per1 = { age: 21 };
const per2 = { age: 16 };
ageVerify.call(per1);
ageVerify.call(per2);



default binding
*when this is used in global scope than this points to window object
*const age = 22;
function verifyAge (){
    return this.age;
}
console.log(verifyAge());


Arrow Function Binding
* Arrow functions do not have their own this.
Instead, they inherit this from the surrounding (lexical) scope — the context in which the arrow function is defined, not where it is called.
*so without the function keyword outside of arror  this is unable to refer to the object in the outer scope. 
*const person = {
    name: "ram",
    age: 22,
    greet : () =>{
        return `Hello , you are ${this.age} years old`
    }
}
console.log(person.greet());
*Hello , you are undefined years old
*const person = {
  name: "Neha",
  greet: function () {
    const arrow = () => {
      console.log(this.name);
    };
    arrow();
  }
};

person.greet(); // Output: "Neha"

Notes:
1.When you use this outside of any function or object, it refers to the global object.

🔧 Example:
javascript
Copy
Edit
console.log(this);
💡 Output (in browser):
js
Copy
Edit
Window {...}
📌 Explanation:
In the browser, the global object is window.

So this outside of any function refers to window.



2.✅ 2. "Within a function, this typically points to the global object"
(in non-strict mode)

🔍 Meaning:
When a regular function is invoked normally (not as a method of an object), this inside the function points to the global object.

🔧 Example:
javascript
Copy
Edit
function show() {
  console.log(this);
}

show();
💡 Output (in browser):
js
Copy
Edit
Window {...}
📌 Explanation:
The function show() is called on its own — not through any object.

In non-strict mode, this refers to the global object by default.


3.✅ 3. "In a function under strict mode, this becomes undefined"
🔍 Meaning:
If you use 'use strict'; at the beginning of your script or function, JavaScript runs in strict mode, which disables some automatic behaviors — including automatically assigning this to the global object in functions.

🔧 Example:
javascript
Copy
Edit
'use strict';

function show() {
  console.log(this);
}

show();
💡 Output:
js
Copy
Edit
undefined
📌 Explanation:
In strict mode, JavaScript does not default this to window.

So this becomes undefined unless the function is called with an object context.

4.When used within a method of an object, this points to that object.
5.During an event, this points to the element that triggered the event.






The precedence order of this keyword
JavaScript bind() Method
JavaScript call() and apply() Method
JavaScript Object Method
JavaScript Global Scope
---------------------------------------------------------------------------------------------------------------------------------------------------------------------

JavaScript Prototype
*In JavaScript, everything is an object, including functions, arrays, and strings, which are specialized types of objects
*JavaScript follows a prototype-based system, where objects inherit properties and methods from other objects through prototypes


What is Prototype in JavaScript?
*In JavaScript, the prototype is a container for methods and properties
* When methods or properties are added to the prototype of a function, array, or string, they become shared by all objects craetd from the constructot(functiona constructot or class constructor).
*Prototype in general can be understood as a mould and all its instances can be considered as the car made from it.
*b.prototype.print = function () {
    console.log('I am from object prototype')
}
let b = {
    name: 'Pranjal',
    age: 21
}
b.print()
*Every JavaScript object has a prototype
*which contains shared methods and properties that all instances of that object can use.






How Prototype Works in JavaScript?
* What is [[Prototype]] in JavaScript?
In JavaScript, every object has a hidden/internal property called [[Prototype]].

This [[Prototype]] is a reference (a link) to another object.

That linked object is called the prototype.

Through this prototype link
* an object can inherit properties and methods from another obejcst using prototype

This mechanism is what enables prototypal inheritance in JavaScript.

*When you access a property or method on an object, JavaScript first checks the object itself. If it's not found, it looks in the object's prototype and continues up the prototype chain until it either finds the property or reaches null.
*Objects created using a constructor function inherit properties and methods from the constructor's prototype
*You can add new properties or methods to an object's prototype, and all instances of that object will automatically have access to the new functionality. This is a common way to extend built-in objects like Array or Object.





Creating Constructor Functions
*A constructor function in JavaScript is a special function used to create and initialize objects, typically using the new keyword. It sets up properties and methods on the newly created object
*function Person(name) {
    this.name = name;
}
Person.prototype.sayHello = function () {
    console.log(`Hello, my name is ${this.name}.`);
};
const n = new Person("Sheema");
n.sayHello();





Adding method to prototype
*let a1 = [1, 2, 3, 4, 5]
let a2 = [5, 6, 7, 8, 9]
Array.prototype.sum = function () {
    let sum = 0
    for (let i = 0; i < this.length; i++) {
        sum += this[i]
    }
    return sum
}
console.log(a1.sum())
console.log(a2.sum())




Prototype Inheritance

*This code demonstrates prototype inheritance where the child constructor inherits from the parent constructor,
*allowing instances of child to access methods defined in parent's prototype.
*function Animal(name) {
    this.name = name;
}

Animal.prototype.speak = function () {
    console.log(`${this.name} makes a noise.`);
};

function Dog(name) {
    Animal.call(this, name); // Call the parent constructor
}

Dog.prototype = Object.create(Animal.prototype); // Set up inheritance
Dog.prototype.constructor = Dog;

Dog.prototype.speak = function () {
    console.log(`${this.name} barks.`);
};

const dog = new Dog('Rex');
dog.speak(); // Rex barks.


*Advanced Prototype Use Cases
1. Extending Built-in Objects
*you can extend built-in objects like Array, String, etc., by adding custom methods to their prototypes.
*This allows you to add new functionality to these objects without modifying the original class.
*Array.prototype.first = function () {
    return this[0];
};

const n = [10, 20, 30, 40];
console.log(n.first());



2. Shared Methods for Performance Optimization
*To optimize performance in JavaScript
*shared methods are added to prototypes,
*allowing multiple instances of objects to access the same method without duplicating it for each instance.
*This reduces memory usage and improves efficiency.
*function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.introduce = function () {
    return `Hello, my name is ${this.name} and I am ${this.age} years old.`;
};

const person1 = new Person('Pranjal', 25);
const person2 = new Person('Ayaan', 30);

console.log(person1.introduce());
console.log(person2.introduce());



3. Dynamic Method Assignment
*In JavaScript, dynamic method assignment allows you to add or modify methods on objects or prototypes at runtime.
*This provides flexibility,
*enabling you to change or extend functionality dynamically as the program runs.
*function Person(name, age) {
    this.name = name;
    this.age = age;
}

const person1 = new Person('Pranshi', 25);
person1.introduce = function () {
    return `Hi, I am ${this.name} and I am ${this.age} years old.`;
};

console.log(person1.introduce());


Advantages of Prototypes
Memory Efficiency: Methods are shared across all instances, reducing memory usage since they're not duplicated for each object.
Inheritance Support: Prototypes enable inheritance, allowing objects to inherit properties and methods from other objects.
Flexibility: Methods and properties can be added or modified dynamically at runtime, offering flexibility in extending functionality.
Performance Optimization: By sharing methods across instances, prototypes help optimize performance, especially for large numbers of objects.



Prototype chain in JavaScript
*In JavaScript, functions, arrays, and strings are all considered types of objects. They are just specialized forms of the general object type. The Object type acts as the parent or base for these different object types
*let o = {
    name: "Pranjal",
    age: 21
}
let a = [1, 2, 3, 4, 5]
let s = "Hello GFG"
function p() {
    console.log('My name is xyzabc')
}
Object.prototype.common = function () {
    console.log('I am a shared method from prototype')
}
o.common()
a.common()
s.common()
p.common()


----------------------------------------------------------------------------------------------------------------------------------------------------------------------
JavaScript Static Methods
*Static methods are functions that are defined on a class but are not accessible through instances of the class
*Instead, they are accessible directly on the class itself.
*These methods are useful for creating utility functions 
*shared logic that doesn’t depend on individual object instances.
*class ClassName {
    static methodName() {
        // method logic
    }
}
*class ClassName {
    static methodName() {
        // method logic
    }
}
*class MathUtils {
    static add(a, b) {
        return a + b;
    }

    static multiply(a, b) {
        return a * b;
    }
}

// Calling static methods on the class
console.log(MathUtils.add(5, 3));
console.log(MathUtils.multiply(4, 6));


Use case of Static Methods

1.The getMax() method is a static method that wraps the built-in Math.max() function
class Calc {
    static getMax(...numbers) {
        return Math.max(...numbers);
    }
}
console.log(Calc.getMax(1, 5, 3, 9));



2.sStatic methods like checkArray() allow you to check for specific conditions (e.g., checking if a variable is an array) without needing to instantiate the class.
class Validator {
    static check(input) {
        return Array.isArray(input);
    }
}
console.log(Validator.check([1, 2, 3]));
console.log(Validator.check('hello'));



3. Static Method Counter
*Static methods can be used to manage class-level state, such as a counter, without creating individual instances.

*class Count {
    static c = 0;
    static inc() {
        return ++Count.c;
    }
    
    static reset() {
        Count.c = 0;
    }
}
console.log(Count.inc()); 
console.log(Count.inc()); 
Count.reset();
console.log(Count.inc());



4. Static Method Factory Pattern
*Static methods can serve as factory methods to create instances of a class
*Static methods can serve as factory methods to create instances of a class

class User {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    static create(name, age) {
        return new User(name, age);
    }
}
const user = User.create('Ajay', 30);
console.log(user);

5. Static Method Singleton Patterns
*Static methods can be used to implement design patterns like the Singleton, where only one instance of the class is allowed.
*class DB{
    static instance
    constructor()
    {
        if(DB.instance)
        {
            return DB.instance
        }
        DB.instance=this
    }
  static  getinstance()
    {
        if(!DB.instance)
        {
            DB.instance=new DB()
        }
        return DB.instance
    }
}
const obj1=new DB()
const obj2=new DB()
console.log(obj1===obj2)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Encapsulation in JavaScript
*Encapsulation is a fundamental concept in object-oriented programming that refers to the practice of hiding the internal details of an object
*d exposing only the necessary information to the outside world.
*Encapsulation can be achieved using two techniques

1.Using Closures
*function BankAccount(accountNumber, accountHolderName, balance) {
    let _accountNumber = accountNumber;
    let _accountHolderName = accountHolderName;
    let _balance = balance;

    function showAccountDetails() {
        console.log(`Account Number: ${_accountNumber}`);
        console.log(`Account Holder Name: ${_accountHolderName}`);
        console.log(`Balance: ${_balance}`);
    }

    function deposit(amount) {
        _balance += amount;
        showAccountDetails();
    }

    function withdraw(amount) {
        if (_balance >= amount) {
            _balance -= amount;
            showAccountDetails();
        } else {
            console.log("Insufficient Balance");
        }
    }

    return {
        deposit: deposit,
        withdraw: withdraw
    };
}

let myBankAccount = BankAccount("123456", "John Doe", 1000);

myBankAccount.deposit(500); 
// Output: Account Number: 123456 Account Holder Name: 
//John Doe Balance: 1500

myBankAccount.withdraw(2000); // Output: Insufficient Balance



he object has three private variables: _accountNumber, _accountHolderName, and _balance.





2.Using Classes
*The class has three private variables: _accountNumber, _accountHolderName, and _balance. These variables are prefixed with an underscore to indicate that they are private variables
*he showAccountDetails method is a public method that displays the account details. The deposit and withdrawal methods are also public methods that can be accessed from outside the object. When these methods are called, they update the _balance variable and call the showAccountDetails method to display the updated account details.
*class BankAccount {
    constructor(accountNumber, accountHolderName, balance) {
        this._accountNumber = accountNumber;
        this._accountHolderName = accountHolderName;
        this._balance = balance;
    }

    showAccountDetails() {
        console.log(`Account Number: ${this._accountNumber}`);
        console.log(`Account Holder Name: ${this._accountHolderName}`);
        console.log(`Balance: ${this._balance}`);
    }

    deposit(amount) {
        this._balance += amount;
        this.showAccountDetails();
    }

    withdraw(amount) {
        if (this._balance >= amount) {
            this._balance -= amount;
            this.showAccountDetails();
        } else {
            console.log("Insufficient Balance");
        }
    }
}

let myBankAccount = new BankAccount("123456", "John Doe", 1000);
myBankAccount.deposit(500); 
// Output: Account Number: 123456 Account Holder Name: 
//John Doe Balance: 150



class BankAccount {
    constructor(accountNumber, accountHolderName, balance) {
        this._accountNumber = accountNumber;
        this._accountHolderName = accountHolderName;
        this._balance = balance;
    }

    showAccountDetails() {
        console.log(`Account Number: ${this._accountNumber}`);
        console.log(`Account Holder Name: ${this._accountHolderName}`);
        console.log(`Balance: ${this._balance}`);
    }

    deposit(amount) {
        this._balance += amount;
        this.showAccountDetails();
    }

    withdraw(amount) {
        if (this._balance >= amount) {
            this._balance -= amount;
            this.showAccountDetails();
        } else {
            console.log("Insufficient Balance");
        }
    }
}

let myBankAccount = new BankAccount("123456", "John Doe", 1000);
myBankAccount.deposit(500); 
// Output: Account Number: 123456 Account Holder Name: 
//John Doe Balance: 150



Benefits of encapsulation in JavaScript
*Data Security: Encapsulation helps in protecting the data by preventing direct access to private variables. This ensures that the data is not modified inappropriately.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Polymorphism in JavaScript
*poly means many and morphism means transforming one form into another.
*n JavaScript, polymorphism works in two primary ways:

Method Overriding: A child class overrides a method of its parent class.
Method Overloading (simulated): A fun

Method Overriding
*Method overriding occurs when a subclass provides its own specific implementation of a method that is already defined in its parent class.
*When you call this method, JavaScript will use the subclass's implementation instead of the parent's, which is a runtime decision.
*class Animal {
    speak() {
        console.log("Animal makes a sound");
    }
}

class Dog extends Animal {
    speak() {
        console.log("Dog barks");
    }
}

class Cat extends Animal {
    speak() {
        console.log("Cat meows");
    }
}

const dog = new Dog();
dog.speak(); 

const cat = new Cat();
cat.speak();






Method Overloading (Compile-time Polymorphism)

*avaScript does not natively support method overloading, where multiple methods with the same name but different arguments exist in the same scope
*However, method overloading can be simulated by checking the number or type of arguments passed to a function, and executing different logic based on them.
*class Calculator {
    add(a, b) {
        if (b === undefined) {
            return a + a; 
        }
        return a + b; 
    }
}

const calc = new Calculator();
console.log(calc.add(2)); 
console.log(calc.add(2, 3));


Benefits of using Polymorphism
Code reusability: Polymorphism allows us to reuse the code. This saves the time of the developers from writing the code again and again.
Easy Integration and Extension: Polymorphism allows us to extend the functionality of code and add the new classes easily.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------JavaScript Getters and Setters
*In JavaScript, getter and setter are the special methods introduced in ECMAScript 5 (ES5 2009)
* that allow us to retrieve and modify the values directly without directly
* The getter uses the get keyword and the setter uses the set keyword to modify and retrieve the values.

JavaScript Getter (The get Keyword)
*In JavaScript, the getter is the method that is used to get the value of the property.
*We can use the get keyword to get the value of the property.
*Getters are automatically called when the property is accessed.
*class P {
    constructor(name) {
        this._name = name;
    }

    get name() {
        return this._name;
    }
}

const res = new P('Anjali');
console.log(res.name);





Getter vs Regular Function
*In JavaScript, the getter and the regular functions both are used for the accessing the object properties but in the different ways
*etters allow properties to be accessed like regular object attributes 
* regular functions require explicit method calls and do not provide direct property-like access.



JavaScript Setter (The set Keyword)
*n JavaScript, the setter is the method that is used for setting the value of the property with the help of the set keyword.
*class P {
    constructor(name) {
        this._name = name;
    }

    set name(newName) {
        this._name = newName;
    }
}

const res = new P('Anjali');
res.name = 'Ayushi'; // Using the setter to change the name
console.log(res._name); // Output: Ayushi
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
JavaScript - Browser Object Model
*The Browser Object Model (BOM) in JavaScript enables developers to interact with the browser beyond just the webpage content, offering control over essential features such as the browser window, URL (location), and browsing history.


Browser Object Model in JavaScript
*The Browser Object Model (BOM) in JavaScript helps to interact with the browser, not just the webpage
*While the DOM handles the content of the page
*In short, BOM helps JavaScript work with the browser to make web pages more interactive


Browser Object Model Types
*Here are the main parts of the Browser Object Model (BOM)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Window Object in JavaScript
*In JavaScript, the Window object represents the browser window that contains a DOM document.
*The Window object offers various properties and methods that enable interaction with the browser environment


Window Object Properties
*The Window object in JavaScript has numerous properties that provide access to various aspects of the browser environment and the window itself
1.window.document:Refers to the Document object representing the HTML document shown in the window.
2.window.console:Returns the window's Console object.
3.window.location:
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
JSON Tutorial
*JSON (JavaScript Object Notation) is a widely-used, lightweight data or text  format
*for representing structured data.
* It is used extensively in APIs, configuration files, and data exchange between servers and clients.


Key Characteristics of JSON
*Text-based: JSON is a simple text format, making it lightweight and easy to transmit.
*It uses key-value pairs making the structure Human-readable
*Language-independent:JSON is supported by many programming languages including Python, Java, PHP, and more.
*It represents data as objects, arrays, strings, numbers, booleans, and null.

JSON Data Flow: From Server to Client


JSON vs XML: A Quick Comparison
Feature        JSON                                           XML
*Readability	Human-readable                                Human-readable but more verbose
*Support	Broad support across languages                Initially JavaScript, but now widely supported
*Parsing	Easier to parse in most languages             More complex parsing
*Use Cases	Web APIs, configuration files, data transfer  Data storage, document formatting



How JSON Data Flow Works in Web Applications
*In a typical web application, JSON (JavaScript Object Notation) is used to transfer data between the server and the client (frontend).

Server Side:
*Data is stored as a JavaScript object.
*Before sending the data to the client, it's converted to a JSON string using 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------



JavaScript JSON stringify() Method

*The JSON.stringify() method in JavaScript is used to convert JavaScript objects into a JSON string
*This method takes a JavaScript object as input and returns a JSON-formatted string representing that object.
*JSON.stringify(value, replacer, space);


Parameters:
*value: It is the value or js object  that is to be converted into a JSON string.
*replacer: It is an optional parameter.
*This parameter value can be an altering function or an array used as a selected filter for the stringify.
*This parameter controls which properties are included in the output
👉 a function:
You can pass a function that modifies the value before it's included in the JSON string.

The function takes two arguments: key and value.
const user = { name: "Neha", age: 28, password: "secret" };

const result = JSON.stringify(user, (key, value) => {
  if (key === "password") return undefined; // exclude password
  return value;
});
console.log(result);  // {"name":"Neha","age":28}
*👉 an array:
You can pass an array of property names to include in the output.

const user = { name: "Neha", age: 28, password: "secret" };

const result = JSON.stringify(user, ["name", "age"]);
console.log(result);  // {"name":"Neha","age":28}

*3. space (optional):
*Adds indentation to the JSON string for readability.
*Can be a number (number of spaces) or a string (used for indentation).

const user = { name: "Neha", age: 28 };
console.log(JSON.stringify(user, null, 4));
*{
    "name": "Neha",
    "age": 28
}


JavaScript JSON stringify() Method Examples
Example 1: Converting JavaScript Object to JSON String
*The code demonstrates how to convert a JavaScript object obj into a JSON string using JSON.stringify(). The resulting JSON string represents the properties of the object in a serialized format.
*const value = {
    Company: "GeeksforGeeks",
    Estd: 2009,
    location: "Noida"
};
const result = JSON.stringify(value);
console.log("value of result = " + result);

value of result = {"Company":"GeeksforGeeks","Estd":2009,"location":"Noida"}





2.Example 2: Deep Copying JavaScript Object with JSON.stringify() and JSON.parse()

*The code creates an object obj with nested properties. JSON.stringify() converts obj to a JSON string, then JSON.parse() parses it back to an object obj2
*Modifying obj2 doesn't affect obj, illustrating deep copying.
*let obj = {
    name: "GFG",
    add: {
        country: "India",
        state: {
            code: "JS",
            topic: "stringify"
        }
    }
}

let obj2 = JSON.parse(JSON.stringify(obj));
obj2.add.state.topic = "stringify json object";
console.log(obj);
console.log(obj2);


Example 3: Converting Array to JSON String
*The code converts the array value into a JSON string using JSON.stringify().
*The resulting string result is logged along with its type.
*This demonstrates how JSON.stringify() converts JavaScript data types into JSON strings.

let value = ["Logan", 21, "Peter", 24];
let result = JSON.stringify(value);
console.log("value of result = " + result);["Logan",21,"Peter",24]but its type is string
console.log("type of result = " + typeof result);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Client Side:
*The JSON string is received as part of an API response 
*The client parses this string back into a JavaScript object using JSON.parse().
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
JavaScript JSON parse() Method
*The JSON.parse() method is used to convert a JSON string into a JavaScript object
*ItIt converts a JSON string into a JavaScript object.
*Throws a SyntaxError if the input string is not valid JSON.’s become important when dealing with data in JSON format,
*Accepts an optional reviver function to transform the parsed data.
*const s = '{"name": "Rahul", "age": 25, "city": "Delhi"}';
const obj = JSON.parse(s);
console.log(obj);
*Syntax:

JSON.parse(text[, reviver]);





Using the Reviver Function
*The reviver function allows you to modify the parsed values before they are returned.
*You can use it to manipulate data as needed during the parsing process.
*You can use it to manipulate data as needed during the parsing process.
*const s = '{"name": "Rahul", "age": 25, "city": "Delhi"}';
fetch("https://api.example.com/user")
  .then(res => res.json()) // Already gives JS object
  .then(obj => {
    console.log(typeof obj); // "object"
    console.log(obj.name);   // Works directly
  });
console.log(obj);
*Output
{ name: 'Rahul', age: 26, city: 'Delhi' }








Common Use Cases of JSON.parse()
1.When you receive a response from an API in JSON format, you need to convert the string to an object to work with it in JavaScript.
fetch("https://api.example.com/user")
  .then(res => res.json()) // Already gives JS object
  .then(obj => {
    console.log(typeof obj); // "object"
    console.log(obj.name);   // Works directly
  });




2.You can store objects as JSON strings in localStorage.(means value)
*When you retrieve them, you need to parse the string back into an object.
*// Saving an object
const a = { name: 'Rahul', age: 25 };
localStorage.setItem('user', JSON.stringify(a));

// Retrieving and parsing the object
const s = localStorage.getItem('user');
const obj = JSON.parse(s);
console.log(obj.name);  // Output: Rahul



3.3. Working with Configuration Files
*You can load configuration settings stored in a JSON file
*then parse it into a usable JavaScript object.
*const s = '{"theme": "dark", "language": "en"}';
const obj = JSON.parse(s);
console.log(obj.theme);




Handling Common Errors with JSON.parse()
* Invalid JSON Format: If the JSON string is malformed, JSON.parse() will throw a SyntaxError.
// Invalid JSON (keys must be in double quotes)
const s = "{name: 'Rahul', age: 25}";  
try {
    const obj = JSON.parse(s);  // Throws SyntaxError
} catch (e) {
    console.log("Error:", e.message);
}

*2. Non-String Input: JSON.parse() only accepts strings. If you try to parse a number or an array, it will throw an error.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
JSON Structure
*The basic structure of JSON consists of two primary components:
Objects: These are enclosed in curly braces {} and contain key-value pairs.
Arrays: Arrays are ordered lists enclosed in square brackets [].

Objects in JSON
*A JSON object is a collection of key-value pairs enclosed in curly braces {}.
*The key is always a string, and the value can be a variety of data types, including strings, numbers,arrays and even other objects.
*{
    "name": "Mohit Kumar",
    "age": 30,
    "isStudent": false
}



*Arrays in JSON
*A JSON array is an ordered collection of values enclosed in square brackets []
*These values can be of any type, including objects, arrays, or primitive data types.

Key JSON Data Types
JSON supports the following data types:

String: A sequence of characters, e.g., "hello".
Number: Integer or floating-point numbers, e.g., 10, 3.14.
Boolean: A value representing true or false.
Array: An ordered list of values.
Object: A collection of key-value pairs.
Null: A null value indicating the absence of any value.


How to Work with JSON in JavaScript
*In JavaScript, we can easily parse JSON data into a JavaScript object and vice versa using built-in methods like JSON.parse() and JSON.stringify().
1.Parse JSON to Object
*To parse a JSON string into a JavaScript object, use JSON.parse().
*let jsonS = '{"name": "Mohit", "age": 30}';
let jsonObj = JSON.parse(jsonS);

console.log(jsonObj.name);

2.To convert a Javascript object into a JSON string, use JSON.stringify()

Example:

let obj = {name: "Mohit", age: 30};
let jsonS= JSON.stringify(obj);

console.log(jsonS);
Output

{"name": "Mohit", "age" : 30}

pplications of JSON
APIs: JSON is the most commonly used format for API responses due to its lightweight nature.
Configuration Files: Many software systems use JSON files for storing configuration data.
Databases: Some NoSQL databases, like MongoDB, store data in JSON-like formats.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
JSON vs JavaScript Object
*JSON is a lightweight data format for transferring data,
*while JavaScript Objects are in-program data structures used for manipulation and logic.

What is JSON?
*JSON (JavaScript Object Notation) is a text-based data format designed for data exchange. It is language-independent and follows a strict syntax for storing and transmitting data.
*{
    "name": "Amit",
    "age": 25,
    "city": "Mumbai"
}
*JSON keys and string values must be enclosed in double quotes.
*It supports only limited data types such as strings, numbers, booleans, arrays, objects, and null.
*These are  not manipulated directly in JavaScript programs.


What is a JavaScript Object?
*A JavaScript Object is a data structure within JavaScript, used to store key-value pairs
*const user = {
    name: "Amit",
    age: 25,
    city: "Mumbai",
    greet: function () {
        console.log(`Hello, ${this.name}!`);
    },
};
*Keys are unquoted (but quotes can be used if needed), and strings can use single or double quotes.
*avaScript Objects can include methods (functions as values).
*These are manipulated directly in JavaScript programs.


Note:. Usage in APIs
JSON

JSON is used for transferring data in APIs.




JavaScript Object

JavaScript Objects are used for manipulating and processing data in memory.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Read JSON File Using JavaScript

1. Using the fetch() API:
*The fetch() API retrieves JSON files asynchronously
*parses them into JavaScript objects.
*using response.json()
fetch('sample.json')
    .then(response => response.json()) // Parse JSON
    .then(data => console.log(data)) // Work with JSON data
    .catch(error => console.error('Error fetching JSON:', error));
*Create a sample.json file with the desired data.
*Use fetch("sample.json"), then parse the response with .json()
*sample.json()file //sample.json
{
    "users": [
      {
        "site": "GeeksForGeeks",
        "user": "Shobhit"
      }
    ]
  }
*<html>
<head></head>
<body>
    <script>
        function fetchJSONData() {
            fetch('./sample.json')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();  
                })
                .then(data => console.log(data))  
                .catch(error => console.error('Failed to fetch data:', error)); 
        }
        fetchJSONData();  
    </script>
</body>
</html>
*here ✅ So !response.ok becomes true (i.e., triggers the error block) in the following scenarios:
404 Not Found: The sample.json file is missing.

403 Forbidden: You don’t have permission to access the file.



2. Using require() Method in Node.js
*In a Node.js environment, require() is a simple way to read JSON files synchronously
*const data = require('./sample.json');
console.log(data);
*const data = require('./sample.json');
console.log(data);



----------------------------------------------------------------------------------------------------------------------------------------------------------------------
How to Parse JSON Data in JavaScript?
*To parse JSON data in JavaScript, you can use the JSON.parse() method. This method converts a JSON string into a JavaScript object, making it easier to work with the data.
*1.parse json string of object
const jsonS = '{"name": "Rahul", "age": 25, "city": "Mumbai"}';
const obj = JSON.parse(jsonS);
console.log(obj.name);

*Parse json with array
const jsonA = '[{"name": "Anjali"}, {"name": "Vikas"}]';
const a = JSON.parse(jsonA);
a.forEach(person =>
	console.log(person.name));


*3. Parse Nested JSON
const nested = '{"person": {"name": "Ravi", "address": {"city": "Delhi", "pin": 110001}}}';
const obj = JSON.parse(nested);
console.log(obj)
console.log(obj.person.address.city);

4. Parse JSON with Validation
*const jsonS = '{"name": "Pooja", "age": 28}';
try {
    const obj = JSON.parse(jsonS);
    console.log(obj);
} catch (e) {
    console.error("Invalid JSON:", e.message);
}
*Wrapping JSON.parse() in a try...catch block handles invalid JSON inputs.
*This is especially useful when dealing with external or unverified data.

5. Parse JSON with a Reviver Function
*const jsonS = '{"name": "Amit", "age": "30"}';
const obj = JSON.parse(jsonS, (key, value) => {
    if (key === "age") return parseInt(value);
    return value;
});
console.log(obj.age);
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
JavaScript JSON Parser
*JSON can be in the following two structures:

Arrays i.e. Ordered list of items /values
Objects i.e. Collection of key-value pairs


Mapping JSON types to Entries or Attributes
*JSON types: object, array, string, number, boolean, null
*JavaScript equivalent:

JSON object ➝ JavaScript object ({})

JSON array ➝ JavaScript array ([])

JSON primitive values ➝ same JavaScript primitive values
In a JSON object, attributes (keys) are the property names.

Their values (entries) become the property values in JavaScript.

The structure is preserved exactly.
*and vice versa
*This means:

No data is lost.

Only the representation changes (from string to object or vice versa).

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
JavaScript JSON Complete Reference
*JavaScript Object keys() Method
The Object.keys() method in JavaScript is used to retrieve an array of the enumerable property names of an object. It returns an array containing the keys of the object.
*t returns an array containing the keys of the object.

Example 1: Enumerating Array Indices with Object.keys()
*The code uses the Object.keys() method to retrieve the enumerable properties of the array ['x', 'y', 'z'] and logs them to the console.
* Since arrays in JavaScript are also objects, their indices are treated as properties. Therefore, the output will be ['0', '1', '2'].
*// Returning enumerable properties
// of a simple array 
let check = ['x', 'y', 'z'];
console.log(Object.keys(check));


Example2:// Returning enumerable properties
// of an array like object.
let object = { 0: 'x', 1: 'y', 2: 'z' };
console.log(Object.keys(object));

Applications:
It can be used for returning enumerable properties of a simple array, an array-like object & an array-like object with random key ordering.

Exceptions:
*It causes a TypeError if the argument passed is not an object.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Object.valus()
*JavaScript object.values() method is used to return an array whose elements are the enumerable property values found on the object. 
*Syntax:
Object.values(obj);
Example 1:
// Returning enumerable property values of a simple array 
let check = ['x', 'y', 'z'];
console.log(Object.values(check));

Example 2
// Returning enumerable property values
// of an array like object. 
let object = { 0: '23', 1: 'geeksforgeeks', 2: 'true' };
console.log(Object.values(object))

Example3:// Returning enumerable property values
// of an array like object. 
let object = { 70: 'x', 21: 'y', 35: 'z' };
console.log(Object.values(object));

: In this example, an array-like object "check" has three property values { 70: 'x', 21: 'y', 35: 'z' } in random ordering and the object.values() method returns the enumerable property values of this array in the ascending order of the value of indices.


Exceptions:
It causes a TypeError if the argument passed is not an object.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
JavaScript Object entries() Method
*The Object.entries() method in JavaScript is used to retrieve an array of an object's enumerable property [key, value] pairs. This method is particularly useful for transforming and iterating over objects in situations where array-like manipulation is needed.
*Object.entries(obj);

Examples of JavaScript Object entries() Method
*// Creating an object constructor
// and assigning values to it
const obj = { 0: 'adam', 1: 'billy', 2: 'chris' };
    
// Displaying the enumerable property [key, value]
// pairs of the object using object.entries() method
console.log(Object.entries(obj)[1]);

Applications of Object.entries()

1.Iterating over Objects:
*You can easily iterate over the object’s properties by using Object.entries() in combination with array methods like forEach() or map().
*const obj = { name: 'Alice', age: 25, city: 'New York' };
Object.entries(obj).forEach(([key, value]) => {
    console.log(`${key}: ${value}`);
});

2.Converting Objects to Arrays:
*Since Object.entries() returns an array of arrays, it is useful for converting objects into arrays, especially when you need to work with array-specific functions.
*const obj = { name: 'Alice', age: 25, city: 'New York' };
const entries = Object.entries(obj);
console.log(entries);

3.Transforming Objects:
*const obj = { name: 'Alice', age: 25, city: 'New York' };
const transformed = Object.entries(obj).map(([key, value]) => [key.toUpperCase(), value]);
console.log(transformed);
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
How to Validate JSON Schema ?
*Validating JSON schema ensures that the structure and data types within a JSON document adhere to a predefined schema
Approach
*Import the Ajv Library, a popular JSON Schema validator for JavaScript.
*
----------------------------------------------------------------------------------------------------------------------------------------------------
JavaScript Promise
*JavaScript Promises make handling asynchronous operations like API calls, file loading, or time delays easier.
*Think of a Promise as a placeholder for a value that will be available in the future.
*Pending: The task is in the initial state.
*Fulfilled: The task was completed successfully, and the result is available.
*Rejected: The task failed, and an error is provided.


*let checkEven = new Promise((resolve, reject) => {
    let number = 4;
    if (number % 2 === 0) resolve("The number is even!");
    else reject("The number is odd!");
});
checkEven
    .then((message) => console.log(message)) // On success
    .catch((error) => console.error(error)); // On failure
Note:resolve(value): Marks the promise as fulfilled and provides a result.
Note:reject(error): Marks the promise as rejected with an error.




Let's See Advanced Promise Methods and Patterns for Effective Async Handling
1. Promise.all() Method

*The Promise.all() method in JavaScript is used for handling multiple asynchronous operations simultaneously
*It takes an array (or any iterable) of promises
*that resolves when all the input promises resolve
*or reject if any one of the promises fails. 
*This makes it ideal for scenarios where you need to wait for multiple asynchronous tasks to complete before proceeding.
*Syntax: 

Promise.all( iterable )
*Parameters:

iterable:An array or other iterable object containing promises. Non-promise values are treated as resolved promises.

Return values: It follows some rules to return a single promise
*If passed argument is empty, it returns a Promise that is already resolved.
*If the passed iterable contains no promises, it returns a Promise that is resolved asynchronously.
For all other cases, it returns a pending Promise.


Fulfillment and Rejection of Promise.all() Method: 


*Fulfillment:If the iterable is empty, it returns a promise that is resolved immediately.
*If all promises in the iterable are fulfilled, Promise.all() resolves to an array of the fulfilled values, maintaining the order of the promises in the input array.

Rejection:
*f any promise in the iterable is rejected, Promise.all() immediately rejects with that reason, ignoring the rest of the promises, even if they were resolved.





Examples of Using Promise.all()
1.Waiting for All Promises to Resolve
*In this example the Promise.all waits for all promises (p1, p2, p3) to resolve. It then returns an array of resolved values [50, 200, 'geek'], logging them once all promises are fulfilled.
*p1 = Promise.resolve(50);
p2 = 200
p3 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 100, 'geek');
});

Promise.all([p1, p2, p3]).then(function (values) {
    console.log(values);
});
*p1 = Promise.resolve(50);
p2 = 200
p3 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 100, 'geek');
});

Promise.all([p1, p2, p3]).then(function (values) {
    console.log(values);
});


2. Handling Promises with Timeouts
*// Simple promise that resolves
// after a given time
const tOut = (t) => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(`Completed in ${t}`)
        }, t)
    })
}

// Resolving a normal promise
tOut(1000).then(result => console.log(result + "<br>"))
// Completed in 1000

// Promise.all
Promise.all([tOut(1000), tOut(2000)])
       .then(result => console.log(result))

3.Example 3: Array of Promises with Varying Timeouts
*
--------------------------------------------------------------------------------------------------------------------------------------------------------------------

2. Promise.allSettled() Method
*Promise.allSettled() method in JavaScript is used to handle multiple promises concurrently
*This promise is fulfilled with an array of promise state descriptors, each describing the outcome of the corresponding promise in the input array
*Unlike Promise.all(), Promise.allSettled() does not short-circuit when one of the promises is rejected; instead, it waits for all promises to settle, providing information about each one
*// Illustration of Promise.allSettled() 
// Method in Javascript with Example

const p1 = Promise.resolve(50);
const p2 = new Promise((resolve, reject) =>
    setTimeout(reject, 100, 'geek'));
const prm = [p1, p2];

Promise.allSettled(prm).
    then((results) => results.forEach((result) =>
        console.log(result.status, result.value)));
*// Simple promise that resolves 
// After a given time 
const tOut = (t) => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(`Completed in ${t}`)
        }, t)
    })
}

// Resolving a normal promise 
tOut(1000).then(result => console.log(result))
// Completed in 1000 

// Promise.allSettled 
Promise.allSettled([tOut(1000), tOut(2000)]).then(result =>
    console.log(result))
*
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
*JavaScript Promise race() Method
*The Promise.race() method returns a promise that fulfills or rejects as soon as one of the promises in an iterable fulfills or rejects, with the value or reason from that promise.
*const promise1 = new Promise((resolve, reject) => {
    setTimeout(resolve, 600, "one");
});

const promise2 = new Promise((resolve, reject) => {
    setTimeout(resolve, 200, "two");
});

Promise.race([promise1, promise2]).then((value) => {
    console.log(value);
});
*here so the output will be two
*const promise1 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("five"), 500);
});

const promise2 = new Promise((resolve, reject) => {
    setTimeout(() => reject(new Error("six")), 100);
});

Promise.race([promise1, promise2]).then((value) => {
    console.log(value);
});
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
JavaScript Promise any() Method
*JavaScript Promise any() method is a static method that takes an array of promises as a parameter and returns the first fulfilled promise
*It returns a rejected value when all of the promises in the array return rejects or if the array is empty. 
*When all the promises are rejected an AggregateError is returned which contains the reason for rejection.


let prom1 = new Promise((resolve, reject) => {
    reject("Failure");
})
let prom2 = new Promise((resolve, reject) => {
    reject("Failed to load");
})
let prom3 = new Promise((resolve, reject) => {
    resolve("Worked");
})
let prom4 = new Promise((resolve, reject) => {
    resolve("Successful");
})

let prom = [prom1, prom2, prom3, prom4];

Promise.any(prom).then((val) => { console.log(val) });
*let prom1 = new Promise((resolve, reject) => {
    reject("Failure");
})
let prom2 = new Promise((resolve, reject) => {
    reject("Failed to load");
})
let prom3 = new Promise((resolve, reject) => {
    reject("Unsuccessful");
})
let prom4 = new Promise((resolve, reject) => {
    reject("Rejected");
})

let prom = [prom1, prom2, prom3, prom4];

Promise.any([])
    .then((val) => console.log(val))
    .catch(err => console.log(err));
Promise.any(prom)
    .then((val) => console.log(val))
    .catch(err => console.log(err));
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*The Promise.resolve() method in JavaScript returns a Promise object that is resolved with a given value. If the value is a promise, it returns that promise; otherwise, it resolves the value as a new promise
*What is Promise resolve() method 
The promise.resolve() method in JS returns a Promise object that is resolved with a given value. Any of the three things can happen: 

*If the value is a native promise means itself fetun promise then the promise is returned.
const p = Promise.resolve(33);
const same = Promise.resolve(p);
console.log(same === p); // true
According to MDN, when you pass a Promise, Promise.resolve() returns the exact same instance without creating a new one 
MDN Web Docs
+15
MDN Web Docs
+15
Reddit
+15
.


*Promise.resolve("Hello").then(v => console.log(v)); // logs "Hello"



----------------------------------------------------------------------------------------------------------------------------------------------------------------------The Promise.reject() method is used to return a rejected Promise object with a given reason for rejection. It is used for debugging purposes and selective error-catching.
*// Initialize a promise variable and
// use the reject() method with a
// reason as a parameter
let promise = Promise.reject("I am a reason of error");

// Catch the promise and pass the
// function for logging the error in console
promise.catch(function (error) {
    console.log(error);
});
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*JavaScript Promise finally() Method
*The finally() method of the Promise object is used to return a callback when a Promise is settled (either fulfilled or rejected).
*task.finally(onFinally() {
});
*Parameters:
This method has a single parameter as mentioned above and described below:

onFinally: It is the function that will be called when the Promise is settled.
*// Define the Promise
let task = new Promise((resolve, reject) => {
    setTimeout(() => {

        // Reject the Promise
        reject("Promise has been rejected!");
    }, 2000);
});

task
    .then(
        (data) => {
            console.log(data);
        },

        // Handle any error
        (error) => {
            console.log("Error:", error);
        }
    )

    // Specify the code to be executed 
    // after the Promise is settled
    .finally(() => {
        console.log(
            "This is finally() block that is " +
            "executed after Promise is settled"
        );
    });
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
8. Chaining with Promise.prototype.then() Method
*Allows sequential execution of promises
*passing results to the next .then() Method.
*Promise.resolve(5)
    .then((value) => value * 2) // Multiplies by 2
    .then((value) => value + 3) // Adds 3
    .then((finalValue) => console.log(finalValue)); // Logs: 13
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
*10. Dynamic Promise Creation
*function asyncTask(taskName) {
    return new Promise((resolve) => {
        setTimeout(() => 
            resolve(`${taskName} completed`), 1000);
    });
}
asyncTask("Download File").then((result) => 
    console.log(result));
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*let fetchData = new Promise((resolve) =>
    setTimeout(() =>
        resolve("Data loaded"), 3000));
let timeout = new Promise((_, reject) =>
    setTimeout(() =>
        reject("Timeout!"), 2000));
Promise.race([fetchData, timeout])
    .then((result) =>
        console.log(result))
    .catch((error) =>
        console.error(error));
means in this time file must be download ifnot the  the error
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
JavaScript Promise Chaining
*Promise chaining allows you to execute a series of asynchronous operations in sequence
*Allows multiple asynchronous operations to run in sequence.


Problem with Callbacks
*Callback Hell (Pyramid of Doom)
*Callback Hell (also called the Pyramid of Doom) happens when:

* 
*Each callback depends on the result of the previous async operation
*nestd callback
*for example getUser(101, (user) => {
  getOrders(user, (orders) => {
    processOrders(orders, (processed) => {
      sendEmail(processed, (confirmation) => {
        console.log("Order Processed:", confirmation);
      });
    });
  });
});
*function getUser(userId, callback) {
  setTimeout(() => {
    console.log("Fetched user");
    callback({ name: "Neha", id: userId });
  }, 1000);
}

*here first callback depends on the sresul of setimeout
*and then inside it we have getUser(101, (user) => {                        // 1️⃣ First async call
  getOrders(user, (orders) => {                 // 2️⃣ Nested inside getUser
    processOrders(orders, (processed) => {      // 3️⃣ Nested inside getOrders
      sendEmail(processed, (confirmation) => {  // 4️⃣ Nested inside processOrders
        console.log("Order Processed:", confirmation); // 5️⃣ Final output
      });
    });
  });
});
here user is first callback which comes from async operation than there us second callnack processed and onec callnack is defined inside another callback hence callback hell



*Error Handling in Nested Callbacks
*Handling errors in nested callbacks is complex, as you must check for errors at each level manually.
*readFile("data.txt", (err, data) => {
    if (err) {
        console.error("Error reading file:", err);
        return;
    }
    parseData(data, (err, result) => {
        if (err) {
            console.error("Error parsing data:", err);
            return;
        }
        console.log("Parsed data:", result);
    });
});
Note:Each function must handle errors separately, leading to repetitive code.


What is Callback Hell?
*Callback Hell in JavaScript can be defined as the situation where we have nested callbacks(functions passed as arguments to other functions) which makes the code difficult to read and debug
*The term "callback hell" describes the deep nesting of functions that can result in poor code readability and difficulty in debugging
*function task1(callback) {
    setTimeout(() => {
        console.log("Task One completed");
        callback();
    },);
}

function task2(callback) {
    setTimeout(() => {
        console.log("Task Two completed");
        callback();
    },);
}

task1(function () {
    task2(function () {
        console.log("Both tasks completed");
    });
});
*here each callback called after certsia task and each callback insude opother
*function task1(callback) {
    setTimeout(() => {
        console.log("Task One completed");
        callback();
    },);
}

function task2(callback) {
    setTimeout(() => {
        console.log("Task Two completed");
        callback();
    },);
}

task1(function () {
    task2(function () {
        console.log("Both tasks completed");
    });
}); 





Solution to Callback Hell
1.Promises
*Promises can help in avoiding the callback hell by providing the structured way to handle the asynchronous operations using the .then() method



2.Async/await
*Async/await can help in avoiding the callback hell by writing the asynchronous code that looks like the synchronous code due to which the code becomes more cleaner and readable and reduces the complexity
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Here comes the Array in js
1. Create Array using Literal
// Creating an Empty Array
let a = [];
console.log(a);

// Creating an Array and Initializing with Values
let b = [10, 20, 30];
console.log(b);



2.Create using new Keyword (Constructor)
*The "Array Constructor" refers to a method of creating arrays by invoking the Array constructor function.
*// Creating and Initializing an array with values
let a = new Array(10, 20, 30);

console.log(a);
 Both the above methods do exactly the same. Use the array literal method for efficiency, readability, and speed.



3.JavaScript - Insert Element in an array
1.At the Beginning
*This operation inserts an element at the start of the array. The unshift() method is commonly used, which mutates the original array and returns its new length.
*let a = [10, 20, 30, 40];
let e = 50;
a.unshift(e);
console.log(a);


2.At the End
*To add an element to the end of the array, the push() method is widely used. It mutates the array and returns its updated length.
*let a = [10, 20, 30, 40];
let e = 50;
a.push(e);
console.log(a);


3.At a Given Position
*let a = [10, 20, 30, 40];
let pos = 2;
let e = 50;
a.splice(pos, 0, e);
console.log(a);


4.Multiple Elements
*Using the splice() method, you can also insert multiple elements at a specified index.
*let a = [10, 20, 30, 40];
let pos = 2;
let e1 = 50, e2 = 60;
a.splice(pos, 0, e1, e2);
console.log(a);

---------------------------------------------------------------------------------------------------------------------------------------------------------------------
The following are different delete operations on a JS Array:
1.Delete from the Beginning of JS Array

*This operation removes the first element of an array, shifting all other elements to lower indices. The array's length is reduced by one. Methods like shift() can be used for this, which directly mutates the array.
*let a = [10, 20, 30, 40];
let res = a.shift();
console.log(res);


2.Delete an Element from the End of a JS Array
*This operation removes the last element in the array, reducing its length by one. This is typically achieved using the pop() method, which mutates the original array and returns the removed element.
*let a = [10, 20, 30, 40];
let res = a.pop();
console.log(res);


3.Delete from specific index
*a.splice(2,1)
*Syntax of splice(startIndex, deleteCount, ...itemsToAdd)




4.Delete First Occurrence from a JS Array
*To delete the first occurrence of a specific value, the value is located within the array (e.g., using indexOf()), and then it is removed. This operation ensures that only the first matching element is deleted while leaving other instances of the value intact.
*let a = [10, 20, 30, 20, 40];
let x = 20;
let idx = a.indexOf(x);
if (idx !== -1) {
  a.splice(idx, 1);
}
console.log(a);


5.Delete last Occurrence from a JS Array
This operation targets the last occurrence of a specific value in the array. Using methods like lastIndexOf() to locate the value ensures that only the last matching element is removed, leaving earlier instances unaffected.
*let a = [10, 20, 30, 20, 40];
let x = 20;
let idx = a.lastIndexOf(x);
if (idx !== -1) {
  a.splice(idx, 1);
}
console.log(a);


6.Delete all Occurrences in a JS Array
*let a = [10, 20, 30, 20, 40];
let x = 20;
let res = a.filter(e => e !== x);
console.log(res);
-------------------------------------------------------------------------------------------------------------------------------------------------------------------



7.Interesting Facts about JavaScript Arrays
1.Arrays are Objectss
*JavaScript arrays are actually specialized objects, with indexed keys and special properties.
*They have a length property and are technically instances of the Array constructor.
*const a = [10, 20, 30];
console.log(typeof a);

const a = [10, 20, 30];
console.log(typeof a);obect


You can add non-integer properties to arrays, making them work partly like objects. However, this is usually discouraged for clarity.
*let a = [1, 2, 3];

// Adding a property to array (NOT RECOMMEMDED IN PRACTICE)
a.name = "MyArray";

console.log(a.name);       

// Iterating through the array with `for...in`
// (NOT RECOMMENDED IN PRACTICE)
for (let key in a) {
  console.log(`${key}: ${a[key]}`);
}



2.Mixed Elements Allowed
*Like Python and unlike C/C++/Java,, we can have mixed type of elements in a JavaScript array.
*const a = [10, "hi", true];
console.log(a);



3.Dynamic Size
like python they have the dynamic size
*let a = [1, 2, 3];
a.push(4); 
console.log(a);



4.The .at() method, introduced in ES2022, allows access to array elements using negative indices, making it easy to retrieve elements from the end of an array without calculating the length.
*const arr = [10, 20, 30];
console.log(arr.at(-1));

5.Resizing an Array
*let a = [1, 2, 3, 4];
a.length = 2;
console.log(a);


6.Array Assignment
When we assign an array to another, it only creates one more reference to the same array.
// changed the original array
let a = [10, 20];
let b = a;

b.push(30);

console.log(a);


7.Spread Operator
*We get members of an array or a string. It helps us in copying in copying an array,
*concatenating arrays and passing array elements to different parameters of a function.
*// Arrat copy using spread operator
let a = [10, 20];
let b = [...a];

b.push(30);

console.log(a);
[10,20]


// Array concatenation using spread operator
let a = [10, 20];
let b = [30, 40];
let c = [...a, ...b]
console.log(c);


function add(x, y, z) {
  return x + y + z;
}

let a = [10, 20, 30];
console.log(add(...a));



8.Empty Elements in Array
*JavaScript allows empty elements in an array. When we access these elements, we get undefined.
*const a = [1, , , 3]; 
console.log(a); 
console.log(a[1]);


9.Direct Methods to Modify Arrays
JavaScript Array Iteration Methods
*Array iteration means accessing each element of an array.
*There are some examples of Array iteration methods are given below:



1.Method 1: Using Array forEach() Method
*The array.forEach() method calls the provided function (a callback function) once for each element of the array. 
*The provided function is user-defined, it can perform any kind of operation on an array.
*let emptytxt = "";
let  Arr = [23, 212, 9, 628, 22314];

function itrtFunction(value, index, array) {
    console.log(value);
}

Arr.forEach(itrtFunction);



2.Method 2: Using Array some() Method
*The array.some() method checks whether at least one of the elements of the array satisfies the condition checked by the argument function.
*let Arr1 = [41, 2, 54, 29, 49];
let someOver50 = Arr1.some(myFunction1);

console.log("Are some values over 50: " 
            + someOver50);

function myFunction1(value, index, array) {
    return value > 50;
}

let Arr2 = [41, 2, 14, 29, 49];
let allLessThan18 = Arr2.some(myFunction2);

console.log("Are all values less than 18: " 
            + allLessThan18);

function myFunction2(value, index, array) {
    return value < 18;
}




3.Method 3: Using Array map() Method
*The array.map() method creates an array by calling a specific function on each item in the parent array and it does not change the value or element of the parent array.
*let numArray = [1, 2, 3, 4];
let numArray2 = numArray.map(multiplyFunction);

console.log(numArray2);

function multiplyFunction(value, index, array) {
    return value + 100;
}




4.JavaScript Array findIndex() Method
*The findIndex() method in JavaScript is a powerful tool for locating the first element in an array that satisfies a provided testing function
*Return value

It returns the array element index if any of the elements in the array pass the test, otherwise, it returns -1.

Examples:
*Example 1: Finding Indices that contain odd numbers
*function isOdd(element, index, array) {
    return (element % 2 == 1);
}

console.log(([4, 6, 8, 12].findIndex(isOdd)));



Example 2:Example 2: Finding Indices that contain positive numbers
*// Input array contain elements
let array = [10, 20, 30, 110, 60];

// Testing method (element > 25).
function finding_index(element) {
    return element > 25;
}

// Printing the index of element which is satisfies
console.log(array.findIndex(finding_index));








5.JavaScript Array find() Method
*The find() method in JavaScript looks through an array and returns the first item that meets a specific condition you provide. If no item matches, it returns undefined. It skips any empty space in the array and doesn’t alter the original array.
*Return value:
It returns the array element value if any of the elements in the array satisfy the condition, otherwise, it returns undefined.
Different Examples of find() Method
Example 1: In this example we searches for the first positive element in the array. The find() method iterates through the array, returning the first element greater than 0. It logs the result to the console.
// Input array contain some elements.
let array = [-10, -0.20, 0.30, -40, -50];

// Method (return element > 0).
let found = array.find(function (element) {
    return element > 0;
});

// Printing desired values.
console.log(found);





6.JavaScript Array lastIndexOf() Method
*The JavaScript Array lastIndexOf() Method is used to find the index of the last occurrence of the search element provided as the argument to the function.
*Syntax: 
array.lastIndexOf(element, start)
Parameters:
This method accepts two parameters as mentioned above and described below: 

element: This parameter holds the element whose index will be returned.
start: This parameter is optional and it holds the starting point of the array, where to begin the search the default value is 0.

Return value:
This method returns the index of the last occurrence of the element. If the element cannot be found in the array, then this method returns -1.

let name = ['gfg', 'cse', 'geeks', 'portal'];
a = name.lastIndexOf('gfg')

// Printing result of method
console.log(a);





7.JavaScript Array indexOf() Method
*The indexOf() method in JavaScript is used to find the position of the first occurrence of a specific value in an array. If the value is not present, it returns -1. This method is handy for quickly determining where a particular item is located within an array.
*let name = ['gfg', 'cse', 'geeks', 'portal'];
a = name.indexOf('gfg')
// Printing result of method
console.log(a)s




8.JavaScript Array every() Method
*The every() method iterates over each array element, returning true if the provided function returns true for all elements
*Syntax
array.every(callback(element, index, array), thisArg);
// JavaScript code for every() method
function isEven(element, index, array) {
    return element % 2 == 0;
}
function func() {
    let arr = [56, 92, 18, 88, 12];

    // Check for even number
    let value = arr.every(isEven);
    console.log(value);
}
func();


9.JavaScript Array reduceRight() Method
*The Javascript arr.reduceRight() method in JavaScript is used to convert elements of the given array from right to left to a single value.
*array.reduceRight( function(total, currentValue, currentIndex, arr), 
initialValue )
*total: It is a required parameter and used to specify the initialValue or the previously returned value of the function.
*let arr = [175, 50, 25];

function subofArray(total, num) {
    return total - num;
}
function myGeeks(item) {
    console.log(arr.reduceRight(subofArray));
}
myGeeks()
answeris -200
*Note:by default it takes its initial values as 0
*let arr = [1.5, 20.3, 11.1, 40.7];

function sumofArray(sum, num) {
    return sum + Math.round(num);
}
function myGeeks(item) {
    console.log(arr.reduceRight(sumofArray, 0));
}
myGeeks();


10.JavaScript Array reduce() Method
*The JavaScript Array.reduce() method iterates over an array, applying a reducer function to each element, accumulating a single output value. It takes an initial value and processes elements from left to right, reducing the array to a single result
*const a = [2, 4, 6];

// Use reduce to calculate the sum
const sum = a.reduce((acc, x) => acc + x, 0);

console.log(sum);
const a = ["js", "html", "css"];

// Use reduce to calculate the sum of the lengths of the strings
const res = a.reduce((acc, str) => acc + str.length, 0);

console.log(res);



11.filter method
*The filter() method creates a new array containing elements that satisfy a specified condition. This method skips empty elements and does not change the original array.
*// JavaScript to illustrate findIndex() method
function canVote(age) {
    return age >= 18;
}

let filtered = [24, 33, 16, 40].filter(canVote);
console.log(filtered);
*function isPositive(value) {
    return value > 0;
}

let filtered = [112, 52, 0, -1, 944].filter(isPositive);
console.log(filtered);
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------Implementation of LinkedList in JavaScript
1. Creaing a Linked List

let list=new LinkedList();
list.append(20);
list.append(30);
list.printList()

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Map in JS
*A Map is a data structure that stores key-value pairs, where each key is unique
*Inserts keys in the order they were added.
*similar to an object but has some advantages:

Inserts keys in the order they were added.
Allows keys of any type, not just strings and symbols.
Provides better performance when dealing with large datasets.


Creating a Map
*Map() constructor allows two ways to create a Map in JavaScript.
*let myMap = new Map(); and then use map.set
*Passing an Array to new Map().

let myMap = new Map();
let anotherMap = new Map([
    ['name', 'GFG'],
    ['age', 30],
    ['city', 'Noida']
]);
console.log(anotherMap);


*Properties of JavaScript Map
set(key, val) : Adds or updates an element with a specified key and value.
get(key) : Returns the value associated with the specified key.
has(key) : Returns a boolean indicating whether an element with the specified key exists.
delete(key) : Removes the element with the specified key.
clear(): Removes all elements from the Map.
size: Returns the number of key-value pairs in the Map.

// Create a new Map
const myMap = new Map();

// 1. set(key, value)
myMap.set('name', 'GFG');
myMap.set('age', 25);
myMap.set(1, 'One'); 

console.log(myMap);


// 2. get(key)
console.log(myMap.get('name')); 
console.log(myMap.get('age')); 
console.log(myMap.get(1)); 
console.log(myMap.get('invalidKey')); 

// 3. has(key)
console.log(myMap.has('name'));
console.log(myMap.has('address')); 
console.log(myMap.has(1)); 

// 4. delete(key)
myMap.delete('age');
console.log(myMap.has('age')); 
console.log(myMap);

// 5. clear()
myMap.clear();
console.log(myMap); // Output: Map {}

console.log(myMap.size); 

myMap.set('a', 1);
myMap.set('b', 2);
console.log(myMap.size); 
console.log(myMap);


Advantages of Using Maps:
Key order: Maps remember the insertion order of the keys.
Performance: Inserting and retrieving elements from a Map are generally faster than objects, especially when the number of elements is large.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Implementation of Stack in JavaScript
*// Node class representing each element in the stack
class Node {
    constructor(value) {
        this.value = value;
        this.next = null;
    }
}

// Stack class using a Linked List
class Stack {
    constructor() {
        this.top = null; 
        this.size = 0;   
    }

    // Push operation
    push(value) {
        const newNode = new Node(value);
        newNode.next = this.top; 
        this.top = newNode; 
        this.size++;
    }

    // Pop operation
    pop() {
        if (this.isEmpty()) {
            console.log("Stack is empty!");
            return null;
        }
        const poppedValue = this.top.value;
        this.top = this.top.next;
        this.size--;
        return poppedValue;
    }

    // Peek operation
    peek() {
        return this.isEmpty() ? null : this.top.value;
    }

    // Check if the stack is empty
    isEmpty() {
        return this.size === 0;
    }

    // Returns the size of the stack
    getSize() {
        return this.size;
    }

    // Print stack elements
    printStack() {
        let current = this.top;
        let stackValues = [];
        while (current) {
            stackValues.push(current.value);
            current = current.next;
        }
        console.log("Stack:", stackValues.join(" -> "));
    }
}

// Example Usage
const stack = new Stack();
stack.push(10);
stack.push(20);
stack.push(30);
stack.printStack();
console.log("Top Element:", stack.peek()); 
console.log("Popped Element:", stack.pop()); 
stack.printStack();
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
*class Queue {
  constructor() {
    this.items = [];
  }

  enqueue(element) {
    this.items.push(element); 
  }

  dequeue() {
    return this.isEmpty() ? "Queue is empty" : this.items.shift();
  }

  peek() {
    return this.isEmpty() ? "Queue is empty" : this.items[0];
  }

  isEmpty() {
    return this.items.length === 0;
  }

  size() {
    return this.items.length;
  }

  print() {
    console.log(this.items.join(" -> "));
  }
}

// Example usage:
const queue = new Queue();
queue.enqueue(1);
queue.enqueue(2);
queue.enqueue(3);
queue.print();
console.log(queue.dequeue());
console.log(queue.peek()); 
console.log(queue.size());
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Javascript Error and Exceptional Handling
*In JavaScript, error and exception handling allows you to manage unexpected issues that occur during the execution of your code. 
What is JavaScript Error?
*Errors can occur during development or while the application is running, causing the program to stop executing properly. 

Types of Errors in JavaScript
*Syntax Errors: This happens when the code doesn't follow the correct syntax (e.g., missing parentheses, brackets, or commas).

*Reference Errors: Occurs when we try to access a variable that hasn’t been declared.
console.log(x); // ReferenceError: x is not defined

*Type Errors: This happens when a value is not of the expected type (e.g., trying to call a method on undefined).
let num = 5;
num.toUpperCase(); // TypeError: num.toUpperCase is not a function

*Range Errors: Occurs when a value is out of range, like passing an invalid number to a function.
let arr = Array(-1); // RangeError: Invalid array length

*Custom Errors
A custom error is an error that you create yourself to give more specific messages that make sense for your app.
*throw new Error("Custom error occurred");



Exception Handling in JavaScript
*Exception handling in JavaScript refers to the process of dealing with errors (exceptions) that occur during the execution of a program
*JavaScript provides some mechanisms to catch, handle, and recover from error instead of letting the error stop the program. The most common approach is using 



1.try...catch blocks.
Try Block: You place code that may potentially throw an error here. and it throws and error 
Catch Block: This block executes if an error occurs in the try block and catches the error
finally Block: The Code inside this block will always run, whether an error occurred or not.
try {
  // Code that may throw an error
} catch (error) {
  // Code to handle the error
} finally {
  // Optional: Code that runs regardless of success or error
}

try {
    let res = 10 / 0;
    if (!isFinite(res)) {
        throw new Error("Cannot divide by zero");
    }
    console.log(res);
} catch (error) {
    console.error("Error occurred:", error.message);
} finally {
    console.log("Execution completed");
}

*Here the error in try then throw
*catch catch and in err.message is the message cannot divide by 0
*



Advanced: try...catch with async/await
*async function fetchData() {
    try {
        let res = await fetch("https://api.example.com/data");
        let d = await res.json();
        console.log(d);
    } catch (error) {
        console.error("Error fetching data:", error.message);
    }
}
fetchData();

Note:here the catch will run if network issues
*Only if there's an actual error thrown — such as:

✅ Examples of situations where catch WILL run:
No internet / lost network connection.

The server is down (e.g., api.example.com is not reachable).

The request times out.

There's a CORS error (cross-origin blocked).

DNS issues or invalid domain.

These are all network-level errors.


but if there are htpp errors like the 500 or 404 catch will NOT run because fetch will not throw error
*const res = await fetch("https://api.example.com/data");
console.log(res.status); // Might be 404 or 500


*if (!res.ok) {
  throw new Error("Server returned error status: " + res.status);
}




Benefits of Exception Handling
Graceful Degradation: If the error occurs, then also the program keeps on running smoothly.
Error Logging: It helps by recording error details, making it easier to find and fix problems.
Prevents Crashes: It ensures the app doesn't completely stop working when something goes wrong.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
JavaScript Errors Throw and Try to Catch
*throw: Used to create custom errors and stop code execution.
*try...catch: Allows you to catch and handle errors, preventing the program from crashing.
try block: Contains code that may throw an error.
catch block: Catches and handles the error.


*finally: Executes code after the try and catch blocks, regardless of an error occurring.


Creating Custom Error Types
*You can create custom error types by extending the built-in Error class.
*This can be useful for more specific error handling.
class ValidationError extends Error {
    constructor(message) {
        super(message);
        this.name = "ValidationError";
    }
}

function validateInput(input) {
    if (input < 0) {
        throw new ValidationError("Input must be a positive number");
    }
    return "Valid input";
}

try {
    validateInput(-5); // Throws ValidationError
} catch (error) {
    console.log(`${error.name}: ${error.message}`);
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
JavaScript this Operator Interview Questions
1. Why this is Necessary in JavaScript?
*To provide access to an object's properties & methods from methods within that object.
Efficiency via code reuse.
Enables reusability and flexibility of functions across different objects.



2.2. What is the default value of this in the global context?
*console.log(this); // Window (browser) or global object (Node.js)

3.3. How does this behave inside a simple function?
*function show() {
    console.log(this); // Global object or undefined in strict mode
}
show();

4.44. What is the value of this in strict mode?
*"use strict";
function test() {
    console.log(this);
}
test();

5.5. How does 'this' work in an object method?
*const obj = {
    name: "GeeksforGeeks",
    greet() {
        console.log(this.name);
    }
};
obj.greet();


6.6. How does 'this' work with nested functions?
*const obj = {
    name: "GeeksforGeeks",
    greet() {
        function inner() {
            console.log(this);
        }
        inner();
    }
};
obj.greet();



7.7. How does this behave in an arrow function?
*const obj = {
    name: "Geeks",
    greet: () => {
        console.log(this.name); // undefined, as `this` refers to the enclosing scope
    }
};
obj.greet();

8.8 8. What is the value of this inside a class?
*class Person {
    constructor(name) {
        this.name = name;
    }
    greet() {
        console.log(this.name); // Refers to the instance of the class
    }
}
const p = new Person("GeeksforGeeks");
p.greet(); // "GeeksforGeeks"



9.9. What happens to 'this' in an IIFE?
*(function () {
    console.log(this); // Global object or undefined in strict mode
})();

10.10. How does 'this' behave in setTimeout?
*The this context in the callback:

In JavaScript, the value of this inside a function depends on how the function is called.
Note:The anonymous function inside setTimeout is not explicitly bound to any object. By default, setTimeout executes its callback function in the global context (or undefined in strict mode).
In strict mode (which is enabled by default in ES modules or when "use strict" is declared), this inside the setTimeout callback is undefined because it’s not explicitly bound to any object.
In non-strict mode, this would refer to the global object (window in browsers or global in Node.js), but since the global object doesn’t have a name property, it would still result in undefined.

const obj = {
    name: "GeeksforGeeks",
    greet() {
        setTimeout(function () {
            console.log(this.name); // undefined in strict mode
        }, 1000);
    }
};
obj.greet();

11. How to fix 'this' in setTimeout using arrow functions?
*const obj = {
    name: "GeeksforGeeks",
    greet() {
        setTimeout(() => {
            console.log(this.name); // "GeeksforGeeks"
        }, 1000);
    }
};
obj.greet();

12.12. What is 'this' when a function is bound?
*const obj = { name: "GeeksforGeeks" };
function greet() {
    console.log(this.name);
}
const boundGreet = greet.bind(obj);
boundGreet();

13.14. What happens when "this" is used in a constructor function?
*function Person(name) {
    this.name = name;
}
const p = new Person("GeeksforGeeks");
console.log(p.name);



15.15. How does "this" behave in chaining methods?
const obj = {
    count: 0,
    increment() {
        this.count++;
        return this;
    },
    show() {
        console.log(this.count);
        return this;
    }
};
obj.increment().increment().show();


16.16. What is "this" in an ES module?
*In an ES module, this is undefined at the top level because ES modules run in strict mode by default

17.17. What is " this " inside the an object returned by the function?
*function createObject() {
    return {
        name: "GeeksforGeeks",
        greet() {
            console.log(this.name);
        }
    };
}
const obj = createObject();
obj.greet();

18.19 . How does "this" behave in a forEach callback?
*[1, 2, 3].forEach(function () {
    console.log(this);
}, { name: "GeeksforGeeks" });
*The forEach method iterates over the array [1, 2, 3], with the second argument { name: "GeeksforGeeks" } explicitly set as this inside the loop.
*Output
{ name: 'GeeksforGeeks' }
{ name: 'GeeksforGeeks' }
{ name: 'GeeksforGeeks' }


22. How does "this" behave with Map key iteration in JavaScript?
*
const map = new Map();
map.set("key1", { name: "Geeks" });
map.set("key2", { name: "forGeeks" });
map.forEach(function (value, key) {
    console.log(this.name);
}, { name: "GeeksforGeeks" });

23.23 .How does "this" behave with async/await in JavaScript?
*const obj = {
    name: "GeeksforGeeks",
    async greet() {
        console.log(this.name);
    }
};
obj.greet();

GeeksforGeeks
In this example, obj.greet() is an asynchronous function that logs this.name. Since this refers to the obj object, it prints "GeeksforGeeks", which is the value of obj.name.


24.24. What is the value of " this " in an event handler in a DOM element?
*const obj = {
    name : "GeeksforGeeks",
    greet() {
        document.getElementById("btn").addEventListener(
            "click", function() {
                console.log(this.name); // Output: undefined
            });
    }
};
obj.greet();
*The this context in the event listener:

In JavaScript, the value of this inside a function depends on how the function is called.
For event listeners added via addEventListener, the this keyword inside the callback function refers to the DOM element that triggered the event (in this case, the button with ID "btn"), not the obj object.
*Fixing the Issue

1.Using bind:

Explicitly bind this to obj when setting the event listener.

javascriptconst obj = {
    name: "GeeksforGeeks",
    greet() {
        document.getElementById("btn").addEventListener(
            "click", function() {
                console.log(this.name); // GeeksforGeeks
            }.bind(this));
    }
};
obj.greet();

2.const obj = {
    name: "GeeksforGeeks",
    greet() {
        document.getElementById("btn").addEventListener(
            "click", () => {
                console.log(this.name); // GeeksforGeeks
            });
    }
};
obj.greet();

3.Using a Variable to Capture this:

Store this in a variable (e.g., self) and use it inside the callback.

javascriptconst obj = {
    name: "GeeksforGeeks",
    greet() {
        const self = this;
        document.getElementById("btn").addEventListener(
            "click", function() {
                console.log(self.name); // GeeksforGeeks
            });
    }
};
obj.greet();


Key Difference from setTimeout Example

In the setTimeout example from the previous question, this was undefined in strict mode because setTimeout executes its callback in the global context (or undefined in strict mode).
In this case, this is not undefined—it is the DOM element (the button) that triggered the event. However, the result is still undefined for this.name because the button element does not have a name property matching obj.name.

Summary
The undefined output occurs because the this keyword inside the event listener callback refers to the DOM element (the button with ID "btn") rather than the obj object. Since the button does not have a name property, this.name is undefined. To fix this, you can use bind, an arrow function, or a variable to ensure this refers to obj, allowing this.name to correctly resolve to "GeeksforGeeks".21.7sHow can Grok help?



-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

JavaScript String Interview Questions and Answers
5. What is the difference between == and === when comparing strings in JavaScript?
*The == operator compares strings for equality after type conversion, while === compares both value and type without type conversion. For example:

console.log('5' == 5);
console.log('5' === 5); 


7. How do you extract a part of a string in JavaScript?
*7. How do you extract a part of a string in JavaScript?
You can use methods like slice(), substring(), and substr() to extract parts of a string. For example:

let str = 'Hello World';
console.log(str.slice(0, 5)); // Output: 'Hello'
console.log(str.substring(0, 5)); // Output: 'Hello'
console.log(str.substr(0, 5)); // Output: 'Hello'

8. How do you check if a string contains a specific substring in JavaScript?
*You can use the includes() method to check if a string contains a specific substring. For example:
*let str = 'Hello World';
console.log(str.includes('World')); // Output: true
console.log(str.includes('world')); // Output: false


99.9. How do you replace a substring within a string in JavaScript?
The replace() method is used to replace a substring with another string This method replaces the first occurrence of the specified substring. For example:
let str = 'Hello World';
let newStr = str.replace('World', 'JavaScript'); // Output: 'Hello JavaScript'


10.10. How do you trim whitespace from a string in JavaScript?
*You can use the trim(), trimStart(), and trimEnd() methods to remove whitespace from both ends, the start, or the end of a string. These methods are useful for cleaning up input data. For example:
*let str = '  Hello World  ';
console.log(str.trim()); // Output: 'Hello World'
console.log(str.trimStart()); // Output: 'Hello World  '
console.log(str.trimEnd()); // Output: '  Hello World'


JavaScript String Intermediate Interview Questions
1. How do you split a string into an array in JavaScript?
*The split() method splits a string into an array of substrings based on a specified separator.
let str = "Hello and Welcome to GeeksforGeeks";
let words = str.split(" ");
console.log(words);


2.2. What is the purpose of the charAt() method in JavaScript?
*The charAt() method returns the character at a specified index in a string. For example:

let str = 'Hello';
console.log(str.charAt(1)); // Output: 'e'
It’s useful for accessing individual characters in a string.



3.3. How do you repeat a string multiple times in JavaScript?
*The repeat() method repeats a string a specified number of times. This method is useful for generating repeated patterns. For example:


4.4. How do you pad a string to a certain length in JavaScript?
*You can use padStart() and padEnd() methods to pad a string to a certain length. For example:
*let str = '5';
console.log(str.padStart(3, '0')); // Output: '005'
console.log(str.padEnd(3, '0')); // Output: '500'

5.5. What does the localeCompare() method do in JavaScript?
*The string.localeCompare() is an inbuilt method in JavaScript that is used to compare any two elements and returns a positive number if the reference string is lexicographically greater than the compare string and a negative number if the reference string is lexicographically smaller than the compare string and zero (0) if the compare and reference strings are equivalent. 
*referenceString.localeCompare(compareString);
*Example 1: This example shows the basic use of the string.localeCompare() Method in Javascript, here we compare the strings based on the locale-specific sorting order and return -1 because "apple" comes before "banana" alphabetically.




let str1 = "apple";
let str2 = "banana";
let result = str1.localeCompare(str2);
console.log(result);


*Example 2:// An alphabet "n" comes before "z" which
// gives a negative value
let a = 'n'.localeCompare('z');
console.log(a)

// Alphabetically the word "gfg" comes after
// "geeksforgeeks" which gives a positive value
let b = 'gfg'.localeCompare('geeksforgeeks');
console.log(b)

// "gfg" and "gfg" are equivalent which
// gives a value of zero(0)
c = 'a'.localeCompare('a');
console.log(c)


6. How do you find the index of a substring in a string in JavaScript?
*The indexOf() method returns the index of the first occurrence of a substring, or -1 if not found. It’s useful for searching within strings. For example:
*let str = 'Hello World';
console.log(str.indexOf('World')); // Output: 6
console.log(str.indexOf('world')); // Output: -1


7.7. What is the difference between slice() and substring()?
*Both slice() and substring() extract parts of a string, but slice() allows negative indices and substring() does not. For example:
*let str = 'Hello World';
console.log(str.slice(-5)); // Output: 'World'
console.log(str.substring(6)); // Output: 'World'



8.8. How do you convert a string to an array of characters in JavaScript?
*You can use the split('') method to convert a string to an array of characters. For example:

9. How do you check if a string starts with a specific substring in JavaScript?
*The startsWith() method checks if a string starts with a specified substring. For example:
let str = 'Hello World';
console.log(str.startsWith('Hello')); // Output: true


10.10. How do you check if a string ends with a specific substring in JavaScript?
*The endsWith() method checks if a string ends with a specified substring. For example:

let str = 'Hello World';
console.log(str.endsWith('World')); // Output: true


11.11. How do you use template literals in JavaScript?
*Template literals are enclosed in backticks (`) and can contain placeholders for variables and expressions. For example:

let name = 'World';
let greeting = `Hello, ${name}!`; // Output: 'Hello, World!'


12.17. How do you find the last occurrence of a substring in a string in JavaScript?
Use the lastIndexOf() method:

let str = 'Hello World Hello';
console.log(str.lastIndexOf('Hello')); // Output: 12
This method returns the index of the last occurrence of the substring.


18. How do you check if a string matches a regular expression in JavaScript?
*JavaScript String match() Method
*The match() method in JavaScript is used for identifying and retrieving substrings that fit a specified pattern, defined by a regular expression. 
*It is often used when you need to find particular patterns within strings, enabling efficient text processing.
*This method returns an array of matched substrings or null if no match is found.
*Syntax:
string.match(regExp);
Parameters:
string: The string to be searched for a specific pattern.
regexp: A regular expression object or pattern string used to search the string.

*Return Value:
Array: An array of matched substrings if matches are found.
null: If no match is found, the method returns null.

Example 1: Using the /g Flag (Global)
*The global (g) flag ensures that all occurrences of the matching pattern are returned.
*// Initializing function to demonstrate match()
// method with "g" para
function matchString() {
    let string = "Welcome to geeks for geeks";
    let result = string.match(/eek/g);
    console.log("Output : " + result);
} matchString();



Example2:Example 2: Using the /i Flag (Case-Insensitive)
*// Initializing function to demonstrate match()
// method with "i" para
function matchString() {
    let string = "Welcome to GEEKS for geeks!";
    let result = string.match(/eek/i);
    console.log("Output : " + result);
} matchString();




19. How do you search for a match in a string using a regular expression in JavaScript?
*JavaScript String search() Method
*The search() method in JavaScript is used to search for a specified substring within a string.
*It returns the index of the first occurrence of the substring within the string. If the substring is not found, it returns -1.
*// Taking input a string.
let string = "GeeksforGeeks";

// Taking a regular expression.
let re1 = /G/;
let re2 = /e/;
let re3 = /s/;

// Printing the index of matching alphabets
console.log(string.search(re1));
console.log(string.search(re2));
console.log(string.search(re3));


0
1
4


20.20. How do you replace all occurrences of a substring in a string in JavaScript?
*Use the replace() method with a global regular expression:

let str = 'Hello World Hello';
let newStr = str.replace(/Hello/g, 'Hi'); // Output: 'Hi World Hi'





JavaScript String Advance Interview Questions
1.1. What is the difference between substring() and substr() in JavaScript?
*The substring() method extracts characters between two indices, while substr() extracts a specified number of characters starting from a given index:

let str = 'Hello World';
console.log(str.substring(6, 11)); // Output: 'World'
console.log(str.substr(6, 5)); // Output: 'World'
substring() takes two arguments: the starting and ending indices, and extracts characters from the start index up to, but not including, the end index. If the end index is omitted, it extracts to the end of the string. substr(), on the other hand, takes the start index and the number of characters to extract. While substring() is useful when you know the exact indices, substr() is more useful when you know the length of the substring you need.


2.22. How do you reverse a string in JavaScript?
*You can reverse a string by converting it into an array, reversing the array, and then joining it back into a string. For example:

let str = 'Hello';
let reversedStr = str.split('').reverse().join('');
console.log(reversedStr); // Output: 'olleH'


3.How can you count the occurrence of a specific character in a string?
*. How can you count the occurrence of a specific character in a string?
You can use the split() method to create an array where each instance of the character is an element, and then subtract one from the length of this array. For example, to count the number of 'l's in "Hello":

let str = 'Hello';
let count = str.split('l').length - 1;
console.log(count); // Output: 2


4.5. How do you format a string using replace() and regular expressions?
*
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
LinkedIn
*20 JavaScript Interview Questions for Frontend Developers in 2025

1. Explain the difference between Promise.all(), Promise.allSettled(), and Promise.any().
2. How does the Nullish Coalescing Operator (??) differ from OR (||)?
3. What are WeakMap and WeakSet, and when would you use them?
4. Explain the concept of Top-Level Await.
5. How do you implement proper error boundaries in JavaScript applications?
6. What happens when you mix async/await with .then()/.catch()?
7. Explain the event loop with microtasks and macrotasks.
8. How would you implement a retry mechanism for failed API calls?
9. What is the difference between debouncing and throttling? Implement both.
10. How does JavaScript garbage collection work, and how can you optimize for it?
11. Explain tree shaking and how it affects your code.
12. What are Web Workers and when would you use them?
13. How do you handle state management without external libraries?
14. Explain the Module Federation pattern.
15. What are JavaScript Proxies and how can they be used?
16. How would you implement a custom hook pattern in vanilla JavaScript?
17. How do you prevent XSS attacks in JavaScript applications?
18. What is Content Security Policy and how does it affect JavaScript?
19. How would you test asynchronous code without external testing frameworks?
20. Explain different types of JavaScript testing (unit, integration, e2e) and their trade-offs.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
How does the Nullish Coalescing Operator (??) differ from OR (||)?

*1. Logical OR (||)

Returns the right-hand operand if the left-hand operand is falsy.

Falsy values in JavaScript are:
false, 0, -0, 0n, "", null, undefined, NaN

👉 So it treats all falsy values the same.

console.log(0 || 5);        // 5  (because 0 is falsy)
console.log("" || "hello"); // "hello" (because "" is falsy)
console.log(null || "x");   // "x"
console.log(undefined || 10); // 10

2. Nullish Coalescing (??)

Returns the right-hand operand only if the left-hand operand is null or undefined.

Does not treat 0, false, or "" as nullish.

👉 It’s safer for default values when 0, false, or "" are valid inputs.

console.log(0 ?? 5);        // 0   (because 0 is not null/undefined)
console.log("" ?? "hello"); // ""  (because "" is not null/undefined)
console.log(false ?? true); // false
console.log(null ?? "x");   // "x"
console.log(undefined ?? 10); // 10

🔑 Key Difference

|| → considers any falsy value as "missing."

?? → considers only null and undefined as "missing."

✅ Use || when you want to fall back on any falsy value.
✅ Use ?? when you only want to fall back on null or undefined (preserve 0, false, "" as valid).
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
what is wekmap
*A WeakMap is like a Map (key → value), but:

Keys must be objects (not primitives).
*Keys are weakly held: if the object used as a key has no other references, it is garbage-collected automatically.
*Not iterable (you can’t loop through its keys/values).

*Methods: set, get, has, delete.
*let wm = new WeakMap();

let obj = { name: "Alice" };
wm.set(obj, "some data");

console.log(wm.get(obj)); // "some data"

obj = null; // object no longer referenced
// At this point, the { name: "Alice" } object is eligible for garbage collection
// and will be automatically removed from WeakMap


Use Case:

Storing metadata or private data about objects without preventing them from being garbage collected.
Example: Caching computed values for DOM nodes.



2.WeakSet
*A WeakSet is like a Set, but:

Only objects can be added (no primitives).

Objects are weakly held (if no references remain, they’re garbage collected).

Not iterable.

Methods: add, has, delete.

let ws = new WeakSet();

let user = { id: 1 };
ws.add(user);

console.log(ws.has(user)); // true

user = null; // user object eligible for garbage collection
// WeakSet will automatically remove it
------------------------------------------------------------------------------------------------------------------------------------------------------------------------what is tla
*Traditionally, await could only be used inside an async function:

async function fetchData() {
  let res = await fetch("https://api.example.com/data");
  let data = await res.json();
  console.log(data);
}
fetchData();


If you tried to use await at the top level (outside an async function), you'd get a syntax error.

✅ But with Top-Level Await (TLA), introduced in ES2022, you can now use await directly at the top level of an ES module.
*// topLevelAwait.mjs

const res = await fetch("https://api.example.com/data");
const data = await res.json();

console.log(data);

*Where Can You Use It?

Only in ES modules (.mjs or "type": "module" in package.json).

Not allowed in CommonJS modules.

Supported in modern browsers and Node.js v14.8+ (behind flag earlier, stable now).


Uses
*Why is it Useful?

Simpler Module Initialization

If your module needs to fetch config, connect to DB, or load data before exporting, you can await it directly.

// db.mjs
import { connect } from "db-client";

export const connection = await connect();


Now, any module that imports connection will wait until the DB is ready.

*Dynamic Imports

Works seamlessly with import() since await is allowed at the top level:

if (Math.random() > 0.5) {
  const { default: chalk } = await import("chalk");
  console.log(chalk.green("Lucky!"));
}



Caveats

Blocking imports
If module A uses TLA, any module importing A must wait until its await finishes.
👉 This can introduce startup delays if misused.

Not in CommonJS
Won’t work in old Node.js scripts with require().

Error handling
Use try/catch, otherwise errors propagate to module loading.

try {
  const res = await fetch("bad_url");
  console.log(await res.json());
} catch (err) {
  console.error("Failed:", err);
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
How to implement error boundaries in the js app

1.Global Error Handling so that they can be seen in browser are:
*.
window.onerror = (msg, url, line, col, error) => {
  console.error("Global error caught:", msg, error);
  // Send to logging service
};
window.onunhandledrejection = (event) => {
  console.error("Unhandled Promise Rejection:", event.reason);
};



2.
ode.js

process.on("uncaughtException", (err) => {
  console.error("Uncaught Exception:", err);
  // Graceful shutdown
});

process.on("unhandledRejection", (reason, promise) => {
  console.error("Unhandled Rejection:", reason);
});

------------------------------------------------------------------------------------------------------------------------------------------------------------------------
What happens when you mix async/await with .then()/.catch()?

Case 1:Exactly 👍 Let’s break that down carefully:

Case 1: .catch() handles the error without rethrowing
async function example() {
  const data = await fetch("bad_url")
    .then(res => res.json())
    .catch(err => {
      console.error("Error in fetch:", err);
      // no rethrow → so implicitly returns undefined
    });

  console.log("Result:", data);
}
example();
Step by step:

fetch("bad_url") rejects (network error).

.then(res => res.json()) is skipped (because Promise rejected).

.catch(err => { ... }) runs → logs the error.

It returns undefined (since nothing explicitly returned).

That means the Promise chain resolves to undefined.

await sees a fulfilled Promise with value undefined.

data = undefined.



Case 2: .catch() rethrows
async function example() {
  const data = await fetch("bad_url")
    .then(res => res.json())
    .catch(err => {
      console.error("Error in fetch:", err);
      throw err; // rethrow
    });

  console.log("Result:", data);
}
example();


🔹 Step by step:

fetch("bad_url") rejects.

.then(...) skipped.

.catch(err => { throw err }) runs.

Instead of resolving, it rethrows → Promise becomes rejected again.

await now sees a rejected Promise → so example() throws inside.

Since there’s no try/catch in example(), the error bubbles out.

✅ Final output:

Error in fetch: TypeError: Failed to fetch   // logged inside catch
Uncaught (in promise) TypeError: Failed to fetch   // unhandled rejection from await




✅ So summary:

If .catch handles the error (no rethrow) → await gets a fulfilled Promise with the return value of .catch (often undefined).

If .catch rethrows → await gets a rejected Promise, so it behaves like a throw inside your async function.

👉 That’s why we say:

.catch converts rejection → fulfillment if it doesn’t rethrow.

.catch propagates rejection if it rethrows.



Case 3: .catch handles the error (no rethrow)
async function example() {
  try {
    const data = await fetch("bad_url")
      .then(res => res.json())
      .catch(err => {
        console.error("Error in fetch:", err);
        return "fallback"; // handling gracefully
      });

    console.log("Result:", data);
  } catch (err) {
    console.error("Caught in try/catch:", err);
  }
}
example();


🔎 What happens:

fetch("bad_url") rejects.

.catch runs, logs error, and returns "fallback".

The chain resolves → await gets fulfilled with "fallback".

No error thrown into try/catch.



case4:
async function example() {
  try {
    const data = await fetch("bad_url")
      .then(res => res.json())
      .catch(err => {
        console.error("Error in fetch:", err);
        throw err; // propagate the rejection
      });

    console.log("Result:", data);
  } catch (err) {
    console.error("Caught in try/catch:", err);
  }
}
example();

What happens:

fetch("bad_url") rejects.

.catch runs, logs error, and rethrows.

Promise chain stays rejected.

await sees a rejection → behaves like throw inside the async function.

That thrown error is caught by the try/catch in the function.

✅ Output:

Error in fetch: TypeError: Failed to fetch
Caught in try/catch: TypeError: Failed to fetch


Final takeaway:

If .catch handles and returns → outer try/catch never runs, because the chain is fulfilled.

If .catch rethrows → outer try/catch catches it, because the chain stays rejected.


Case 5:Case 3: No inner .catch, rely only on outer try/catch
async function example() {
  try {
    const data = await fetch("bad_url")
      .then(res => res.json()); // no .catch here

    console.log("Result:", data);
  } catch (err) {
    console.error("Caught in try/catch:", err);
  }
}
example();


🔎 What happens:

fetch("bad_url") rejects.

No inner .catch, so the promise remains rejected.

await sees the rejection → throws inside the async function.

Outer try/catch catches it.

✅ Output:

Caught in try/catch: TypeError: Failed to fetch


✨ Key point:

await is basically “try/catch-aware”: if the awaited promise rejects, it throws into your function so the outer try/catch can handle it.

That’s why in practice, most developers skip .catch inside a chain and just wrap await calls in try/catch.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Great question 🚀 — this is one of the most important concepts in JavaScript!
Let’s break it down step by step.

🔹 1. The Event Loop — what is it?

JavaScript is single-threaded: it can do only one thing at a time.
The event loop is the mechanism that allows JS to handle asynchronous code (like timers, promises, I/O, etc.) without blocking execution.

🔹 2. The Two Queues

The event loop organizes tasks into two main groups:

✅ Macrotasks (a.k.a. Task Queue)

Scheduled tasks like:

setTimeout

setInterval

setImmediate (Node.js)

DOM events

requestAnimationFrame

✅ Microtasks (a.k.a. Job Queue)

Higher-priority, run right after the current code but before macrotasks:

Promise.then() / catch() / finally()

async/await (because under the hood it uses promises)

queueMicrotask()

MutationObserver

🔹 3. Execution Order

Run synchronous (main script) code first.

Empty the microtask queue completely (all queued jobs).

Take the next macrotask, run it.

After finishing that macrotask → again, empty all microtasks.

Repeat forever.

🔹 4. Example in Action
console.log("Start");

setTimeout(() => {
  console.log("Macrotask (setTimeout)");
}, 0);

Promise.resolve()
  .then(() => {
    console.log("Microtask 1");
  })
  .then(() => {
    console.log("Microtask 2");
  });

console.log("End");

🟢 Output:
Start
End
Microtask 1
Microtask 2
Macrotask (setTimeout)


🔎 Why?

"Start" & "End" → synchronous, run immediately.

Then the event loop checks → microtasks first (then callbacks).

Only after finishing microtasks, it moves to macrotask (setTimeout).
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
How would you implement a retry mechanism for failed API calls?
*When an API call fails (timeout, 500 error, network issue, etc.), instead of failing immediately, you try again a few times before giving up.
This improves reliability.
*async function fetchWithRetry(url, options = {}, retries = 3, delay = 1000) {
  try {
    let res = await fetch(url, options);

    if (!res.ok) {
      throw new Error(`HTTP error! Status: ${res.status}`);
    }

    return await res.json();
  } catch (err) {
    if (retries > 0) {
      console.warn(`Retrying... attempts left: ${retries}`, err);
      await new Promise(resolve => setTimeout(resolve, delay));
      return fetchWithRetry(url, options, retries - 1, delay);
    } else {
      throw err; // rethrow after final failure
    }
  }
}

*🔹 4. When to Retry?

✅ Network errors (timeouts, DNS errors, connection lost).

✅ 5xx server errors (500, 502, 503, 504).

❌ Don’t retry for 4xx client errors (e.g., 400, 401, 404) → they won’t magically succeed.

So, include a condition check:

if (res.status >= 500 || res.status === 429) {
  // Retryable error
}

Axios → has built-in retry with axios-retry

fetch-retry → wraps fetch with retry behavior

Example with axios-retry:

import axios from "axios";
import axiosRetry from "axios-retry";

const api = axios.create();
axiosRetry(api, { retries: 3, retryDelay: axiosRetry.exponentialDelay });

api.get("/data")
  .then(res => console.log(res.data))
  .catch(err => console.error("Failed after retries", err));
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Concept	Behavior
Debounce	Waits until after the user has stopped triggering the event for X ms. Only then executes the function.
Throttle	Executes the function at most once per X ms, no matter how many times the event happens.


🔹 Debounce vs Throttle (Core Difference)
Concept	Behavior
Debounce	Waits until after the user has stopped triggering the event for X ms. Only then executes the function.
Throttle	Executes the function at most once per X ms, no matter how many times the event happens.
🔹 Debounce

👉 Imagine a search bar.
You don’t want to call the API on every keystroke (s, se, sea, sear, …).
You only want to call it after the user stops typing for 500ms.

function debounce(fn, delay) {
  let timer;
  return function (...args) {
    clearTimeout(timer); // cancel previous timer
    timer = setTimeout(() => {
      fn.apply(this, args); // execute after delay
    }, delay);
  };
}

// Example usage: search input
const handleSearch = debounce((query) => {
  console.log("Searching for:", query);
}, 500);

document.getElementById("search").addEventListener("input", (e) => {
  handleSearch(e.target.value);
});


✅ Effect: Only runs once after typing pauses.

🔹 Throttle

👉 Imagine a scroll event.
When you scroll, events can fire dozens of times per second.
But you only want to handle it once per second.

function throttle(fn, limit) {
  let inThrottle = false;
  return function (...args) {
    if (!inThrottle) {
      fn.apply(this, args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
}

// Example usage: scroll event
const handleScroll = throttle(() => {
  console.log("Scroll event triggered:", new Date().toLocaleTimeString());
}, 1000);

window.addEventListener("scroll", handleScroll);


✅ Effect: Runs at most once every 1000ms, no matter how fast you scroll.

🔹 Quick Analogy

Debounce:
"I’ll only speak after you stop interrupting me for 2 seconds."

Throttle:
"You can only interrupt me once every 2 seconds, no matter what."

🔹 Bonus – Combined (Debounce + Throttle)

Sometimes you want both behaviors:

Run immediately (leading call).

Also run after the burst of events stops (trailing call).

Example: User scrolls → update position right away + after scrolling stops.

Libraries like Lodash’s _.debounce and _.throttle support these options (leading/trailing).

✅ Summary:

Use Debounce → when action should only happen after a pause (search bar, resize end).

Use Throttle → when action should happen at regular intervals (scroll, window resize, mouse move).
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------*JavaScript is a garbage-collected language, meaning you don’t manually allocate and free memory (like in C/C++). Instead, the runtime (V8 in Chrome/Node.js, SpiderMonkey in Firefox, etc.) automatically reclaims memory.


1. Memory Allocation
*1. Memory Allocation

When you create objects, arrays, functions, closures, etc., memory is allocated in the heap.

Example:

let user = { name: "Alice" }; // object allocated in heap

2.Garbage collectors use the idea of reachability:

If a value can be reached through a chain of references from roots (like global variables, local variables in stack, closures, DOM nodes), it is considered alive.

If it’s no longer reachable → it becomes garbage and eligible for collection.

Example:




Common GC Pitfalls

Even though JS has GC, memory leaks still happen if you accidentally keep references alive.

2.2. Closures holding onto memory
function outer() {
  let bigData = new Array(1000000);
  return function inner() {
    console.log(bigData.length);
  };
}
let fn = outer(); // bigData stays in memory as long as fn exists

3. Detached DOM nodes
let div = document.createElement("div");
document.body.appendChild(div);
document.body.removeChild(div);
// ❌ If JS variable still references it:
let ref = div; // GC won’t free it

4. Event listeners not removed
let button = document.getElementById("btn");
button.addEventListener("click", () => console.log("hi"));
// If button removed from DOM but listener not removed → leak


How to help to gc
*Be careful with closures
Don’t capture large objects if you only need a small part.
*Avoid accidental DOM leaks
If you remove a node, also clear any JS references to it.
*element.removeEventListener("click", handler);
clearInterval(intervalId);


*Use WeakMap / WeakSet for caches

Keys are weakly held → auto-GC when no longer referenced elsewhere.

let cache = new WeakMap();
let obj = {};
cache.set(obj, "data");
obj = null; // entry auto-removed, no memory leak
*Monitor memory usage

Use Chrome DevTools → Memory tab → take heap snapshots.

Look for objects that should have been GC’d but still exist.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Explain tree shaking and how it affects your code.

*Tree shaking is a dead code elimination technique used by modern JavaScript bundlers (like Webpack, Rollup, esbuild, Vite).
*It analyzes your code and removes unused (unreachable) exports from the final bundle, making it smaller and faster.


How It Works
*Tree shaking mainly relies on ES6 module syntax (import / export) because they are static (resolved at compile time), unlike CommonJS (require) which is dynamic.


xample:

// utils.js
export function add(a, b) { return a + b; }
export function multiply(a, b) { return a * b; }

// app.js
import { add } from './utils.js';

console.log(add(2, 3));


✅ In the final bundle, only add will be included.
❌ multiply is never imported → removed during bundling.

🔹 When Tree Shaking Works Best

Use ES Modules (import / export) – not CommonJS (require).

Avoid dynamic imports where the bundler can’t determine usage.

const lib = require(someVariable); // ❌ breaks tree shaking


Mark libraries as "side-effect free" in package.json:

{
  "sideEffects": false
}


This tells bundlers: "If no exports are used, drop the whole file."



Tree Shaking Example in Bundlers

Without tree shaking:

import * as _ from "lodash";
console.log(_.flatten([[1,2],[3,4]]));


👉 This pulls all of lodash into the bundle (hundreds of KB).

With tree shaking (or better: lodash-es):

import { flatten } from "lodash-es";
console.log(flatten([[1,2],[3,4]]));


👉 Only flatten is included.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*Web Workers are a browser feature that lets you run JavaScript in a separate background thread, parallel to the main UI thread.

Normally, JS runs on a single thread (the main thread). If you do heavy computations there (e.g., image processing, data crunching), the UI freezes and becomes unresponsive.
*Web Workers are a browser feature that lets you run JavaScript in a separate background thread, parallel to the main UI thread.
*Web Workers solve this by letting you offload heavy tasks to a worker thread. The worker can do CPU-heavy work without blocking the UI.


How Web Workers Work

*You create a Worker with new Worker("worker.js").

*The worker runs in its own isolated environment (no direct DOM access).

*Communication is via message passing (postMessage / onmessage).

*Workers run in parallel, but not truly multi-threaded in the sense of shared memory (except via SharedArrayBuffer).


How Web Workers Work

You create a Worker with new Worker("worker.js").

The worker runs in its own isolated environment (no direct DOM access).

Communication is via message passing (postMessage / onmessage).

Workers run in parallel, but not truly multi-threaded in the sense of shared memory (except via SharedArrayBuffer).

Example:

main.js

// Create a worker
const worker = new Worker("worker.js");

// Send data to the worker
worker.postMessage({ numbers: [1, 2, 3, 4, 5] });

// Listen for results
worker.onmessage = function(e) {
  console.log("Sum from worker:", e.data);
};


worker.js

onmessage = function(e) {
  const numbers = e.data.numbers;
  const sum = numbers.reduce((a, b) => a + b, 0);

  // Send result back to main thread
  postMessage(sum);
};


✅ The calculation happens in the worker thread, UI never blocks.


When to Use Web Workers

Use them when you have CPU-intensive tasks that would otherwise freeze the UI:

Heavy computations

Data processing, math-heavy calculations.

Example: running an LRU cache computation, encryption, machine learning inference.

Image / video / audio processing

Image resizing, filtering, transcoding.

Large JSON parsing / data transformations

Parsing huge files, log analysis, data visualization.

Background tasks

Syncing with server, prefetching data, caching, text indexing.


🔹 Step 1: Create a Worker File (filterWorker.js)
// filterWorker.js
onmessage = function (e) {
  const { data, query } = e.data;

  // Simulate heavy computation
  const filtered = data.filter((item) =>
    item.toLowerCase().includes(query.toLowerCase())
  );

  // Send result back to React
  postMessage(filtered);
};

🔹 Step 2: Use It in a React Component (App.js)
import React, { useEffect, useState, useRef } from "react";

export default function App() {
  const [data] = useState(() =>
    Array.from({ length: 500000 }, (_, i) => `Item ${i}`)
  );
  const [query, setQuery] = useState("");
  const [filteredData, setFilteredData] = useState([]);
  const workerRef = useRef(null);

  useEffect(() => {
    // Create worker dynamically
    workerRef.current = new Worker(new URL("./filterWorker.js", import.meta.url));

    workerRef.current.onmessage = (e) => {
      setFilteredData(e.data);
    };

    return () => {
      workerRef.current.terminate();
    };
  }, []);

  useEffect(() => {
    if (query && workerRef.current) {
      workerRef.current.postMessage({ data, query });
    } else {
      setFilteredData([]);
    }
  }, [query, data]);

  return (
    <div className="p-6">
      <h1 className="text-xl font-bold">React + Web Worker Filtering</h1>
      <input
        className="border p-2 mt-4"
        type="text"
        placeholder="Search items..."
        value={query}
        onChange={(e) => setQuery(e.target.value)}
      />

      <p className="mt-2 text-gray-600">
        Showing {filteredData.length} results
      </p>

      <ul className="h-64 overflow-auto border mt-4 p-2">
        {filteredData.slice(0, 100).map((item, i) => (
          <li key={i}>{item}</li>
        ))}
      </ul>
    </div>
  );
}

🔹 How It Works

We generate 500,000 items in memory (huge dataset).

Instead of filtering in React (which would block the main thread), we send data + query to the Web Worker.

Worker filters in the background, returns results via postMessage.

React updates UI with no lag while typing.

✅ Benefits:

The UI remains smooth, even with a half-million dataset.

Filtering happens off the main thread.

Easy to plug into existing apps.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------Explain the Module Federation pattern.

he Problem (Before Module Federation)

Imagine you have two React apps:

App1 → Checkout

App2 → Product Page

Both apps need to use the same Button component.
Normally, you would:

Put the Button in a shared library (npm package).

Install that library in both apps.

Rebuild & redeploy both apps whenever the Button changes.


This is slow, and teams cannot work independently.

🚀 The Solution (Module Federation)

Module Federation (Webpack 5 feature) says:

"Why not let apps directly import code from each other at runtime instead of bundling everything at build time?"

So:

App1 (Remote) → Exposes its Button (like saying, "Hey world, I have a Button you can use!")

App2 (Host) → Dynamically imports that Button at runtime (like plugging in Lego pieces).

No npm publish, no rebuilding both apps — only the changed app is redeployed.



⚙️ How It Works

At build time:

Webpack creates a small container file (remoteEntry.js) in App1.

This file knows what modules App1 is exposing.

At runtime:

App2 loads that container (remoteEntry.js) from App1’s server.

App2 then imports the Button component as if it was local.

📌 Example
App1 (Remote → exposes Button)
// webpack.config.js
new ModuleFederationPlugin({
  name: "app1",
  filename: "remoteEntry.js",
  exposes: {
    "./Button": "./src/Button",  // expose Button
  },
  shared: ["react", "react-dom"], // prevent duplicate React
});

App2 (Host → consumes Button)
// webpack.config.js
new ModuleFederationPlugin({
  name: "app2",
  remotes: {
    app1: "app1@http://localhost:3001/remoteEntry.js", // fetch from App1
  },
  shared: ["react", "react-dom"],
});

App2 Code
import React from "react";

const RemoteButton = React.lazy(() => import("app1/Button"));

function App() {
  return (
    <div>
      <h1>App2 consuming Button from App1</h1>
      <React.Suspense fallback="Loading...">
        <RemoteButton />
      </React.Suspense>
    </div>
  );
}

export default App;


👉 Here, App2 did not bundle Button inside its build.
Instead, it downloads the Button from App1 when running.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
What are JavaScript Proxies and how can they be used?


What is a Proxy?

A Proxy is like a "middleman" for an object or function.
Instead of interacting directly with the object, you interact with the proxy — and it decides what to do.

You create one like this:

const proxy = new Proxy(target, handler);


target → the real object you want to wrap

handler → an object that defines traps (functions that “intercept” operations)

🔹 Why use Proxies?

They let you intercept and control operations like:

Getting a property (obj.name)

Setting a property (obj.age = 30)

Checking if a property exists ("name" in obj)

Function calls
…and many more.

🔹 Example 1: Logging Access
const user = { name: "Neha", age: 25 };

const proxyUser = new Proxy(user, {
  get(target, property) {
    console.log(`Reading ${property}`);
    return target[property];
  },
  set(target, property, value) {
    console.log(`Writing ${property} = ${value}`);
    target[property] = value;
    return true;
  }
});

console.log(proxyUser.name); // Logs: Reading name → "Neha"
proxyUser.age = 26;     


2.🔹 Example 2: Validation

Stop invalid data from being stored:

const person = new Proxy({}, {
  set(target, property, value) {
    if (property === "age" && typeof value !== "number") {
      throw new Error("Age must be a number!");
    }
    target[property] = value;
    return true;
  }
});

person.age = 30;    // ✅ Works
person.age = "old"; // ❌ Error

🔹 Example 3: Default Values

Return a fallback if a property doesn’t exist:

const defaults = new Proxy({}, {
  get(target, property) {
    return property in target ? target[property] : "Not Found";
  }
});

console.log(defaults.username); // "Not Found"
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
How do you prevent XSS attacks in JavaScript applications?

*ross-Site Scripting (XSS) happens when attackers inject malicious scripts into your app (e.g., <script>alert('hacked')</script>), which then run in the user’s browser.
*

1.1. Escape & Sanitize User Input

Never trust user input (form fields, query params, API data).

Sanitize input before storing or rendering.

In React / Angular / Vue, the frameworks escape HTML by default (safe).

If you must render raw HTML, sanitize it first with libraries like:

DOMPurify

sanitize-html

import DOMPurify from "dompurify";

const safeHTML = DOMPurify.sanitize(userInput);
element.innerHTML = safeHTML;


2.22. Use Safe DOM APIs
*Avoid innerHTML, document.write(), outerHTML.

Use textContent or createElement instead:

3.33. Content Security Policy (CSP)
*Add CSP headers from the backend to restrict what scripts can run.

Example (Node.js / Express):

app.use((req, res, next) => {
  res.setHeader("Content-Security-Policy", "default-src 'self'");
  next();
});


This blocks inline scripts and only allows resources from your domain.

4.4🔹 6. HTTP-Only & Secure Cookies

Store session tokens in HttpOnly cookies (not accessible via JS) → prevents theft through XSS.

Set-Cookie: sessionId=abc123; HttpOnly; Secure; SameSite=Strict














